


=== availabilitycheck.cpp 



=== availabilitycheckwnd.cpp 
#include "availabilitycheckwnd.h"

#include <QtConcurrent/QtConcurrent>
#include <QtWidgets>

#include "excelapp.h"
#include "global.h"

#include <QAxObject>

AvailabilityCheckWnd::AvailabilityCheckWnd(QWidget *parent) : QWidget(parent) {
  setupUI();

  // 可用性检查比较费时，所以多线程，这里是完成后的回调绑定
  connect(&watcherCheckAvail, SIGNAL(finished()), this, SLOT(postCheckAvail()));

  connect(&watcherPrepareInputs, SIGNAL(finished()), this,
          SLOT(postPrepareInputs()));
}

void AvailabilityCheckWnd::setupUI() {
  // 三个 tabs
  mainTabs = new QTabWidget;

  // 1. 初始需求；2. 可用量；3：缺料；

  // 1. 初始需求：
  // 上面：复选框：库存、生产订单、采购需求、采购订单、委外订单；
  // 中间：tableview；
  // 底部：可用性；

  chkOnlyStock = new QCheckBox(tr("仅包含库存"));
  //  chkInv = new QCheckBox(tr("库存"));
  //  chkPP = new QCheckBox(tr("生产订单未入库"));
  //  chkPR = new QCheckBox(tr("采购需求未关联"));
  //  chkPO = new QCheckBox(tr("采购订单未到货"));
  //  chkMO = new QCheckBox(tr("委外订单未到货"));
  //  chkPO2 = new QCheckBox(tr("采购订单到货未入库"));
  //  chkMO2 = new QCheckBox(tr("委外订单到货未入库"));

  connect(chkOnlyStock, &QCheckBox::clicked, this,
          &AvailabilityCheckWnd::updateOnlyStockStatus);

  chkOnlyStock->setChecked(false);
  //  chkInv->setChecked(true);
  //  chkPP->setChecked(true);
  //  chkPR->setChecked(true);
  //  chkPO->setChecked(true);
  //  chkMO->setChecked(true);
  //  chkPO2->setChecked(true);
  //  chkMO2->setChecked(true);

  QHBoxLayout *hCond = new QHBoxLayout;
  hCond->addWidget(chkOnlyStock);
  //  hCond->addWidget(chkInv);
  //  hCond->addWidget(chkPP);
  //  hCond->addWidget(chkPR);
  //  hCond->addWidget(chkPO);
  //  hCond->addWidget(chkPO2);
  //  hCond->addWidget(chkMO);
  //  hCond->addWidget(chkMO2);

  hCond->addStretch();

  tvInputs = new QTableView;
  tvInputsModel = new QStandardItemModel;
  tvInputs->setStyleSheet("font: 8pt 微软雅黑;");
  //  tvInputs->setEditTriggers(QAbstractItemView::NoEditTriggers);

  inputModel = new InputDemandModel(matInputs);
  tvInputs->setModel(inputModel);

  btnCheckAvl = new QPushButton("可用性检查");
  connect(btnCheckAvl, &QPushButton::clicked, this,
          &AvailabilityCheckWnd::checkAvailAsyn);

  btnUpload = new QPushButton("上载");
  connect(btnUpload, &QPushButton::clicked, this,
          &AvailabilityCheckWnd::loadDemand);

  QPushButton *btnExportInput = new QPushButton("下载");
  connect(btnExportInput, &QPushButton::clicked, this,
          [this]() { exportTableView(tvInputs); });

  QHBoxLayout *hbtn = new QHBoxLayout;
  hbtn->addWidget(btnCheckAvl);
  hbtn->addWidget(btnUpload);
  hbtn->addWidget(btnExportInput);

  QVBoxLayout *vInput = new QVBoxLayout;
  vInput->addLayout(hCond);
  vInput->addWidget(tvInputs);
  vInput->addLayout(hbtn);

  QWidget *tabInput = new QWidget;
  tabInput->setLayout(vInput);
  mainTabs->addTab(tabInput, "需求输入");

  // 3、缺料
  // 上部：复选框仅显示缺料，
  // 中部：tableview；
  // 底部：导出；

  chkOnlyShortage = new QCheckBox(tr("仅显示缺料"));
  chkOnlyShortage->setChecked(true);
  chkVirtual = new QCheckBox(tr("显示虚拟件"));
  chkVirtual->setChecked(false);

  QPushButton *btnRefreshShortage = new QPushButton("刷新");
  connect(btnRefreshShortage, &QPushButton::clicked, this,
          [this]() { renderShortage(checkResults); });

  QHBoxLayout *hShortage = new QHBoxLayout;
  hShortage->addWidget(chkOnlyShortage);
  hShortage->addWidget(chkVirtual);
  hShortage->addWidget(btnRefreshShortage);
  hShortage->addStretch();

  tvShortage = new QTableView;
  tvShortageModel = new QStandardItemModel;
  tvShortage->setStyleSheet("font: 8pt 微软雅黑;");
  tvShortage->setEditTriggers(QAbstractItemView::NoEditTriggers);

  QPushButton *btnExportShortage = new QPushButton("导出");
  connect(btnExportShortage, &QPushButton::clicked, this,
          [this]() { exportTableView(tvShortage); });

  QVBoxLayout *vShortage = new QVBoxLayout;
  vShortage->addLayout(hShortage);
  vShortage->addWidget(tvShortage);
  vShortage->addWidget(btnExportShortage);

  QWidget *tabShortage = new QWidget;
  tabShortage->setLayout(vShortage);
  mainTabs->addTab(tabShortage, "缺料统计");

  // 2. 可用量
  // 上部：tableview：根据用户的选择，当前所有的可用量；
  // 底部：导出；
  tvAvailability = new QTableView;
  tvAvailabilityModel = new QStandardItemModel;
  tvAvailability->setStyleSheet("font: 8pt 微软雅黑;");
  tvAvailability->setEditTriggers(QAbstractItemView::NoEditTriggers);

  QPushButton *btnExportAvl = new QPushButton("导出");
  connect(btnExportAvl, &QPushButton::clicked, this,
          [this]() { exportTableView(tvAvailability); });

  QVBoxLayout *vAvl = new QVBoxLayout;
  vAvl->addWidget(tvAvailability);
  vAvl->addWidget(btnExportAvl);

  QWidget *tabAvl = new QWidget;
  tabAvl->setLayout(vAvl);
  // 不需要显示
  mainTabs->addTab(tabAvl, "全部量");

  // 主窗口
  QVBoxLayout *vMain = new QVBoxLayout;
  vMain->addWidget(mainTabs);
  setLayout(vMain);

  setWindowTitle(tr("缺料查看"));
  showMaximized();
}

void AvailabilityCheckWnd::updateOnlyStockStatus() {
  // 更新全局变量，计算可用量时使用；
  gOnlyStock = chkOnlyStock->isChecked();
}

void AvailabilityCheckWnd::loadDemand() {
  //  loadDemandTxt();
  loadDemandExcel();

  // 如果输入为空
  if (matInputs.size() == 0) {
    return;
  }

  // 多线程调用；
  // 先更新 UI
  QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));
  btnUpload->setEnabled(false);

  // 启动多线程，执行完毕后，自动回调；
  // 处理上载的文件 loadDemandExcel，
  // 执行 prepareInputs，再执行回调函数 postPrepareInputs；
  QFuture<void> future = QtConcurrent::run([this]() { this->prepareInputs(); });
  watcherPrepareInputs.setFuture(future);
}

void AvailabilityCheckWnd::loadDemandTxt() {
  QString fileName =
      QFileDialog::getOpenFileName(this, QString(), QString(), "txt(*.txt)");

  if (fileName.isEmpty()) {
    QMessageBox::information(this, tr("Code"), tr("请选择文件"));
    return;
  }

  QFile file(fileName);
  if (file.open(QFile::ReadOnly)) {
    matInputs.clear();
    while (!file.atEnd()) {
      QString line = file.readLine(200).simplified().trimmed();

      if (line.length() == 0) {
        break;
      }

      QStringList cs = line.split(QRegExp(",| "), QString::SkipEmptyParts);

      MaterialItem item;
      item.invCode = cs.at(0);
      item.inputDemandQty = cs.at(1).toInt();
      matInputs.push_back(item);
    }
  }

  file.close();
}

void AvailabilityCheckWnd::loadDemandExcel() {
  QString fileName = QFileDialog::getOpenFileName(this, QString(), QString(),
                                                  "excel(*.xls *.xlsx)");
  if (fileName.isEmpty()) {
    return;
  }

  QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));

  qDebug() << "reading:" << fileName;

  QElapsedTimer timer;
  timer.start();

  QAxObject *pWorkbooks = ExcelApp::instance()->getWorkbooks();

  QAxObject *workbook =
      pWorkbooks->querySubObject("Open (const QString &)", fileName);

  // 读取 sheet1 的内容
  QAxObject *worksheets = workbook->querySubObject("WorkSheets");
  QAxObject *worksheet = worksheets->querySubObject("Item(int)", 1);

  qDebug() << timer.elapsed() << " Open excel sheet1. ";

  // 从第二行开始，最多 1000 个
  //  timer.restart();
  QString dataRange = "A2:C1000";
  QAxObject *range = worksheet->querySubObject("Range(QString)", dataRange);
  QVariant excel_data = range->dynamicCall("Value()");
  qDebug() << timer.elapsed() << " read range.";

  // 取得读到的所有行
  QVariantList rows = excel_data.toList();

  int rowCount = rows.count();
  qDebug() << timer.elapsed() << "total rows: " << rowCount;

  if (rowCount == 0) {
    qDebug() << "no data. ";
    return;
  }

  QVariantList row;
  matInputs.clear();
  for (int i = 0; i < rowCount; i++) {
    row = rows[i].toList();

    QString firstCol = row[0].toString();

    // 第一列：料号；
    // 为空，表示结束
    if (firstCol.length() == 0) {
      qDebug() << "The last: " << i;
      break;
    }

    // 第三列是数量；
    QString qtyCol = row[2].toString();

    MaterialItem item;
    item.invCode = firstCol;
    item.inputDemandQty = qtyCol.toInt();
    matInputs.push_back(item);
  }

  // 关闭 excel 文件；
  workbook->dynamicCall("Close(Boolean)", false);

  QApplication::restoreOverrideCursor();
}

void AvailabilityCheckWnd::prepareInputs() {
  // thread 中，不能处理界面
  //  btnUpload->setEnabled(false);

  // thread 中，只处理逻辑，不处理界面
  // 输入的初始需求
  avlCheck.initBom();
  avlCheck.updateInfo(matInputs);
}

void AvailabilityCheckWnd::renderAllSupply(
    const std::vector<MaterialItem> &allSupply) {
  tvAvailability->setUpdatesEnabled(false);
  tvAvailabilityModel->clear();

  int row = 0;
  for (const auto &i : allSupply) {
    tvAvailabilityModel->setItem(row, 0, new QStandardItem(i.invCode));
    tvAvailabilityModel->setItem(row, 1, new QStandardItem(i.part.cInvName));
    tvAvailabilityModel->setItem(row, 2, new QStandardItem(i.part.getType()));
    tvAvailabilityModel->setItem(
        row, 3, new QStandardItem(QString::number(i.inventoryQty)));
    tvAvailabilityModel->setItem(row, 4,
                                 new QStandardItem(QString::number(i.ppQty)));
    tvAvailabilityModel->setItem(row, 5,
                                 new QStandardItem(QString::number(i.prQty)));
    tvAvailabilityModel->setItem(row, 6,
                                 new QStandardItem(QString::number(i.poQty)));
    tvAvailabilityModel->setItem(row, 7,
                                 new QStandardItem(QString::number(i.moQty)));
    tvAvailabilityModel->setItem(
        row, 8, new QStandardItem(QString::number(i.getAllAvlQty())));

    row += 1;
  }

  // 形成 model: 标题
  QStringList headers;
  headers << "料号"
          << "名称"
          << "类型"
          << "库存量"
          << "PP"
          << "PR"
          << "PO"
          << "MO"
          << "总供给";

  tvAvailabilityModel->setHorizontalHeaderLabels(headers);
  tvAvailability->setModel(tvAvailabilityModel);
  tvAvailability->resizeColumnsToContents();
  tvAvailability->setUpdatesEnabled(true);
}

void AvailabilityCheckWnd::renderShortage(
    const std::vector<MaterialItem> &shortages) {
  bool onlyShortage = chkOnlyShortage->isChecked();
  bool showVirtual = chkVirtual->isChecked();

  std::vector<MaterialItem> showList;

  for (const auto &i : shortages) {

    if (onlyShortage && i.netDemandQty < 0) {
      continue;
    }

    if (!showVirtual && i.part.bSelf == 1 && i.part.iSupplyType == 3) {
      continue;
    }

    MaterialItem a{i};
    showList.push_back(a);
  }

  // 输入的初始需求
  tvShortage->setUpdatesEnabled(false);
  tvShortageModel->clear();

  int row = 0;
  for (const auto &i : showList) {
    tvShortageModel->setItem(row, 0,
                             new QStandardItem(QString::number(i.maxLevel)));
    tvShortageModel->setItem(row, 1, new QStandardItem(i.invCode));
    tvShortageModel->setItem(row, 2, new QStandardItem(i.part.cInvName));
    tvShortageModel->setItem(row, 3, new QStandardItem(i.part.getType()));
    //    tvShortageModel->setItem(
    //        row, 4, new QStandardItem(QString::number(i.inputDemandQty)));
    tvShortageModel->setItem(row, 4,
                             new QStandardItem(QString::number(i.ppDemandQty)));
    tvShortageModel->setItem(row, 5,
                             new QStandardItem(QString::number(i.moDemandQty)));
    tvShortageModel->setItem(
        row, 6, new QStandardItem(QString::number(i.grossDemandQty)));
    tvShortageModel->setItem(
        row, 7, new QStandardItem(QString::number(i.inventoryQty)));
    tvShortageModel->setItem(row, 8,
                             new QStandardItem(QString::number(i.ppQty)));
    tvShortageModel->setItem(row, 9,
                             new QStandardItem(QString::number(i.prQty)));
    tvShortageModel->setItem(row, 10,
                             new QStandardItem(QString::number(i.poQty)));
    tvShortageModel->setItem(row, 11,
                             new QStandardItem(QString::number(i.poQty2)));
    tvShortageModel->setItem(row, 12,
                             new QStandardItem(QString::number(i.moQty)));
    tvShortageModel->setItem(row, 13,
                             new QStandardItem(QString::number(i.moQty2)));
    tvShortageModel->setItem(
        row, 14, new QStandardItem(QString::number(i.netDemandQty)));

    row += 1;
  }

  // 形成 model: 标题
  QStringList headers;
  headers << "层级"
          << "料号"
          << "名称"
          << "类型"
          //          << "用户输入需求"
          << "生产订单未入库需求"
          << "外协未入库需求"
          << "总需求"
          << "库存量"
          << "生产订单未入库"
          << "采购需求未关联"
          << "采购未到货"
          << "采购到货未入库"
          << "外协未到货"
          << "外协到货未入库"
          << "净需求";

  tvShortageModel->setHorizontalHeaderLabels(headers);
  tvShortage->setModel(tvShortageModel);
  tvShortage->resizeColumnsToContents();
  tvShortage->setUpdatesEnabled(true);
}

void AvailabilityCheckWnd::checkAvailDo() {
  // 耗时的操作；
  checkResults = avlCheck.doCheck(matInputs);
}

void AvailabilityCheckWnd::checkAvailability() {
  // 同步执行

  // 首先更新 UI
  btnCheckAvl->setEnabled(false);
  btnUpload->setEnabled(false);

  // 执行耗时操作
  checkAvailDo();

  // 操作结束后，再更新 UI
  renderShortage(checkResults);
  mainTabs->setCurrentIndex(idxShortage);

  renderAllSupply(avlCheck.allSupply);

  btnCheckAvl->setEnabled(true);
  btnUpload->setEnabled(true);
}

void AvailabilityCheckWnd::checkAvailAsyn() {
  // 异步执行
  // 先处理 UI；
  QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));
  btnCheckAvl->setEnabled(false);
  btnUpload->setEnabled(false);

  // 再起线程，做计算；线程中，不处理任何 UI 相关的操作；
  // 启动多线程
  QFuture<void> future = QtConcurrent::run([this]() { this->checkAvailDo(); });

  // 计算完毕后，通过 watcher 的 connect 做后续 UI 更新；
  // 绑定 watcher
  watcherCheckAvail.setFuture(future);
}

void AvailabilityCheckWnd::exportTableView(QTableView *view) {
  QString fileName = QFileDialog::getSaveFileName(
      this, "保存",
      QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation),
      "Excel 文件(*.xlsx)");

  if (fileName != "") {
    bool ok = ExcelApp::instance()->exportTableView(view, fileName);
    if (ok) {
      QMessageBox::information(this, tr("导出"), tr("导出完毕"));
    }
  }
}

void AvailabilityCheckWnd::postCheckAvail() {
  // 异步线程结束后，更新 UI
  renderShortage(checkResults);
  mainTabs->setCurrentIndex(idxShortage);

  renderAllSupply(avlCheck.allSupply);

  btnCheckAvl->setEnabled(true);
  btnUpload->setEnabled(true);

  QApplication::restoreOverrideCursor();
}

void AvailabilityCheckWnd::postPrepareInputs() {
  // 异步线程结束后，更新 UI
  qDebug() << "view should updated: "
           << QString::number(inputModel->inputsMats.size());
  //  tvInputs->repaint();
  //  tvInputs->setModel(inputModel);
  inputModel->notifyChanges();
  //  tvInputs->resizeColumnsToContents();

  btnUpload->setEnabled(true);

  QApplication::restoreOverrideCursor();
}

/////////////////////////////////////////////////////////////////////////

InputDemandModel::InputDemandModel(std::vector<MaterialItem> &inputs,
                                   QObject *parent)
    : inputsMats{inputs}, QAbstractTableModel(parent) {}

int InputDemandModel::rowCount(const QModelIndex &parent) const {
  Q_UNUSED(parent);

  return static_cast<int>(inputsMats.size());
}

int InputDemandModel::columnCount(const QModelIndex &parent) const {
  Q_UNUSED(parent);

  return colCount;
}

QVariant InputDemandModel::data(const QModelIndex &index, int role) const {
  // 判断行、列，是否超出范围
  int row = index.row();
  int col = index.column();

  //  qDebug() << QString("(%1, %2, %3)")
  //                  .arg(QString::number(row), QString::number(col),
  //                       QString::number(role));

  if ((row >= rowCount(index)) || (col >= columnCount())) {
    return QVariant();
  }

  // 把列映射到不同的属性上；
  if ((role == Qt::DisplayRole) || (role == Qt::EditRole)) {
    const MaterialItem &a = inputsMats.at(row);
    if (col == 0) {
      return a.invCode;
    } else if (col == 1) {
      return a.part.cInvName;
    } else if (col == 2) {
      return a.inputDemandQty;
    } else {
      return QVariant();
    }
  } else {
    return QVariant();
  }
}

QVariant InputDemandModel::headerData(int section, Qt::Orientation orientation,
                                      int role) const {

  if (orientation == Qt::Vertical) {
    return QString::number(section);
  }

  // 只是 DisplayRole
  if (role != Qt::DisplayRole) {
    return QVariant();
  }

  if (section >= columnCount()) {
    return QVariant();
  }

  QMap<int, QString> colTitles;
  colTitles.insert(0, tr("料号"));
  colTitles.insert(1, tr("名称"));
  colTitles.insert(2, tr("数量"));

  return colTitles[section];
}

bool InputDemandModel::setData(const QModelIndex &index, const QVariant &value,
                               int role) {
  if (role == Qt::EditRole) {
    if (index.isValid()) {
      int row = index.row();
      int col = index.column();
      MaterialItem &a = inputsMats.at(row);
      if (col == 0) {
        a.invCode = value.toString();
      } else if (col == 1) {
        a.part.cInvName = value.toString();
      } else if (col == 2) {
        a.inputDemandQty = value.toInt();
      }

      emit dataChanged(index, index);

      return true;
    }
  }
  return false;
}

Qt::ItemFlags InputDemandModel::flags(const QModelIndex &index) const {
  if ((index.column() == 2) || (index.column() == 0)) {
    return QAbstractTableModel::flags(index) | Qt::ItemIsEditable;
  } else {
    return Qt::ItemIsEnabled | Qt::ItemIsSelectable;
  }
}

void InputDemandModel::notifyChanges() {
  beginResetModel();

  // todo: 当 model 改变后，行的 header 没有改变；
  emit headerDataChanged(Qt::Vertical, 0, rowCount() - 1);

  endResetModel();
}

#include "moc_availabilitycheckwnd.cpp"



=== backflushcheck.cpp 
#include "backflushcheck.h"

BackFlushCheck::BackFlushCheck()
{

}



=== backflushoutwnd.cpp 
﻿#include "backflushoutwnd.h"

#include "excelapp.h"
#include "global.h"
#include <QtSql>
#include <QtWidgets>

BackFlushOutWnd::BackFlushOutWnd(QWidget *parent) : QWidget(parent) {
  prepareUI();
  connect(&watch, SIGNAL(finished()), this, SLOT(postFetchItems()));
  showMaximized();
}

void BackFlushOutWnd::prepareUI() {
  tabs = new QTabWidget;
  tabs->addTab(createPPTab(), tr("生产订单"));
  //  tabs->addTab(createMOTab(), tr("外协订单"));

  QVBoxLayout *vBox = new QVBoxLayout;
  vBox->addWidget(tabs);
  setLayout(vBox);

  setWindowTitle(tr("提前扣料"));
}

QWidget *BackFlushOutWnd::createPPTab() {
  QLabel *lfrom = new QLabel(tr("开始日期"));
  lfrom->setAlignment(Qt::AlignRight | Qt::AlignCenter);
  QLabel *lto = new QLabel(tr("结束日期"));
  lto->setAlignment(Qt::AlignRight | Qt::AlignCenter);

  // 默认之前一个星期；
  QDate t1, t2;
  t2 = QDate::currentDate();
  t1 = t2.addDays(-7);

  dtePPFrom = new QDateTimeEdit(t1);
  dtePPFrom->setCalendarPopup(true);
  dtePPFrom->setDisplayFormat(dateFormat);

  dtePPTo = new QDateTimeEdit(t2);
  dtePPTo->setCalendarPopup(true);
  dtePPTo->setDisplayFormat(dateFormat);

  QLabel *lOrderfrom = new QLabel(tr("订单号起"));
  lOrderfrom->setAlignment(Qt::AlignRight | Qt::AlignCenter);
  QLabel *lOrderTo = new QLabel(tr("订单号止"));
  lOrderTo->setAlignment(Qt::AlignRight | Qt::AlignCenter);
  lePPOrderFrom = new QLineEdit;
  lePPOrderTo = new QLineEdit;

  btnPPSearch = new QPushButton(tr("查找"));
  QPushButton *btnPPExport = new QPushButton(tr("导出"));

  connect(btnPPSearch, &QPushButton::clicked, this,
          &BackFlushOutWnd::btnPPSearchClicked);

  connect(btnPPExport, &QPushButton::clicked,
          [this]() { exportTableView(tvPP); });

  QHBoxLayout *hlayout = new QHBoxLayout;
  hlayout->addWidget(lfrom);
  hlayout->addWidget(dtePPFrom);
  hlayout->addWidget(lto);
  hlayout->addWidget(dtePPTo);
  //  hlayout->addWidget(lOrderfrom);
  //  hlayout->addWidget(lePPOrderFrom);
  //  hlayout->addWidget(lOrderTo);
  //  hlayout->addWidget(lePPOrderTo);
  hlayout->addWidget(btnPPSearch);
  hlayout->addWidget(btnPPExport);

  tvPP = new QTableView;
  tvPP->setStyleSheet("font: 8pt 微软雅黑;");
  ppModel = new QStandardItemModel;

  // 形成 model: 标题
  QStringList headers;
  headers << "订单号"
          << "订单日期"
          << "产品"
          << "名称"
          << "入库数量"
          << "子件"
          << "子件名称"
          << "出库数量";
  ppModel->setHorizontalHeaderLabels(headers);
  tvPP->setModel(ppModel);

  QVBoxLayout *vBox = new QVBoxLayout;
  vBox->addLayout(hlayout);
  vBox->addWidget(tvPP);

  QWidget *w = new QWidget;
  w->setLayout(vBox);

  return w;
}

void BackFlushOutWnd::exportTableView(QTableView *view) {
  QString fileName = QFileDialog::getSaveFileName(
      this, "保存",
      QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation),
      "Excel 文件(*.xlsx)");

  if (fileName != "") {
    bool ok = ExcelApp::instance()->exportTableView(view, fileName);
    if (ok) {
      QMessageBox::information(this, tr("导出"), tr("导出完毕"));
    }
  }
}

void BackFlushOutWnd::btnPPSearchClicked() {
  // 从 UI 取得用户输入的查询条件；

  QString dteFrom = dtePPFrom->date().toString(dateFormat);
  QString dteTo = dtePPTo->date().toString(dateFormat);

  QString poFrom = lePPOrderFrom->text().trimmed();
  QString poTo = lePPOrderTo->text().trimmed();
  if (poTo.length() == 0) {
    poTo = poFrom;
  }

  // 和 sql 对应
  // 出入库时间
  QString cond1 =
      QString(" and (h.dDate >= '%1' and h.dDate <= '%2')").arg(dteFrom, dteTo);

  // 生产订单号
  QString cond2 = "";
  QString cond3 = "";
  if (poFrom.length() > 0) {
    cond2 = QString(" and (h.cMPoCode >= '%1' and h.cMPoCode <= '%2')")
                .arg(poFrom, poTo);
    cond3 =
        QString(" and (chkh.sourceCode >= '%1' and chkh.sourceCode <= '%2')")
            .arg(poFrom, poTo);
  }

  qDebug() << "1: " << cond1 << "\n2: " << cond2 << "\n3: " << cond3;

  QString sqlTemplate = loadSqlCmd("4.sql");

  QString sqlCmd;
  if (cond2.length() == 0) {
    // 没有限制单号，只取期间内的出入库
    sqlCmd = sqlTemplate.arg(cond1, cond2, cond3, cond1);
  } else {
    // 限制了单号，对于母件入库，不限制时间；
    sqlCmd = sqlTemplate.arg(cond1, cond2, cond3, "");
  }

  qDebug() << "temp: " << sqlTemplate << "\ncmd: " << sqlCmd;

  QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));
  btnPPSearch->setEnabled(false);

  QFuture<void> future =
      QtConcurrent::run([this, sqlCmd]() { fetchItems(sqlCmd); });

  watch.setFuture(future);
}

void BackFlushOutWnd::fetchItems(const QString &sqlCmd) {
  QSqlDatabase db = QSqlDatabase::database(CONN_SRC);
  QSqlQuery query(db);
  query.setForwardOnly(true);
  query.prepare(sqlCmd);

  bool ok = query.exec();

  if (!ok) {
    QSqlError error = db.lastError();
    qDebug() << "Filed: btnPPSearchClicked "
             << QString("err: %1").arg(error.text());
    return;
  }

  allItems.clear();
  while (query.next()) {
    QStringList item;

    // 不同列的处理
    for (int c = 0; c <= colCnt; c++) {
      if (c == 1) {
        // 日期类型
        item.push_back(query.value(c).toDate().toString(dateFormat));
      } else {
        // 字符类型
        item.push_back(query.value(c).toString());
      }
    }

    allItems.push_back(item);
  }
}

void BackFlushOutWnd::postFetchItems() {
  QStandardItemModel *model = ppModel;
  QTableView *tableView = tvPP;

  tableView->setUpdatesEnabled(false);

  // 把结果集，显示在tableview 中；
  // 结果集中都是字符；
  model->removeRows(0, model->rowCount());
  int row = 0;
  for (const auto &it : allItems) {
    for (int c = 0; c <= colCnt; c++) {
      model->setItem(row, c, new QStandardItem(it.at(c)));
    }

    row++;
  }

  tableView->resizeColumnsToContents();
  tableView->setUpdatesEnabled(true);

  btnPPSearch->setEnabled(true);
  QApplication::restoreOverrideCursor();

  QMessageBox::information(this, tr(""), tr("执行完毕"));
}

#include "moc_backflushoutwnd.cpp"



=== backflushwnd.cpp 
﻿#include "backflushwnd.h"

#include "excelapp.h"
#include "global.h"
#include <QtSql>
#include <QtWidgets>

BackFlushWnd::BackFlushWnd(QWidget *parent) : QWidget(parent) {
  prepareUI();

  connect(&watchPP, SIGNAL(finished()), this, SLOT(postFetchItemsPP()));
  connect(&watchMO, SIGNAL(finished()), this, SLOT(postFetchItemsMO()));

  showMaximized();
}

void BackFlushWnd::prepareUI() {
  tabs = new QTabWidget;
  tabs->addTab(createPPTab(), tr("生产订单"));
  tabs->addTab(createMOTab(), tr("外协订单"));

  QVBoxLayout *vBox = new QVBoxLayout;
  vBox->addWidget(tabs);
  setLayout(vBox);

  setWindowTitle(tr("扣料比对"));
}

QWidget *BackFlushWnd::createPPTab() {
  QLabel *lfrom = new QLabel(tr("开始日期"));
  lfrom->setAlignment(Qt::AlignRight | Qt::AlignCenter);
  QLabel *lto = new QLabel(tr("结束日期"));
  lto->setAlignment(Qt::AlignRight | Qt::AlignCenter);

  // 默认之前一个星期；
  QDate t1, t2;
  t2 = QDate::currentDate();
  t1 = t2.addDays(-7);

  dtePPFrom = new QDateTimeEdit(t1);
  dtePPFrom->setCalendarPopup(true);
  dtePPFrom->setDisplayFormat(dateFormat);

  dtePPTo = new QDateTimeEdit(t2);
  dtePPTo->setCalendarPopup(true);
  dtePPTo->setDisplayFormat(dateFormat);

  QLabel *lOrderfrom = new QLabel(tr("订单号起"));
  lOrderfrom->setAlignment(Qt::AlignRight | Qt::AlignCenter);
  QLabel *lOrderTo = new QLabel(tr("订单号止"));
  lOrderTo->setAlignment(Qt::AlignRight | Qt::AlignCenter);
  lePPOrderFrom = new QLineEdit;
  lePPOrderTo = new QLineEdit;

  btnPPSearch = new QPushButton(tr("查找"));
  QPushButton *btnPPExport = new QPushButton(tr("导出"));

  connect(btnPPSearch, &QPushButton::clicked, this,
          &BackFlushWnd::btnPPSearchClicked);

  connect(btnPPExport, &QPushButton::clicked,
          [this]() { exportTableView(tvPP); });

  QHBoxLayout *hlayout = new QHBoxLayout;
  hlayout->addWidget(lfrom);
  hlayout->addWidget(dtePPFrom);
  hlayout->addWidget(lto);
  hlayout->addWidget(dtePPTo);
  hlayout->addWidget(lOrderfrom);
  hlayout->addWidget(lePPOrderFrom);
  hlayout->addWidget(lOrderTo);
  hlayout->addWidget(lePPOrderTo);
  hlayout->addWidget(btnPPSearch);
  hlayout->addWidget(btnPPExport);

  tvPP = new QTableView;
  tvPP->setStyleSheet("font: 8pt 微软雅黑;");
  ppModel = new QStandardItemModel;

  // 形成 model: 标题
  QStringList headers;
  headers << "订单号"
          << "订单日期"
          << "产品"
          << "名称"
          << "入库数量"
          << "子件"
          << "子件名称"
          << "出库数量"
          << "耗用标准"
          << "差异";
  ppModel->setHorizontalHeaderLabels(headers);
  tvPP->setModel(ppModel);

  QVBoxLayout *vBox = new QVBoxLayout;
  vBox->addLayout(hlayout);
  vBox->addWidget(tvPP);

  QWidget *w = new QWidget;
  w->setLayout(vBox);

  return w;
}

QWidget *BackFlushWnd::createMOTab() {
  QLabel *lfrom = new QLabel(tr("开始日期"));
  lfrom->setAlignment(Qt::AlignRight | Qt::AlignCenter);
  QLabel *lto = new QLabel(tr("结束日期"));
  lto->setAlignment(Qt::AlignRight | Qt::AlignCenter);

  // 默认之前一个星期；
  QDate t1, t2;
  t2 = QDate::currentDate();
  t1 = t2.addDays(-7);

  dteMOFrom = new QDateTimeEdit(t1);
  dteMOFrom->setCalendarPopup(true);
  dteMOFrom->setDisplayFormat(dateFormat);

  dteMOTo = new QDateTimeEdit(t2);
  dteMOTo->setCalendarPopup(true);
  dteMOTo->setDisplayFormat(dateFormat);

  QLabel *lOrderfrom = new QLabel(tr("订单号起"));
  lOrderfrom->setAlignment(Qt::AlignRight | Qt::AlignCenter);
  QLabel *lOrderTo = new QLabel(tr("订单号止"));
  lOrderTo->setAlignment(Qt::AlignRight | Qt::AlignCenter);
  leMOOrderFrom = new QLineEdit;
  leMOOrderTo = new QLineEdit;

  btnMOSearch = new QPushButton(tr("查找"));
  QPushButton *btnMOExport = new QPushButton(tr("导出"));

  connect(btnMOSearch, &QPushButton::clicked, this,
          &BackFlushWnd::btnMOSearchClicked);

  connect(btnMOExport, &QPushButton::clicked,
          [this]() { exportTableView(tvMO); });

  QHBoxLayout *hlayout = new QHBoxLayout;
  hlayout->addWidget(lfrom);
  hlayout->addWidget(dteMOFrom);
  hlayout->addWidget(lto);
  hlayout->addWidget(dteMOTo);
  hlayout->addWidget(lOrderfrom);
  hlayout->addWidget(leMOOrderFrom);
  hlayout->addWidget(lOrderTo);
  hlayout->addWidget(leMOOrderTo);
  hlayout->addWidget(btnMOSearch);
  hlayout->addWidget(btnMOExport);

  tvMO = new QTableView;
  tvMO->setStyleSheet("font: 8pt 微软雅黑;");
  moModel = new QStandardItemModel;

  // 形成 model: 标题
  QStringList headers;
  headers << "订单号"
          << "行号"
          << "产品"
          << "名称"
          << "入库数量"
          << "子件"
          << "子件名称"
          << "出库数量"
          << "耗用标准"
          << "差异"
          << "委外商"
          << "项目号"
          << "项目名称";

  moModel->setHorizontalHeaderLabels(headers);
  tvMO->setModel(moModel);

  QVBoxLayout *vBox = new QVBoxLayout;
  vBox->addLayout(hlayout);
  vBox->addWidget(tvMO);

  QWidget *w = new QWidget;
  w->setLayout(vBox);

  return w;
}

void BackFlushWnd::exportTableView(QTableView *view) {
  QString fileName = QFileDialog::getSaveFileName(
      this, "保存",
      QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation),
      "Excel 文件(*.xlsx)");

  if (fileName != "") {
    bool ok = ExcelApp::instance()->exportTableView(view, fileName);
    if (ok) {
      QMessageBox::information(this, tr("导出"), tr("导出完毕"));
    }
  }
}

void BackFlushWnd::btnPPSearchClicked() {
  // 从 UI 取得用户输入的查询条件；
  QString dteFrom = dtePPFrom->date().toString(dateFormat);
  QString dteTo = dtePPTo->date().toString(dateFormat);

  QString poFrom = lePPOrderFrom->text().trimmed();
  QString poTo = lePPOrderTo->text().trimmed();
  if (poTo.length() == 0) {
    poTo = poFrom;
  }

  // 和 sql 对应
  // 出入库时间
  QString cond1 =
      QString(" and (h.dDate >= '%1' and h.dDate <= '%2')").arg(dteFrom, dteTo);

  // 生产订单号
  QString cond2 = "";
  QString cond3 = "";
  if (poFrom.length() > 0) {
    cond2 = QString(" and (h.cMPoCode >= '%1' and h.cMPoCode <= '%2')")
                .arg(poFrom, poTo);
    cond3 =
        QString(" and (chkh.sourceCode >= '%1' and chkh.sourceCode <= '%2')")
            .arg(poFrom, poTo);
  }

  qDebug() << "1: " << cond1 << "\n2: " << cond2 << "\n3: " << cond3;

  QString sqlTemplate = loadSqlCmd("1.sql");

  QString sqlCmd;
  if (cond2.length() == 0) {
    // 没有限制单号，只取期间内的出入库
    sqlCmd = sqlTemplate.arg(cond1, cond2, cond3, cond1);
  } else {
    // 限制了单号，对于子件扣料，不限制时间；
    sqlCmd = sqlTemplate.arg(cond1, cond2, cond3, "");
  }

  qDebug() << "temp: " << sqlTemplate << "\ncmd: " << sqlCmd;

  QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));
  btnPPSearch->setEnabled(false);

  QFuture<void> future =
      QtConcurrent::run([this, sqlCmd]() { fetchItemsPP(sqlCmd); });

  watchPP.setFuture(future);
}

// 参数：需要执行的sql；结果集；结果集的列数
// 两个结果集，不完全一样，所以各是各的；
void BackFlushWnd::fetchItemsPP(const QString &sqlCmd) {
  QSqlDatabase db = QSqlDatabase::database(CONN_SRC);
  QSqlQuery query(db);
  query.setForwardOnly(true);
  query.prepare(sqlCmd);

  bool ok = query.exec();

  if (!ok) {
    QSqlError error = db.lastError();
    qDebug() << "Filed: btnPPSearchClicked "
             << QString("err: %1").arg(error.text());
    return;
  }

  allItemsPP.clear();
  while (query.next()) {
    QStringList item;

    // 不同列的处理
    for (int c = 0; c <= colCntPP; c++) {
      if (c == 1) {
        // 日期类型
        item.push_back(query.value(c).toDate().toString(dateFormat));
      } else {
        // 字符类型
        item.push_back(query.value(c).toString());
      }
    }

    allItemsPP.push_back(item);
  }
}

void BackFlushWnd::postFetchItemsPP() {
  QStandardItemModel *model = ppModel;
  QTableView *tableView = tvPP;

  tableView->setUpdatesEnabled(false);

  // 把结果集，显示在tableview 中；
  // 结果集中都是字符；
  model->removeRows(0, model->rowCount());
  int row = 0;
  for (const auto &it : allItemsPP) {
    for (int c = 0; c <= colCntPP; c++) {
      model->setItem(row, c, new QStandardItem(it.at(c)));
    }

    row++;
  }

  tableView->resizeColumnsToContents();
  tableView->setUpdatesEnabled(true);

  btnPPSearch->setEnabled(true);
  QApplication::restoreOverrideCursor();

  QMessageBox::information(this, tr(""), tr("执行完毕"));
}

void BackFlushWnd::btnMOSearchClicked() {
  // 从 UI 取得用户输入的查询条件；
  QString dteFrom = dteMOFrom->date().toString(dateFormat);
  QString dteTo = dteMOTo->date().toString(dateFormat);

  QString poFrom = leMOOrderFrom->text().trimmed();
  QString poTo = leMOOrderTo->text().trimmed();
  if (poTo.length() == 0) {
    poTo = poFrom;
  }

  // 和 sql 对应
  // 出入库时间
  QString cond1 =
      QString(" and (h.dDate >= '%1' and h.dDate <= '%2')").arg(dteFrom, dteTo);

  // 订单号
  QString cond2 = "";
  if (poFrom.length() > 0) {
    cond2 = QString(" and (d.cDefine23 >= '%1' and d.cDefine23 <= '%2')")
                .arg(poFrom, poTo);
  }

  qDebug() << "1: " << cond1 << "\n2: " << cond2;

  QString sqlTemplate = loadSqlCmd("2.sql");

  QString sqlCmd;
  if (cond2.length() == 0) {
    // 没有限制单号，只取期间内的出入库
    sqlCmd = sqlTemplate.arg(cond1, cond2, cond1);
  } else {
    // 限制了单号，对于子件扣料，不限制时间；
    sqlCmd = sqlTemplate.arg(cond1, cond2, "");
  }

  qDebug() << "temp: " << sqlTemplate << "\ncmd: " << sqlCmd;

  QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));
  btnMOSearch->setEnabled(false);

  QFuture<void> future =
      QtConcurrent::run([this, sqlCmd]() { fetchItemsMO(sqlCmd); });

  watchMO.setFuture(future);
}

void BackFlushWnd::fetchItemsMO(const QString &sqlCmd) {
  QSqlDatabase db = QSqlDatabase::database(CONN_SRC);
  QSqlQuery query(db);
  query.setForwardOnly(true);
  query.prepare(sqlCmd);

  bool ok = query.exec();

  if (!ok) {
    QSqlError error = db.lastError();
    qDebug() << "Filed: btnPPSearchClicked "
             << QString("err: %1").arg(error.text());
    return;
  }

  allItemsMO.clear();
  while (query.next()) {
    QStringList item;

    // 不同列的处理
    for (int c = 0; c <= colCntMO; c++) {
      item.push_back(query.value(c).toString());
    }

    allItemsMO.push_back(item);
  }
}

void BackFlushWnd::postFetchItemsMO() {
  QStandardItemModel *model = moModel;
  QTableView *tableView = tvMO;

  tableView->setUpdatesEnabled(false);

  // 把结果集，显示在tableview 中；
  // 结果集中都是字符；
  model->removeRows(0, model->rowCount());
  int row = 0;
  for (const auto &it : allItemsMO) {
    for (int c = 0; c <= colCntMO; c++) {
      model->setItem(row, c, new QStandardItem(it.at(c)));
    }

    row++;
  }

  tableView->resizeColumnsToContents();
  tableView->setUpdatesEnabled(true);

  btnMOSearch->setEnabled(true);
  QApplication::restoreOverrideCursor();

  QMessageBox::information(this, tr(""), tr("执行完毕"));
}

#include "moc_backflushwnd.cpp"



=== bom.cpp 
#include "bom.h"

BOM::BOM()
{

}



=== bomcomponent.cpp 
#include "bomcomponent.h"

BOMComponent::BOMComponent() {}

QString BOMComponent::toString() const {
  return QString("%1 %2 %3 %4 %5 %6 %7 %8")
      .arg(QString::number(bomId), QString::number(componentId),
           QString::number(sortSeq), QString::number(baseQtyN),
           QString::number(fullQtyN), invCode, invName,
           QString::number(fullLevel));
}

bool BOMComponent::isLeaf() const { return false; }



=== bomexplorer.cpp 
﻿#include "bomexplorer.h"

#include <QtSql>

#include <algorithm>
#include <stack>

#include "global.h"

BOMExplorer::BOMExplorer() {}

/////////////////////////////////////////////////////////////////////////
/// BOM 展开到底

int BOMExplorer::findPartIdByInv(const QString &invCode) {
  // 根据 invCode 找到 partid;
  auto it = std::find_if(allBOMParts.begin(), allBOMParts.end(),
                         [invCode](const BOMPart &p) {
                           return (p.cInvCode.compare(invCode) == 0);
                         });

  if (it == allBOMParts.end()) {
    return -1;
  };

  return it->partId;
}

int BOMExplorer::findBomIdByInv(const QString &invCode) {
  // 根据 invCode 找到 partid，再根据 partID 找到 bomid

  // 根据 invCode 查找对应的 partid
  //  auto it = std::find_if(allBOMParts.begin(), allBOMParts.end(),
  //                         [invCode](const BOMPart &p) {
  //                           return (p.cInvCode.compare(invCode) == 0);
  //                         });

  int partId = findPartIdByInv(invCode);
  if (partId == -1) {
    return -1;
  };

  // 根据 partid，查找对应的 bomid
  return findBomIdByPartId(partId);
}

int BOMExplorer::findBomIdByPartId(int partid) {

  // 在 bomparent 中根据 partid 找到 bomid；
  auto bomit =
      std::find_if(allBOMs.begin(), allBOMs.end(),
                   [partid](const BOM &p) { return (p.partId == partid); });

  if (bomit == allBOMs.end()) {
    //    qDebug() << QString("No BomId for partid
    //    %2").arg(QString::number(partid));
    return -1;
  };

  //  qDebug() << QString("Got BomId %1 for partid %2")
  //                  .arg(QString::number(bomit->bomId),
  //                  QString::number(partid));

  return bomit->bomId;
}

std::vector<BOMComponent> BOMExplorer::findSubPartsByBomId(int bomid) {
  // 在 bomComponent 中，根据 bomid 找到所有的 partid；
  // 只查找一层；
  std::vector<BOMComponent> comps;
  for (auto &p : allBOMComponents) {
    if (p.bomId == bomid) {
      BOMComponent b{p};
      comps.push_back(b);
    }
  }

  // 按照 sortSeq 从小到大排序
  std::sort(comps.begin(), comps.end(),
            [](const BOMComponent &a, const BOMComponent &b) {
              return (a.sortSeq > b.sortSeq);
            });

  //  qDebug() << QString("total %1 subs for %2")
  //                  .arg(QString::number(comps.size()),
  //                  QString::number(bomid));
  return comps;
}

// 根据 bomid 找到 bomcomponent
BOMComponent BOMExplorer::loadBOMComponentByBOMID(int bomid) {
  // 根据 bomid 找到 partid
  auto it = std::find_if(allBOMs.begin(), allBOMs.end(),
                         [bomid](const BOM &p) { return (p.bomId == bomid); });

  if (it == allBOMs.end()) {
    BOMComponent err;
    err.bomId = -1;
    return err;
  };

  qlonglong partid = it->partId;

  // 根据 partid 找到 part
  auto partit =
      std::find_if(allBOMParts.begin(), allBOMParts.end(),
                   [partid](const BOMPart &p) { return (p.partId == partid); });

  if (partit == allBOMParts.end()) {
    BOMComponent err;
    err.bomId = -1;
    return err;
  };

  // 把 part 转化成 compoent
  BOMPart part{*partit};
  BOMComponent result;
  result.invCode = part.cInvCode;
  result.invName = part.cInvName;
  result.cInvStd = part.cInvStd;
  result.bProxyForeign = part.bProxyForeign;
  result.bPurchase = part.bPurchase;
  result.bSelf = part.bSelf;
  result.Spec = part.designNo;
  result.VerDesc = part.bomVer;
  result.bomStatus = part.bomStatus;
  result.matVer = part.matVer;
  return result;
}

std::vector<BOMComponent> BOMExplorer::findAllSubs(int bomid) {
  std::vector<BOMComponent> allSubComps;

  // 根据 bomid 找到 bomcomponent
  BOMComponent root = loadBOMComponentByBOMID(bomid);
  root.fullLevel = 1;
  allSubComps.push_back(root);

  std::stack<BOMComponent> compsStack;

  // bomid 的直接下层
  std::vector<BOMComponent> subs = findSubPartsByBomId(bomid);
  for (const auto &s : subs) {
    BOMComponent i{s};
    i.fullQtyD = i.baseQtyD;
    i.fullQtyN = i.baseQtyN;
    i.fullSeq = QString::number(i.sortSeq);
    i.fullLevel = 2;
    compsStack.push(i);
  }

  int round = 0;

  // 使用 stack，深度遍历
  while (!compsStack.empty()) {
    round++;
    if (round > maxPartCount) {
      qDebug() << "findAllSubs：有漏洞，无限循环了";
      break;
    }

    // 取 第一个，并出栈
    BOMComponent part = compsStack.top();
    compsStack.pop();

    // 把 partid 加入到结果集中
    allSubComps.push_back(part);

    // 如果 partid 有对应的 bomID，
    // 那么把对应的 bomid 都压入 stack 中；
    int bomid = findBomIdByPartId(part.componentId);

    if (bomid != -1) {
      //      qDebug() << QString("next level for
      //      %1").arg(QString::number(bomid));

      // 如果 bomid 还有下一层，
      // 把下一层压入 stack
      subs = findSubPartsByBomId(bomid);
      for (const auto &s : subs) {
        // 子part 耗量  = 本层耗量 * 上层耗量
        BOMComponent i{s};
        i.fullQtyN = i.baseQtyN * part.fullQtyN;
        i.fullQtyD = i.baseQtyD * part.fullQtyD;
        i.fullLevel = part.fullLevel + 1;

        compsStack.push(i);
      }
    }
  }

  return allSubComps;
}

std::vector<BOMPart> &BOMExplorer::getAllParts() { return allBOMParts; }

std::vector<BOMComponent> BOMExplorer::dumpBom(const QString &invCode) {
  std::vector<BOMComponent> allParts;

  // 传入的是物料编码，根据物料编码，找到对应的 bomid
  int bomid = findBomIdByInv(invCode);

  if (bomid == -1) {
    qDebug() << QString("%1 没有对应的 bomid").arg(invCode);
    return allParts;
  }

  // 查找 bomid 下的 partids
  return findAllSubs(bomid);
}

/////////////////////////////////////////////////////////////////////////////////////
// BOM 反查

int BOMExplorer::findPartIdByBomId(int bomid) {
  // 在 bomparent 中根据 bomid 找到 partid；
  auto part =
      std::find_if(allBOMs.begin(), allBOMs.end(),
                   [bomid](const BOM &p) { return (p.bomId == bomid); });

  if (part == allBOMs.end()) {
    //    qDebug() << QString("No partid for bomid
    //    %2").arg(QString::number(bomid));
    return -1;
  };

  //  qDebug() << QString("Got PartId %1 for BomId %2")
  //                  .arg(QString::number(part->partId),
  //                  QString::number(bomid));

  return part->partId;
}

std::vector<BOMComponent> BOMExplorer::findParentsByPartId(int partid) {
  // 在 bomComponent 中，根据 partid 找到所有的 bomid；
  // 只查找一层；
  // 返回的 BOMComponent 中，只记录了 parent 的 partid，其余字段为空；

  // 查到的是 bomid - 子 partid，返回的结果是 bomid 自己的 partid
  std::vector<BOMComponent> results;
  for (const auto &p : allBOMComponents) {
    if (p.componentId == partid) {
      BOMComponent b;
      b.componentId = p.bomPartId;
      results.push_back(b);
    }
  }

  // 根据 bomid 转成 partid
  //  std::vector<BOMComponent> results;
  //  for (const auto &p : parents) {
  //    int partid = findPartIdByBomId(p.bomId);
  //    BOMComponent b;
  //    b.componentId = partid;
  //    results.push_back(b);
  //  }

  // 按照 bomid 从小到大排序
  std::sort(results.begin(), results.end(),
            [](const BOMComponent &a, const BOMComponent &b) {
              return (a.componentId > b.componentId);
            });

  //  qDebug() << QString("total %1 parents for %2")
  //                  .arg(QString::number(results.size()),
  //                       QString::number(partid));
  return results;
}

std::vector<BOMComponent> BOMExplorer::findAllAncestors(int partid) {
  std::vector<BOMComponent> results;

  // findParentsByPartId: 返回值中，只有 partid，其他属性都为空；
  std::vector<BOMComponent> oneLevelUp = findParentsByPartId(partid);

  std::stack<BOMComponent> stk;
  // 第一层上级，压入 stack
  for (auto i : oneLevelUp) {
    i.fullLevel = 1;
    stk.push(i);
  }

  int round = 0;
  while (!stk.empty()) {
    round++;
    if (round > maxParentCount) {
      qDebug() << "findAllAncestors：有漏洞，无限循环了";
      break;
    }

    // 取出第一个，放入最终的结果集，并出栈；
    BOMComponent p = stk.top();
    results.push_back(p);
    stk.pop();

    // 再往上层找；并且压栈
    oneLevelUp = findParentsByPartId(p.componentId);
    for (auto i : oneLevelUp) {
      i.fullLevel = p.fullLevel + 1;
      stk.push(i);
    }
  }

  for (auto &i : results) {
    for (const auto &m : allBOMParts) {
      if (i.componentId == m.partId) {
        i.invCode = m.cInvCode;
        i.invName = m.cInvName;

        i.Spec = m.designNo;
        i.VerDesc = m.bomVer;
        i.bomStatus = m.bomStatus;
        i.matVer = m.matVer;
      }
    }
  }

  return results;
}

std::vector<BOMComponent> BOMExplorer::dumpBomReverse(const QString &invCode) {
  std::vector<BOMComponent> allParts;

  // 传入的是物料编码，根据物料编码，找到对应的 partid
  int partid = findPartIdByInv(invCode);

  if (partid == -1) {
    qDebug() << QString("%1 没有对应的 partid").arg(invCode);
    return allParts;
  }

  // 查找 partid 的所有祖先
  return findAllAncestors(partid);

  //  allParts = findAllAncestors(partid);
  //  for (const auto &i : allParts) {
  //    qDebug() << i.toString();
  //  }

  //  return allParts;
}

std::vector<BOMComponent> BOMExplorer::expandOneLevel(const QString &invCode) {
  // 根据输入料号，查找该料号的直接下层；
  int bomid = findBomIdByInv(invCode);
  std::vector<BOMComponent> oneLevelDown = findSubPartsByBomId(bomid);

  return oneLevelDown;
}

/////////////////////////////////////////////////////////////////////////////////////
/// \brief BOMExplorer::loadRawData
/// 从数据库初始化数据
void BOMExplorer::loadRawData() {
  loadBOM();
  loadBOMComponent();
  loadBOMPart();
}

void BOMExplorer::loadBOM() {
  QSqlDatabase db = QSqlDatabase::database(CONN_SRC);
  QSqlQuery query(db);
  QSqlError err;
  QString cmd;
  bool ok;

  QElapsedTimer timer;
  timer.start();

  // 加载 bom 母件，status=3 审核
  cmd = "select a.BomId, b.ParentId partId "
        "from bom_bom a inner join bom_parent b on a.BomId=b.BomId "
        // "a.status = 3 "
        "order by "
        "a.BomId, b.ParentId";
  query.setForwardOnly(true);
  query.prepare(cmd);

  //  QSqlQuery query(cmd, db);

  ok = query.exec();
  if (!ok) {
    err = db.lastError();
    qDebug() << QString("load bom failed: %1, %2").arg(cmd, err.text());
    return;
  }

  allBOMs.clear();
  while (query.next()) {
    BOM b;
    b.bomId = query.value(0).toLongLong();
    b.partId = query.value(1).toLongLong();

    allBOMs.push_back(b);
  }

  //  std::sort(allBOMs.begin(), allBOMs.end(),
  //            [](const BOM &a, const BOM &b) { return a.bomId < b.partId; });

  qDebug() << QString("load bom: (%1, %2)")
                  .arg(QString::number(allBOMs.size()),
                       QString::number(timer.elapsed()));
}

void BOMExplorer::loadBOMComponent() {
  QSqlDatabase db = QSqlDatabase::database(CONN_SRC);
  QSqlQuery query(db);
  QSqlError err;
  QString cmd;
  bool ok;

  QElapsedTimer timer;
  timer.start();

  // 加载 bom 子件，单层
  cmd = " select a.BomId, a.componentId, a.sortSeq, a.baseQtyN, a.baseQtyD, "
        "i.cInvCode, i.cInvName,isnull(i.bSelf,0), isnull(i.bProxyForeign,0), "
        "isnull(i.bPurchase,0), "
        //        "isnull(i.iSupplyType,0) '制造属性-物料主数据', "
        "o.WIPType '制造属性-BOM子件', "
        "iInvAdvance, "
        "fMinSupply, e.cComUnitName, i.cInvDefine7 '图纸号' , m.versionDesc, "
        "m.status, "
        "i.cInvDefine2 '物料版本' "
        " from bom_opcomponent a "
        " inner join bom_opcomponentopt o on o.OptionsId = a.OpComponentId "
        " inner join bas_part b on a.componentId = b.partId "
        " inner join inventory i on b.InvCode = i.cInvCode "
        " inner join ComputationUnit e ON i.cComUnitCode =e.cComUnitCode "
        " left join bom_parent p on p.parentId = b.partid "
        " left join bom_bom m on m.bomid = p.bomid "
        " order by a.BomId, "
        "a.sortSeq; ";
  query.setForwardOnly(true);
  query.prepare(cmd);

  ok = query.exec();
  if (!ok) {
    err = db.lastError();
    qDebug() << QString("load bom-comps failed: %1, %2").arg(cmd, err.text());
    return;
  }

  allBOMComponents.clear();
  while (query.next()) {
    BOMComponent b;
    b.bomId = query.value(0).toLongLong();
    b.componentId = query.value(1).toLongLong();
    b.sortSeq = query.value(2).toInt();
    b.baseQtyN = query.value(3).toDouble();
    b.baseQtyD = query.value(4).toDouble();
    b.invCode = query.value(5).toString();
    b.invName = query.value(6).toString();
    b.bSelf = query.value(7).toInt();
    b.bProxyForeign = query.value(8).toInt();
    b.bPurchase = query.value(9).toInt();
    b.iSupplyType = query.value(10).toInt();
    b.iInvAdvance = query.value(11).toInt();
    b.fMinSupply = query.value(12).toInt();
    b.cComUnitName = query.value(13).toString();

    b.Spec = query.value(14).toString();
    b.VerDesc = query.value(15).toString();
    b.matVer = query.value(16).toString();

    allBOMComponents.push_back(b);
  }

  //  std::sort(allBOMComponents.begin(), allBOMComponents.end());

  // 根据 bomid 找到对应的 partid
  for (auto &c : allBOMComponents) {
    for (const auto &b : allBOMs) {
      if (c.bomId == b.bomId) {
        c.bomPartId = b.partId;
        break;
      }
    }
  }

  qDebug() << QString("load bom-components: (%1, %2)")
                  .arg(QString::number(allBOMComponents.size()),
                       QString::number(timer.elapsed()));
}

void BOMExplorer::loadBOMPart() {
  QSqlDatabase db = QSqlDatabase::database(CONN_SRC);
  QSqlQuery query(db);
  QSqlError err;
  QString cmd;
  bool ok;

  QElapsedTimer timer;
  timer.start();

  // 加载 part 和 invCode 的对应关系
  cmd = "select a.partId, a.InvCode, i.cInvName, "
        " isnull(i.bSelf,0), isnull(i.bProxyForeign,0), "
        " isnull(i.bPurchase,0),isnull(i.iSupplyType,0), iInvAdvance,  "
        " fMinSupply, i.cInvDefine7, m.versionDesc, m.status, i.cInvDefine2 "
        " from bas_part a "
        " inner join  inventory i on a.InvCode = i.cInvCode "
        " left join bom_parent p on p.parentid = a.partid "
        " left join bom_bom m on m.bomid = p.bomid"
        " order by a.partId, a.InvCode";
  query.setForwardOnly(true);
  query.prepare(cmd);

  ok = query.exec();
  if (!ok) {
    err = db.lastError();
    qDebug()
        << QString("load part-invCode failed: %1, %2").arg(cmd, err.text());
    return;
  }
  QMap<QString, QString> statusMap;
  statusMap.insert("1", "新建");
  statusMap.insert("3", "审核");
  statusMap.insert("4", "停用");

  allBOMParts.clear();
  while (query.next()) {
    BOMPart b;
    b.partId = query.value(0).toLongLong();
    b.cInvCode = query.value(1).toString();
    b.cInvName = query.value(2).toString();
    b.bSelf = query.value(3).toInt();
    b.bProxyForeign = query.value(4).toInt();
    b.bPurchase = query.value(5).toInt();
    b.iSupplyType = query.value(6).toInt();
    b.iInvAdvance = query.value(7).toInt();
    b.fMinSupply = query.value(8).toInt();
    b.designNo = query.value(9).toString();
    b.bomVer = query.value(10).toString();
    b.bomStatus = statusMap.value(query.value(11).toString(), "未定义");
    b.matVer = query.value(12).toString();

    allBOMParts.push_back(b);
  }

  //  std::sort(allBOMParts.begin(), allBOMParts.end());

  qDebug() << QString("load parts: (%1, %2)")
                  .arg(QString::number(allBOMParts.size()),
                       QString::number(timer.elapsed()));
}

void BOMExplorer::init() {
  qDebug() << "Initial all bom data.";

  QElapsedTimer timer;
  timer.start();

  loadRawData();

  isLoad = true;

  qDebug() << QString("complete: %1").arg(QString::number(timer.elapsed()));
}



=== bomexplorerwnd.cpp 
﻿#include "bomexplorerwnd.h"

#include "excelapp.h"
#include "global.h"
#include <QtConcurrent/QtConcurrent>
#include <QtSql>
//#include <future>

#include "bomcomponent.h"

BOMExplorerWnd::BOMExplorerWnd(QWidget *parent) : QWidget(parent) { setupUI(); }

void BOMExplorerWnd::setupUI() {
  matModel = new QStandardItemModel;
  partModel = new QStandardItemModel;

  tabs = new QTabWidget;

  // 第一个 tab 页：查询条件 + 结果列表 + 操作按钮
  // 顶部的查找框
  QLabel *label = new QLabel(tr("物料"));
  leMaterial = new QLineEdit;

  QPushButton *btnFindMat = new QPushButton(tr("查找"));
  QPushButton *btnReload = new QPushButton(tr("刷新"));

  connect(btnFindMat, &QPushButton::clicked, this,
          &BOMExplorerWnd::btnFindMatClicked);
  connect(btnReload, &QPushButton::clicked, this,
          &BOMExplorerWnd::btnReloadClicked);

  QHBoxLayout *h1 = new QHBoxLayout;
  h1->addWidget(label);
  h1->addWidget(leMaterial);
  h1->addWidget(btnFindMat);
  h1->addWidget(btnReload);

  // 中部 tab
  QVBoxLayout *matTab = new QVBoxLayout;

  tvMaterial = new QTableView;
  tvMaterial->setStyleSheet("font: 8pt 微软雅黑;");
  tvMaterial->setEditTriggers(QAbstractItemView::NoEditTriggers);

  // 底部的 button，可以换成右键菜单
  btnBOM = new QPushButton(tr("物料清单"));
  btnBOMUp = new QPushButton(tr("BOM反查"));
  QHBoxLayout *h2 = new QHBoxLayout;
  h2->addWidget(btnBOM);
  h2->addWidget(btnBOMUp);

  btnBOM->setEnabled(false);
  btnBOMUp->setEnabled(false);

  connect(btnBOM, &QPushButton::clicked, this,
          [this]() { this->matTabUpDown(true); });
  connect(btnBOMUp, &QPushButton::clicked, this,
          [this]() { this->matTabUpDown(false); });

  matTab->addLayout(h1);
  matTab->addWidget(tvMaterial);
  matTab->addLayout(h2);

  QWidget *wMat = new QWidget;
  wMat->setLayout(matTab);
  tabs->addTab(wMat, tr("物料"));

  // BOM 清单 tab：母件 + 子件列表
  QVBoxLayout *v3 = new QVBoxLayout;

  // 显示母件
  QHBoxLayout *hTips = new QHBoxLayout;
  QLabel *labelTips = new QLabel(tr("物料"));
  leParent = new QLineEdit;
  //  leParent->setEnabled(false);
  leParent->setReadOnly(true);
  hTips->addWidget(labelTips);
  hTips->addWidget(leParent);
  v3->addLayout(hTips);

  tvParts = new QTableView;
  tvParts->setStyleSheet("font: 8pt 微软雅黑;");
  tvParts->setEditTriggers(QAbstractItemView::NoEditTriggers);
  v3->addWidget(tvParts);

  QPushButton *btnBOMTabExport = new QPushButton(tr("导出"));
  QPushButton *btnBOMTabUp = new QPushButton(tr("反查"));

  connect(btnBOMTabExport, &QPushButton::clicked, this,
          [this]() { exportTableView(tvParts); });
  connect(btnBOMTabUp, &QPushButton::clicked, this,
          &BOMExplorerWnd::btnBOMTabUpClicked);

  QHBoxLayout *hbom = new QHBoxLayout;
  hbom->addWidget(btnBOMTabExport);
  hbom->addWidget(btnBOMTabUp);

  v3->addLayout(hbom);

  QWidget *wBom = new QWidget;
  wBom->setLayout(v3);
  tabs->addTab(wBom, tr("BOM清单"));

  // BOM 反查 Tab：part + 列表 + 按钮
  lePart = new QLineEdit;
  //  lePart->setEnabled(false);
  lePart->setReadOnly(true);

  tvParents = new QTableView;
  parentModel = new QStandardItemModel;
  tvParents->setStyleSheet("font: 8pt 微软雅黑;");
  tvParents->setEditTriggers(QAbstractItemView::NoEditTriggers);

  QPushButton *btnParentTabExport = new QPushButton(tr("导出"));
  QPushButton *btnParentTabDown = new QPushButton(tr("BOM清单"));

  connect(btnParentTabExport, &QPushButton::clicked, this,
          [this]() { exportTableView(tvParents); });
  connect(btnParentTabDown, &QPushButton::clicked, this,
          &BOMExplorerWnd::btnParentTabDownClicked);

  QHBoxLayout *hParent = new QHBoxLayout;
  hParent->addWidget(btnParentTabExport);
  hParent->addWidget(btnParentTabDown);

  QVBoxLayout *vBomR = new QVBoxLayout;
  vBomR->addWidget(lePart);
  vBomR->addWidget(tvParents);
  vBomR->addLayout(hParent);

  QWidget *wR = new QWidget;
  wR->setLayout(vBomR);
  tabs->addTab(wR, tr("BOM反查"));

  // 主窗口
  QVBoxLayout *vMain = new QVBoxLayout;
  vMain->addWidget(tabs);

  setLayout(vMain);

  //  resize(1400, 900);
  setWindowTitle(tr("BOM查看"));
  showMaximized();

  // 加载完数据后的回调函数；
  connect(&watcher, SIGNAL(finished()), this, SLOT(afterLoadRawData()));
}

void BOMExplorerWnd::btnFindMatClicked() {
  QString mat = leMaterial->text().simplified().trimmed();

  if (mat.length() == 0) {
    QMessageBox::information(this, tr("DJPlan"), tr("请输入料号"));
    return;
  }

  // 根据用户输入，查找物料基本信息
  QSqlDatabase db = QSqlDatabase::database(CONN_SRC);
  QSqlQuery query(db);

  QString cmd = " select i.cInvCode, i.cInvName, i.cInvAddCode, i.cInvStd, "
                " isnull(i.bSelf,0), "
                " isnull(i.bProxyForeign,0), isnull(i.bPurchase,0), "
                " isnull(i.iSupplyType,0), i.cInvDefine7 '图纸号', "
                " a.versionDesc 'BOM版本', a.status '状态', i.cInvDefine2 "
                "'物料版本' from inventory i "
                " left join bas_part c on c.InvCode = i.cInvCode "
                " left join bom_parent b on  b.parentId = c.partid "
                " left join  bom_bom a on a.bomid = b.bomid "
                "where 1 = 1";

  cmd = QString("%1 and (i.cInvCode like '%%2%' or i.cInvName like '%%2%');")
            .arg(cmd, mat);
  qDebug() << "cmd: " << cmd;
  query.setForwardOnly(true);
  query.prepare(cmd);
  bool ok = query.exec();

  if (!ok) {
    QSqlError err = db.lastError();
    qDebug() << QString("query material failed: %1, %2, %3")
                    .arg(mat, cmd, err.text());
    return;
  }

  QMap<QString, QString> statusMap;
  statusMap.insert("1", "新建");
  statusMap.insert("3", "审核");
  statusMap.insert("4", "停用");

  materials.clear();
  while (query.next()) {
    BOMPart b;
    b.cInvCode = query.value(0).toString();
    b.cInvName = query.value(1).toString();
    b.cInvAddCode = query.value(2).toString();
    b.cInvStd = query.value(3).toString();
    b.bSelf = query.value(4).toInt();
    b.bProxyForeign = query.value(5).toInt();
    b.bPurchase = query.value(6).toInt();
    b.iSupplyType = query.value(7).toInt();
    b.designNo = query.value(8).toString();
    b.bomVer = query.value(9).toString();
    b.bomStatus = statusMap.value(query.value(10).toString(), "未定义");
    //    b.bomStatus = query.value(10).toString();
    b.matVer = query.value(11).toString();

    materials.push_back(b);
  }

  // 如果输入
  if (materials.size() == 0) {
    QMessageBox::information(this, tr("DJPlan"), tr("无记录"));
    return;
  }

  // 在 tableview 中显示
  tvMaterial->setUpdatesEnabled(false);
  matModel->clear();

  int row = 0;
  for (const auto &m : materials) {
    matModel->setItem(row, 0, new QStandardItem(m.cInvCode));
    matModel->setItem(row, 1, new QStandardItem(m.cInvName));
    matModel->setItem(row, 2, new QStandardItem(m.cInvStd));
    matModel->setItem(row, 3, new QStandardItem(QString::number(m.bSelf)));
    matModel->setItem(row, 4, new QStandardItem(QString::number(m.bPurchase)));
    matModel->setItem(row, 5,
                      new QStandardItem(QString::number(m.bProxyForeign)));
    matModel->setItem(row, 6,
                      new QStandardItem(QString::number(m.iSupplyType)));
    matModel->setItem(row, 7, new QStandardItem(m.designNo));
    matModel->setItem(row, 8, new QStandardItem(m.bomVer));
    matModel->setItem(row, 9, new QStandardItem(m.bomStatus));
    matModel->setItem(row, 10, new QStandardItem(m.matVer));

    row += 1;
  }

  // 形成 model: 标题
  QStringList headers;
  headers << "料号"
          << "名称"
          << "规格"
          << "自制"
          << "外购"
          << "委外"
          << "制造属性"
          << "图纸号"
          << "BOM版本"
          << "BOM状态"
          << "物料版本";

  matModel->setHorizontalHeaderLabels(headers);
  tvMaterial->setModel(matModel);
  tvMaterial->resizeColumnsToContents();
  tvMaterial->setUpdatesEnabled(true);

  tabs->setCurrentIndex(0);

  if (!bomExplorer.isLoad) {
    loadRawData();
  }
}

void BOMExplorerWnd::btnReloadClicked() { loadRawData(); }

void BOMExplorerWnd::exportTableView(QTableView *tableView) {
  // 默认是 BOM 展开的导出
  QString tmp = leParent->text();

  int tabIdx = tabs->currentIndex();
  if (tabIdx == 2) {
    // 这里是 BOM 反查
    tmp = lePart->text();
  }

  QString bomName =
      QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation) +
      "/" + tmp;

  QString fileName =
      QFileDialog::getSaveFileName(this, "保存", bomName, "Excel 文件(*.xlsx)");

  if (fileName != "") {
    bool ok = ExcelApp::instance()->exportTableView(tableView, fileName);
    if (ok) {
      QMessageBox::information(this, tr("导出"), tr("导出完毕"));
    }
  }
}

void BOMExplorerWnd::btnBOMTabUpClicked() {
  // 在 parts 列表中，点击 反查；
  QModelIndex idx = tvParts->selectionModel()->currentIndex();
  int r = idx.row();

  // 如果没有选中任一记录，返回
  if (r < 0) {
    QMessageBox::information(this, tr("DJPlan"), tr("请选中一个料号"));
    return;
  }

  // 当前选中的物料
  BOMComponent p = parts.at(r);
  showBomUp(p.invCode, p.invName);
}

// BOM 展开
void BOMExplorerWnd::showBOMComponents(const std::vector<BOMComponent> &comps,
                                       QStandardItemModel *model,
                                       QTableView *tableView) {
  // 把 comps 显示到 tableview 中
  tableView->setUpdatesEnabled(false);
  model->clear();

  const int maxLevel = 8;
  int row = 0;
  for (const auto &m : comps) {
    for (int a = 0; a < maxLevel; a++) {
      model->setItem(row, a, new QStandardItem(""));
    }
    model->setItem(row, m.fullLevel - 1,
                   new QStandardItem(QString::number(m.fullLevel)));

    model->setItem(row, maxLevel, new QStandardItem(m.invCode));
    model->setItem(row, maxLevel + 1, new QStandardItem(m.invName));
    model->setItem(row, maxLevel + 2,
                   new QStandardItem(QString::number(m.baseQtyN, 10, 4)));
    model->setItem(row, maxLevel + 3,
                   new QStandardItem(QString::number(m.fullQtyN, 10, 4)));

    QString msg = "自制";
    if (m.bPurchase == 1) {
      msg = "外购";
    } else if (m.bProxyForeign == 1) {
      msg = "委外";
    }
    model->setItem(row, maxLevel + 4, new QStandardItem(msg));

    QMap<int, QString> supplyMap;
    supplyMap.insert(1, "入库倒冲");
    supplyMap.insert(2, "工序倒冲");
    supplyMap.insert(3, "领用");
    supplyMap.insert(4, "虚拟件");
    supplyMap.insert(5, "直接供应");

    QString supply = supplyMap.value(m.iSupplyType, "未定义");

    model->setItem(row, maxLevel + 5, new QStandardItem(supply));

    model->setItem(row, maxLevel + 6,
                   new QStandardItem(QString::number(m.iInvAdvance)));
    model->setItem(row, maxLevel + 7,
                   new QStandardItem(QString::number(m.fMinSupply)));
    model->setItem(row, maxLevel + 8, new QStandardItem(m.cComUnitName));

    model->setItem(row, maxLevel + 9, new QStandardItem(m.Spec));
    model->setItem(row, maxLevel + 10, new QStandardItem(m.VerDesc));
    model->setItem(row, maxLevel + 11, new QStandardItem(m.bomStatus));
    model->setItem(row, maxLevel + 12, new QStandardItem(m.matVer));

    row += 1;
  }

  // 形成 model: 标题
  QStringList headers;
  for (int a = 0; a < maxLevel; a++) {
    headers << QString::number(a + 1);
  }

  headers << "料号"
          << "名称"
          << "用量"
          << "累计用量"
          << "物料属性"
          << "制造属性"
          << "提前期"
          << "起订量"
          << "单位"
          << "图纸号"
          << "BOM版本"
          << "BOM状态"
          << "物料版本";

  model->setHorizontalHeaderLabels(headers);
  tableView->setModel(model);
  tableView->resizeColumnsToContents();
  tableView->setUpdatesEnabled(true);
}

// BOM 反查
void BOMExplorerWnd::showBOMComponentsUp(const std::vector<BOMComponent> &comps,
                                         QStandardItemModel *model,
                                         QTableView *tableView) {
  // 把 comps 显示到 tableview 中
  tableView->setUpdatesEnabled(false);
  model->clear();

  const int maxLevel = 8;
  int row = 0;
  for (const auto &m : comps) {
    for (int a = 0; a < maxLevel; a++) {
      model->setItem(row, a, new QStandardItem(""));
    }
    model->setItem(row, m.fullLevel - 1,
                   new QStandardItem(QString::number(m.fullLevel)));

    model->setItem(row, maxLevel, new QStandardItem(m.invCode));
    model->setItem(row, maxLevel + 1, new QStandardItem(m.invName));
    //    model->setItem(row, maxLevel + 2,
    //                   new QStandardItem(QString::number(m.baseQtyN, 10, 4)));
    //    model->setItem(row, maxLevel + 3,
    //                   new QStandardItem(QString::number(m.fullQtyN, 10, 4)));

    //    QString msg = "自制";
    //    if (m.bPurchase == 1) {
    //      msg = "采购";
    //    } else if (m.bProxyForeign == 1) {
    //      msg = "外协";
    //    }
    //    model->setItem(row, maxLevel + 4, new QStandardItem(msg));

    //    QString supply = "";
    //    if (m.bSelf == 1) {
    //      if (m.iSupplyType == 0) {
    //        supply = "领用";
    //      } else if (m.iSupplyType == 3) {
    //        supply = "虚拟件";
    //      }
    //    }
    //    model->setItem(row, maxLevel + 5, new QStandardItem(supply));

    //    model->setItem(row, maxLevel + 6,
    //                   new QStandardItem(QString::number(m.iInvAdvance)));
    //    model->setItem(row, maxLevel + 7,
    //                   new QStandardItem(QString::number(m.fMinSupply)));
    //    model->setItem(row, maxLevel + 8, new QStandardItem(m.cComUnitName));

    model->setItem(row, maxLevel + 2, new QStandardItem(m.Spec));
    model->setItem(row, maxLevel + 3, new QStandardItem(m.VerDesc));
    model->setItem(row, maxLevel + 4, new QStandardItem(m.bomStatus));
    model->setItem(row, maxLevel + 5, new QStandardItem(m.matVer));

    row += 1;
  }

  // 形成 model: 标题
  QStringList headers;
  for (int a = 0; a < maxLevel; a++) {
    headers << QString::number(a + 1);
  }

  headers << "料号"
          << "名称"
          //          << "用量"
          //          << "累计用量"
          //          << "物料属性"
          //          << "制造属性"
          //          << "提前期"
          //          << "起订量"
          //          << "单位"
          << "图纸号"
          << "BOM版本"
          << "BOM状态"
          << "物料版本";

  model->setHorizontalHeaderLabels(headers);
  tableView->setModel(model);
  tableView->resizeColumnsToContents();
  tableView->setUpdatesEnabled(true);
}

void BOMExplorerWnd::showBomUp(const QString &invCode, const QString &invName) {
  // BOM 反查：根据 part
  lePart->setText(QString("%1 %2").arg(invCode, invName));

  // BOM 反查
  parents = bomExplorer.dumpBomReverse(invCode);

  qDebug() << parents.size();

  showBOMComponentsUp(parents, parentModel, tvParents);

  tabs->setCurrentIndex(2);
}

void BOMExplorerWnd::showBomDown(const QString &invCode,
                                 const QString &invName) {
  // BOM 展开
  leParent->setText(QString("%1 %2").arg(invCode, invName));

  // 取得BOM表
  parts = bomExplorer.dumpBom(invCode);

  qDebug() << parents.size();

  showBOMComponents(parts, partModel, tvParts);

  tabs->setCurrentIndex(1);
}

void BOMExplorerWnd::matTabUpDown(bool isDown) {
  // material Tab 中，BOM展开，反查 功能
  // isDown=true: BOM 反查；否则 反查；
  // 打开不同的 tab
  QModelIndex idx = tvMaterial->selectionModel()->currentIndex();
  int r = idx.row();

  // 如果没有选中任一记录，返回
  if (r < 0) {
    QMessageBox::information(this, tr("DJPlan"), tr("请选中一个料号"));
    return;
  }

  // 当前选中的物料
  BOMPart p = materials.at(r);
  if (isDown) {
    showBomDown(p.cInvCode, p.cInvName);
  } else {
    showBomUp(p.cInvCode, p.cInvName);
  }
}

void BOMExplorerWnd::loadRawData() {
  btnBOM->setEnabled(false);
  btnBOMUp->setEnabled(false);

  QFuture<void> future =
      QtConcurrent::run([this]() { this->bomExplorer.init(); });

  watcher.setFuture(future);
}

void BOMExplorerWnd::afterLoadRawData() {
  btnBOM->setEnabled(true);
  btnBOMUp->setEnabled(true);
}

void BOMExplorerWnd::btnParentTabDownClicked() {
  // 在反查 tab 中，进行 BOM 展开；
  QModelIndex idx = tvParents->selectionModel()->currentIndex();
  int r = idx.row();

  // 如果没有选中任一记录，返回
  if (r < 0) {
    QMessageBox::information(this, tr("DJPlan"), tr("请选中一个料号"));
    return;
  }

  // 当前选中的物料
  BOMComponent p = parents.at(r);
  showBomDown(p.invCode, p.invName);
}

#include "moc_bomexplorerwnd.cpp"



=== bomparent.cpp 
#include "bomparent.h"

BOMParent::BOMParent() {}



=== bompart.cpp 
﻿#include "bompart.h"

BOMPart::BOMPart() {}

QString BOMPart::getType() const {
  QString s = "未定义";
  if (bSelf == 1) {
    if (iSupplyType == 0) {
      s = "自制-领用";
    } else if (iSupplyType == 3) {
      s = "自制-虚拟";
    }
  } else if (bProxyForeign == 1) {
    s = "委外";
  } else if (bPurchase == 1) {
    s = "外购";
  }

  return s;
}



=== cursorguard.cpp 
﻿#include "cursorguard.h"

CursorGuard::CursorGuard() {
  QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));
}

CursorGuard::~CursorGuard() { QApplication::restoreOverrideCursor(); }



=== deliveryplanwnd.cpp 
﻿#include "deliveryplanwnd.h"

#include "excelapp.h"
#include "global.h"
#include <QtSql>
#include <QtWidgets>

DeliveryPlanWnd::DeliveryPlanWnd(QWidget *parent) : QWidget(parent) {
  prepareUI();

  // 更新后的回调函数
  connect(&watch, SIGNAL(finished()), this, SLOT(postFetchItems()));

  showMaximized();
}

void DeliveryPlanWnd::prepareUI() {
  tabs = new QTabWidget;
  tabs->addTab(createPPTab(), tr("发货计划与实际"));
  //  tabs->addTab(createMOTab(), tr("外协订单"));

  QVBoxLayout *vBox = new QVBoxLayout;
  vBox->addWidget(tabs);
  setLayout(vBox);

  setWindowTitle(tr("发货分析"));
}

QWidget *DeliveryPlanWnd::createPPTab() {
  QLabel *lfrom = new QLabel(tr("开始日期"));
  lfrom->setAlignment(Qt::AlignRight | Qt::AlignCenter);
  QLabel *lto = new QLabel(tr("结束日期"));
  lto->setAlignment(Qt::AlignRight | Qt::AlignCenter);

  // 默认之前一个星期；
  QDate t1, t2;
  t2 = QDate::currentDate();
  t1 = t2.addDays(-7);

  dteFrom = new QDateTimeEdit(t1);
  dteFrom->setCalendarPopup(true);
  dteFrom->setDisplayFormat(dateFormat);

  dteTo = new QDateTimeEdit(t2);
  dteTo->setCalendarPopup(true);
  dteTo->setDisplayFormat(dateFormat);

  //  QLabel *labelMaterial = new QLabel(tr("物料"));
  //  leMaterial = new QLineEdit;

  btnSearch = new QPushButton(tr("查找"));
  QPushButton *btnPPExport = new QPushButton(tr("导出"));

  connect(btnSearch, &QPushButton::clicked, this,
          &DeliveryPlanWnd::btnSearchClicked);

  connect(btnPPExport, &QPushButton::clicked,
          [this]() { exportTableView(tvPP); });

  QHBoxLayout *hlayout = new QHBoxLayout;
  hlayout->addWidget(lfrom);
  hlayout->addWidget(dteFrom);
  hlayout->addWidget(lto);
  hlayout->addWidget(dteTo);
  //  hlayout->addWidget(labelMaterial);
  //  hlayout->addWidget(leMaterial);

  hlayout->addWidget(btnSearch);
  hlayout->addWidget(btnPPExport);

  tvPP = new QTableView;
  tvPP->setStyleSheet("font: 8pt 微软雅黑;");
  ppModel = new QStandardItemModel;

  // 形成 model: 标题
  QStringList headers;
  headers << "客户"
          << "料号"
          << "名称"
          << "计划"
          << "实际";
  ppModel->setHorizontalHeaderLabels(headers);
  tvPP->setModel(ppModel);

  QVBoxLayout *vBox = new QVBoxLayout;
  vBox->addLayout(hlayout);
  vBox->addWidget(tvPP);

  QWidget *w = new QWidget;
  w->setLayout(vBox);

  return w;
}

void DeliveryPlanWnd::btnSearchClicked() {
  // 从界面读入查询条件
  // 订单创建日期，起/止
  QString pFrom = dteFrom->date().toString(dateFormat);
  QString pTo = dteTo->date().toString(dateFormat);

  // 和 sql 对应
  // 出入库时间
  QString cond1 =
      QString(" and (rd.dDate >= '%1' and rd.dDate < '%2')").arg(pFrom, pTo);

  // 加载 sql
  QString sqlTemplate = loadSqlCmd("6.sql");
  QString sqlCmd = sqlTemplate.arg(cond1);
  qDebug() << "cmd: " << sqlCmd;

  QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));
  btnSearch->setEnabled(false);

  QFuture<void> future =
      QtConcurrent::run([this, sqlCmd]() { fetchItems(sqlCmd); });

  watch.setFuture(future);
}

void DeliveryPlanWnd::fetchItems(const QString &sqlCmd) {
  QSqlDatabase db = QSqlDatabase::database(CONN_SRC);
  QSqlQuery query(db);
  query.setForwardOnly(true);

  query.prepare(sqlCmd);

  bool ok = query.exec();

  if (!ok) {
    QSqlError error = db.lastError();
    qDebug() << "Filed: btnSearchClicked "
             << QString("err: %1").arg(error.text());
    return;
  }

  allItems.clear();
  while (query.next()) {
    QStringList item;

    // 不同列的处理
    for (int c = 0; c <= colCnt; c++) {
      // 全部是字符类型
      item.push_back(query.value(c).toString());
    }

    allItems.push_back(item);
  }
}

void DeliveryPlanWnd::postFetchItems() {
  QStandardItemModel *model = ppModel;
  QTableView *tableView = tvPP;

  tableView->setUpdatesEnabled(false);

  // 把结果集，显示在tableview 中；
  // 结果集中都是字符；
  model->removeRows(0, model->rowCount());
  int row = 0;
  for (const auto &it : allItems) {
    for (int c = 0; c <= colCnt; c++) {
      model->setItem(row, c, new QStandardItem(it.at(c)));
    }

    row++;
  }

  tableView->resizeColumnsToContents();
  tableView->setUpdatesEnabled(true);

  btnSearch->setEnabled(true);
  QApplication::restoreOverrideCursor();

  QMessageBox::information(this, tr(""), tr("执行完毕"));
}

void DeliveryPlanWnd::exportTableView(QTableView *view) {
  QString fileName = QFileDialog::getSaveFileName(
      this, "保存",
      QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation),
      "Excel 文件(*.xlsx)");

  if (fileName != "") {
    bool ok = ExcelApp::instance()->exportTableView(view, fileName);
    if (ok) {
      QMessageBox::information(this, tr("导出"), tr("导出完毕"));
    }
  }
}

#include "moc_deliveryplanwnd.cpp"



=== etldispatchitem.cpp 
#include "etldispatchitem.h"

ETLDispatchItem::ETLDispatchItem()
{

}



=== etldispatchlist.cpp 
#include "etldispatchlist.h"

ETLDispatchList::ETLDispatchList() {}



=== etlso.cpp 
#include "etlso.h"

ETLSO::ETLSO()
{

}



=== etlsoitem.cpp 
#include "etlsoitem.h"

ETLSOItem::ETLSOItem()
{

}



=== etlsord.cpp 
#include "etlsord.h"

ETLSORd::ETLSORd() {}



=== etlsorditem.cpp 
#include "etlsorditem.h"

ETLSORdItem::ETLSORdItem()
{

}



=== etlsotools.cpp 
#include "etlsotools.h"

#include "global.h"
#include <QtSql>

ETLSOTools::ETLSOTools() { setupDB(); }

void ETLSOTools::setupDB() {
  // todo: 每次使用时，重新获得，而不是取得后存起来；
  dbSource = QSqlDatabase::database(CONN_SRC);
  dbTarget = QSqlDatabase::database(CONN_TARGET);
}

// 读取原表数据
std::vector<ETLSO> ETLSOTools::soMainQuery(const QString &from,
                                           const QString &to) {
  std::vector<ETLSO> items;

  QString cmd = SOMain_Select + SOMain_Cond;

  QSqlQuery query(dbSource);
  query.setForwardOnly(true);
  query.prepare(cmd);
  query.bindValue(":from", from);
  query.bindValue(":to", to);
  bool ok = query.exec();

  if (!ok) {
    QSqlError error = dbSource.lastError();
    qDebug()
        << "Filed: soMainQuery "
        << QString("from: %1, to: %2: err: %3").arg(from, to, error.text());
    return items;
  }

  while (query.next()) {
    ETLSO i;
    i.SOHeaderID = query.value(0).toLongLong();
    i.cPersonCode = query.value(1).toString();
    i.cPersonName = query.value(2).toString();
    i.cMaker = query.value(3).toString();
    i.cSOCode = query.value(4).toString();
    i.cCusCode = query.value(5).toString();
    i.cDepName = query.value(6).toString();
    i.cCusName = query.value(7).toString();
    i.dDate = query.value(8).toDate().toString("yyyy-MM-dd");

    items.push_back(i);
  }
  return items;
}

// 删除目标表数据
bool ETLSOTools::soMainDelete(const QString &from, const QString &to) {
  QString cmd = SOMain_Delete + SOMain_Cond;
  qDebug() << "cmd: " << cmd;

  QSqlQuery query(dbTarget);
  query.prepare(cmd);
  query.bindValue(":from", from);
  query.bindValue(":to", to);
  bool ok = query.exec();

  if (!ok) {
    QSqlError error = dbTarget.lastError();
    qDebug()
        << "Failed: soMainDelete "
        << QString("from: %1, to: %2: err: %3").arg(from, to, error.text());
  }

  return ok;
}

// 插入目标表数据
bool ETLSOTools::soMainInsertAll(const std::vector<ETLSO> &items) {
  QString cmd = SOMain_Insert;
  qDebug() << "cmd: " << cmd;

  QSqlQuery query(dbTarget);
  query.prepare(cmd);

  bool ok;

  for (auto &i : items) {
    query.bindValue(":SOHeaderID", i.SOHeaderID);
    query.bindValue(":cPersonCode", i.cPersonCode);
    query.bindValue(":cPersonName", i.cPersonName);
    query.bindValue(":cMaker", i.cMaker);
    query.bindValue(":cSOCode", i.cSOCode);
    query.bindValue(":cCusCode", i.cCusCode);
    query.bindValue(":cDepName", i.cDepName);
    query.bindValue(":cCusName", i.cCusName);
    query.bindValue(":dDate", i.dDate);
    ok = query.exec();

    if (!ok) {
      QSqlError error = dbTarget.lastError();
      qDebug() << QString("Failed: soMainInsertAll: %1 %2")
                      .arg(i.cSOCode, error.text());
      return ok;
    }
  }

  return ok;
}

void ETLSOTools::soMainLoad(const QString &from, const QString &to) {
  std::vector<ETLSO> items = soMainQuery(from, to);

  dbTarget.transaction();

  soMainDelete(from, to);
  soMainInsertAll(items);

  dbTarget.commit();
}

std::vector<ETLSOItem> ETLSOTools::soItemQuery(const QString &from,
                                               const QString &to) {
  std::vector<ETLSOItem> items;

  QString cmd = SO_SODetails_Select + SOMain_Cond;

  QSqlQuery query(dbSource);
  query.setForwardOnly(true);
  query.prepare(cmd);
  query.bindValue(":from", from);
  query.bindValue(":to", to);
  bool ok = query.exec();

  if (!ok) {
    QSqlError error = dbSource.lastError();
    qDebug()
        << QString("Failed: %1").arg(cmd)
        << QString("from: %1, to: %2: err: %3").arg(from, to, error.text());

    return items;
  }

  while (query.next()) {
    ETLSOItem i;
    i.SOHeaderID = query.value(0).toLongLong();
    i.iSOsID = query.value(1).toLongLong();
    i.cInvCode = query.value(2).toString();
    i.cInvName = query.value(3).toString();
    i.cItemCode = query.value(4).toString();
    i.cItemName = query.value(5).toString();
    i.iQuantity = query.value(6).toInt();
    i.iFHQuantity = query.value(7).toInt();
    items.push_back(i);
  }

  return items;
}

bool ETLSOTools::soItemDelete(const QString &from, const QString &to) {
  QString cmd = SO_SODetails_Delete + SOMain_Cond;
  qDebug() << "cmd: " << cmd;

  QSqlQuery query(dbTarget);
  query.prepare(cmd);
  query.bindValue(":from", from);
  query.bindValue(":to", to);
  bool ok = query.exec();

  if (!ok) {
    QSqlError error = dbTarget.lastError();
    qDebug()
        << "Failed: soItemDelete "
        << QString("from: %1, to: %2: err: %3").arg(from, to, error.text());
  }

  return ok;
}

bool ETLSOTools::soItemInsertAll(const std::vector<ETLSOItem> &items) {
  QString cmd = SO_SODetails_Insert;
  qDebug() << "cmd: " << cmd;

  QSqlQuery query(dbTarget);
  query.prepare(cmd);

  bool ok;
  for (auto &i : items) {
    query.bindValue(":SOHeaderID", i.SOHeaderID);
    query.bindValue(":iSOsID", i.iSOsID);
    query.bindValue(":cInvCode", i.cInvCode);
    query.bindValue(":cInvName", i.cInvName);
    query.bindValue(":cItemCode", i.cItemCode);
    query.bindValue(":cItemName", i.cItemName);
    query.bindValue(":iQuantity", i.iQuantity);
    query.bindValue(":iFHQuantity", i.iFHQuantity);

    ok = query.exec();
    if (!ok) {
      QSqlError error = dbTarget.lastError();
      qDebug() << QString("Failed: %1").arg(error.text());
      return ok;
    }
  }

  return ok;
}

void ETLSOTools::soItemLoad(const QString &from, const QString &to) {
  std::vector<ETLSOItem> items = soItemQuery(from, to);

  dbTarget.transaction();

  soItemDelete(from, to);
  soItemInsertAll(items);

  dbTarget.commit();
}

std::vector<ETLSORd> ETLSOTools::soRdQuery(const QString &from,
                                           const QString &to) {
  std::vector<ETLSORd> items;

  QString cmd = RdRecord32_Select + SOMain_Cond;

  QSqlQuery query(dbSource);
  query.setForwardOnly(true);
  query.prepare(cmd);
  query.bindValue(":from", from);
  query.bindValue(":to", to);
  bool ok = query.exec();

  if (!ok) {
    QSqlError error = dbTarget.lastError();
    qDebug()
        << QString("Failed: %1").arg(cmd)
        << QString("from: %1, to: %2: err: %3").arg(from, to, error.text());
  }

  while (query.next()) {
    ETLSORd i;
    i.RdRecordID = query.value(0).toLongLong();
    i.cMaker = query.value(1).toString();
    i.cHandler = query.value(2).toString();
    i.dDate = query.value(3).toDate().toString("yyyy-MM-dd");
    i.cMemo = query.value(4).toString();
    i.cBusType = query.value(5).toString();
    i.cCusCode = query.value(6).toString();
    i.cDLCode = query.value(7).toString();
    i.cCusName = query.value(8).toString();
    items.push_back(i);
  }

  return items;
}

bool ETLSOTools::soRdDelete(const QString &from, const QString &to) {
  QString cmd = RdRecord32_Delete + SOMain_Cond;
  qDebug() << "cmd: " << cmd;

  QSqlQuery query(dbTarget);
  query.prepare(cmd);
  query.bindValue(":from", from);
  query.bindValue(":to", to);
  bool ok = query.exec();

  if (!ok) {
    QSqlError error = dbTarget.lastError();
    qDebug()
        << "Failed: soItemDelete "
        << QString("from: %1, to: %2: err: %3").arg(from, to, error.text());
  }

  return ok;
}

bool ETLSOTools::soRdInsertAll(const std::vector<ETLSORd> &items) {
  QString cmd = RdRecord32_Insert;
  qDebug() << "cmd: " << cmd;

  QSqlQuery query(dbTarget);
  query.prepare(cmd);

  bool ok;
  for (auto &i : items) {
    query.bindValue(":RdRecordID", i.RdRecordID);
    query.bindValue(":cMaker", i.cMaker);
    query.bindValue(":cHandler", i.cHandler);
    query.bindValue(":dDate", i.dDate);
    query.bindValue(":cMemo", i.cMemo);
    query.bindValue(":cBusType", i.cBusType);
    query.bindValue(":cCusCode", i.cCusCode);
    query.bindValue(":cDLCode", i.cDLCode);
    query.bindValue(":cCusName", i.cCusName);
    ok = query.exec();
    if (!ok) {
      QSqlError error = dbTarget.lastError();
      qDebug() << QString("Failed: %1").arg(error.text());
      return ok;
    }
  }
  return ok;
}

void ETLSOTools::soRdLoad(const QString &from, const QString &to) {
  std::vector<ETLSORd> items = soRdQuery(from, to);

  dbTarget.transaction();

  soRdDelete(from, to);
  soRdInsertAll(items);

  dbTarget.commit();
}

std::vector<ETLSORdItem> ETLSOTools::soRdItemQuery(const QString &from,
                                                   const QString &to) {
  std::vector<ETLSORdItem> items;

  QString cmd = RdRecords32_Select + SOMain_Cond;
  qDebug() << "cmd: " << cmd;

  QSqlQuery query(dbSource);
  query.setForwardOnly(true);
  query.prepare(cmd);
  query.bindValue(":from", from);
  query.bindValue(":to", to);
  bool ok = query.exec();

  if (!ok) {
    QSqlError error = dbSource.lastError();
    qDebug()
        << QString("Failed: %1").arg(cmd)
        << QString("from: %1, to: %2: err: %3").arg(from, to, error.text());

    return items;
  }

  while (query.next()) {
    ETLSORdItem i;
    i.RdRecordID = query.value(0).toLongLong();
    i.iSOsID = query.value(1).toLongLong();
    i.iQuantity = query.value(2).toInt();
    i.cDefine28 = query.value(3).toString();
    i.cInvCode = query.value(4).toString();
    i.cItem_class = query.value(5).toString();
    i.cItemCName = query.value(6).toString();
    i.cItemCode = query.value(7).toString();
    i.cName = query.value(8).toString();
    items.push_back(i);
  }
  return items;
}

bool ETLSOTools::soRdItemDelete(const QString &from, const QString &to) {
  QString cmd = RdRecords32_Delete + SOMain_Cond;
  qDebug() << "cmd: " << cmd;

  QSqlQuery query(dbTarget);
  query.prepare(cmd);
  query.bindValue(":from", from);
  query.bindValue(":to", to);
  bool ok = query.exec();

  if (!ok) {
    QSqlError error = dbTarget.lastError();
    qDebug()
        << "Failed: soRdItemDelete "
        << QString("from: %1, to: %2: err: %3").arg(from, to, error.text());
  }

  return ok;
}

bool ETLSOTools::soRdItemInsertAll(const std::vector<ETLSORdItem> &items) {

  QString cmd = RdRecords32_Insert;
  qDebug() << "cmd: " << cmd;
  QSqlQuery query(dbTarget);
  query.prepare(cmd);
  bool ok;
  for (auto &i : items) {
    query.bindValue(":RdRecordID", i.RdRecordID);
    query.bindValue(":iSOsID", i.iSOsID);
    query.bindValue(":iQuantity", i.iQuantity);
    query.bindValue(":cDefine28", i.cDefine28);
    query.bindValue(":cInvCode", i.cInvCode);
    query.bindValue(":cItem_class", i.cItem_class);
    query.bindValue(":cItemCName", i.cItemCName);
    query.bindValue(":cItemCode", i.cItemCode);
    query.bindValue(":cName", i.cName);
    ok = query.exec();
    if (!ok) {
      QSqlError error = dbTarget.lastError();
      qDebug() << QString("Failed: %1").arg(error.text());
      return ok;
    }
  }
  return ok;
}

void ETLSOTools::soRdItemLoad(const QString &from, const QString &to) {
  std::vector<ETLSORdItem> items = soRdItemQuery(from, to);

  dbTarget.transaction();

  soRdItemDelete(from, to);
  soRdItemInsertAll(items);

  dbTarget.commit();
}

// dispatchlist
std::vector<ETLDispatchList> ETLSOTools::dispatchListQuery(const QString &from,
                                                           const QString &to) {
  std::vector<ETLDispatchList> items;

  QString cmd = DispatchList_Select + SOMain_Cond;
  qDebug() << "cmd: " << cmd;

  QSqlQuery query(dbSource);
  query.setForwardOnly(true);
  query.prepare(cmd);
  query.bindValue(":from", from);
  query.bindValue(":to", to);
  bool ok = query.exec();

  if (!ok) {
    QSqlError error = dbSource.lastError();
    qDebug()
        << QString("Failed: %1").arg(cmd)
        << QString("from: %1, to: %2: err: %3").arg(from, to, error.text());

    return items;
  }

  while (query.next()) {
    ETLDispatchList i;
    i.DLID = query.value(0).toLongLong();
    i.dDate = query.value(1).toDate().toString(dateFormat);
    i.cCusCode = query.value(2).toString();
    i.cCusName = query.value(3).toString();
    i.cBusType = query.value(4).toString();
    i.cMaker = query.value(5).toString();
    i.cMemo = query.value(6).toString();
    i.cPersonCode = query.value(7).toString();
    i.cShipAddress = query.value(8).toString();
    i.cVerifier = query.value(9).toString();
    i.dverifydate = query.value(10).toDate().toString(dateFormat);
    i.cmodifier = query.value(11).toString();
    i.dmoddate = query.value(12).toDate().toString(dateFormat);
    items.push_back(i);
  }
  return items;
}

bool ETLSOTools::dispatchListDelete(const QString &from, const QString &to) {
  QString cmd = DispatchList_Delete;
  qDebug() << "cmd: " << cmd;

  QSqlQuery query(dbTarget);
  query.prepare(cmd);
  query.bindValue(":from", from);
  query.bindValue(":to", to);
  bool ok = query.exec();

  if (!ok) {
    QSqlError error = dbTarget.lastError();
    qDebug()
        << "Failed: dispatchListDelete "
        << QString("from: %1, to: %2: err: %3").arg(from, to, error.text());
  }

  return ok;
}

bool ETLSOTools::dispatchListInsertAll(
    const std::vector<ETLDispatchList> &items) {

  QString cmd = DispatchList_Insert;
  qDebug() << "cmd: " << cmd;
  QSqlQuery query(dbTarget);
  query.prepare(cmd);
  bool ok;
  for (auto &i : items) {
    query.bindValue(":DLID", i.DLID);
    query.bindValue(":dDate", i.dDate);
    query.bindValue(":cCusCode", i.cCusCode);
    query.bindValue(":cCusName", i.cCusName);
    query.bindValue(":cBusType", i.cBusType);
    query.bindValue(":cMaker", i.cMaker);
    query.bindValue(":cMemo", i.cMemo);
    query.bindValue(":cPersonCode", i.cPersonCode);
    query.bindValue(":cShipAddress", i.cShipAddress);
    query.bindValue(":cVerifier", i.cVerifier);
    query.bindValue(":dverifydate", i.dverifydate);
    query.bindValue(":cmodifier", i.cmodifier);
    query.bindValue(":dmoddate", i.dmoddate);
    ok = query.exec();
    if (!ok) {
      QSqlError error = dbTarget.lastError();
      qDebug() << QString("Failed: %1").arg(error.text());
      return ok;
    }
  }
  return ok;
}

void ETLSOTools::dispatchListLoad(const QString &from, const QString &to) {
  std::vector<ETLDispatchList> items = dispatchListQuery(from, to);

  dbTarget.transaction();

  dispatchListDelete(from, to);
  dispatchListInsertAll(items);

  dbTarget.commit();
}

// dispatchlist item
std::vector<ETLDispatchItem> ETLSOTools::dispatchItemQuery(const QString &from,
                                                           const QString &to) {
  std::vector<ETLDispatchItem> items;

  QString cmd = DispatchLists_Select;
  qDebug() << "cmd: " << cmd;

  QSqlQuery query(dbSource);
  query.setForwardOnly(true);
  query.prepare(cmd);
  query.bindValue(":from", from);
  query.bindValue(":to", to);
  bool ok = query.exec();

  if (!ok) {
    QSqlError error = dbSource.lastError();
    qDebug()
        << QString("Failed: %1").arg(cmd)
        << QString("from: %1, to: %2: err: %3").arg(from, to, error.text());

    return items;
  }

  while (query.next()) {
    ETLDispatchItem i;
    i.iDLsID = query.value(0).toLongLong();
    i.DLID = query.value(1).toLongLong();
    i.iSOsID = query.value(2).toLongLong();
    i.cInvCode = query.value(3).toString();
    i.cInvName = query.value(4).toString();
    i.iQuantity = query.value(5).toString();
    i.fOutQuantity = query.value(6).toString();
    i.cItemCode = query.value(7).toString();
    i.cItem_class = query.value(8).toString();
    i.cItemName = query.value(9).toString();
    i.cItem_CName = query.value(10).toString();
    items.push_back(i);
  }
  return items;
}

bool ETLSOTools::dispatchItemDelete(const QString &from, const QString &to) {
  QString cmd = DispatchLists_Delete;
  qDebug() << "cmd: " << cmd;

  QSqlQuery query(dbTarget);
  query.prepare(cmd);
  query.bindValue(":from", from);
  query.bindValue(":to", to);
  bool ok = query.exec();

  if (!ok) {
    QSqlError error = dbTarget.lastError();
    qDebug()
        << "Failed: dispatchListDelete "
        << QString("from: %1, to: %2: err: %3").arg(from, to, error.text());
  }

  return ok;
}

bool ETLSOTools::dispatchItemInsertAll(
    const std::vector<ETLDispatchItem> &items) {

  QString cmd = DispatchLists_Insert;
  qDebug() << "cmd: " << cmd;
  QSqlQuery query(dbTarget);
  query.prepare(cmd);
  bool ok;
  for (auto &i : items) {
    query.bindValue(":iDLsID", i.iDLsID);
    query.bindValue(":DLID", i.DLID);
    query.bindValue(":iSOsID", i.iSOsID);
    query.bindValue(":cInvCode", i.cInvCode);
    query.bindValue(":cInvName", i.cInvName);
    query.bindValue(":iQuantity", i.iQuantity);
    query.bindValue(":fOutQuantity", i.fOutQuantity);
    query.bindValue(":cItemCode", i.cItemCode);
    query.bindValue(":cItem_class", i.cItem_class);
    query.bindValue(":cItemName", i.cItemName);
    query.bindValue(":cItem_CName", i.cItem_CName);
    ok = query.exec();
    if (!ok) {
      QSqlError error = dbTarget.lastError();
      qDebug() << QString("Failed: %1").arg(error.text());
      return ok;
    }
  }
  return ok;
}

void ETLSOTools::dispatchItemLoad(const QString &from, const QString &to) {
  std::vector<ETLDispatchItem> items = dispatchItemQuery(from, to);

  dbTarget.transaction();

  dispatchItemDelete(from, to);
  dispatchItemInsertAll(items);

  updateSOItemsFHQty(from, to);

  dbTarget.commit();
}

void ETLSOTools::updateSOItemsFHQty(const QString &from, const QString &to) {
  QString cmd = updateSOItemsbyDispatchItem;
  qDebug() << "cmd: " << cmd;

  QSqlQuery query(dbTarget);
  query.prepare(cmd);
  query.bindValue(":from", from);
  query.bindValue(":to", to);
  bool ok = query.exec();

  if (!ok) {
    QSqlError error = dbTarget.lastError();
    qDebug()
        << "Failed: updateSOItemsFHQty "
        << QString("from: %1, to: %2: err: %3").arg(from, to, error.text());
  }
}



=== etlwnd.cpp 
#include "etlwnd.h"

#include <vector>

#include "etlsotools.h"

ETLWnd::ETLWnd(QWidget *parent) : QWidget(parent) { setupUI(); }

void ETLWnd::setupUI() {
  QLabel *lfrom = new QLabel(tr("开始日期"));
  lfrom->setAlignment(Qt::AlignRight);
  QLabel *lto = new QLabel(tr("结束日期"));
  lto->setAlignment(Qt::AlignRight);

  // 抽取时间
  // 默认之前一个月；
  QDate t1, t2;
  t2 = QDate::currentDate();
  t1 = t2.addMonths(-1);

  dteFrom = new QDateTimeEdit(t1);
  dteFrom->setCalendarPopup(true);
  dteFrom->setDisplayFormat(dateFormat);

  dteTo = new QDateTimeEdit(t2);
  dteTo->setCalendarPopup(true);
  dteTo->setDisplayFormat(dateFormat);

  QHBoxLayout *hlayout = new QHBoxLayout;
  hlayout->addWidget(lfrom);
  hlayout->addWidget(dteFrom);
  hlayout->addWidget(lto);
  hlayout->addWidget(dteTo);
  //  hlayout->addStretch();

  // 每张表，对应一个单独的按钮
  QPushButton *btn1 = new QPushButton(tr("销售订单"));
  QPushButton *btn2 = new QPushButton(tr("销售订单行项目"));
  QPushButton *btn3 = new QPushButton(tr("发货单"));
  QPushButton *btn4 = new QPushButton(tr("发货单行项目"));
  QPushButton *btn5 = new QPushButton(tr("出库单"));
  QPushButton *btn6 = new QPushButton(tr("出库单行项目"));

  connect(btn1, &QPushButton::clicked, this, &ETLWnd::loadSo);
  connect(btn2, &QPushButton::clicked, this, &ETLWnd::loadSoItems);
  connect(btn3, &QPushButton::clicked, this, &ETLWnd::loadSoDL);
  connect(btn4, &QPushButton::clicked, this, &ETLWnd::loadSoDLItems);
  connect(btn5, &QPushButton::clicked, this, &ETLWnd::loadSoRd);
  connect(btn6, &QPushButton::clicked, this, &ETLWnd::loadSoRdItems);

  QGridLayout *grid1 = new QGridLayout;
  grid1->addLayout(hlayout, 0, 0, 1, 2);
  grid1->addWidget(btn1, 1, 0, 1, 1);
  grid1->addWidget(btn2, 1, 1, 1, 1);
  grid1->addWidget(btn3, 1, 2, 1, 1);
  grid1->addWidget(btn4, 1, 3, 1, 1);
  grid1->addWidget(btn5, 1, 4, 1, 1);
  grid1->addWidget(btn6, 1, 5, 1, 1);

  //  QVBoxLayout *v2 = new QVBoxLayout;
  //  v2->addLayout(hlayout);
  //  v2->addLayout(grid1);

  // 代码生成器
  teResult = new QTextEdit;
  QPushButton *btnGen = new QPushButton(tr("Gen Code"));
  connect(btnGen, &QPushButton::clicked, this, &ETLWnd::genCode);

  QVBoxLayout *vlayout = new QVBoxLayout;
  vlayout->addLayout(grid1);
  vlayout->addSpacing(12);
  vlayout->addWidget(teResult);
  vlayout->addWidget(btnGen);
  //  vlayout->addStretch();
  setLayout(vlayout);

  setWindowTitle(tr("ETL"));
  resize(1400, 900);
}

void ETLWnd::loadSo() {
  QString from, to;
  bool rtn = canProcessLoad(from, to);
  if (rtn) {
    ETLSOTools tool;
    tool.soMainLoad(from, to);
    QMessageBox::information(this, tr("ETL"), tr("抽取完毕"));
  }
}

void ETLWnd::loadSoItems() {
  QString from, to;
  bool rtn = canProcessLoad(from, to);
  if (rtn) {
    ETLSOTools tool;
    tool.soItemLoad(from, to);
    QMessageBox::information(this, tr("ETL"), tr("抽取完毕"));
  }
}

void ETLWnd::loadSoDL() {
  QString from, to;
  bool rtn = canProcessLoad(from, to);
  if (rtn) {
    ETLSOTools tool;
    tool.dispatchListLoad(from, to);
    QMessageBox::information(this, tr("ETL"), tr("抽取完毕"));
  }
}

void ETLWnd::loadSoDLItems() {
  QString from, to;
  bool rtn = canProcessLoad(from, to);
  if (rtn) {
    ETLSOTools tool;
    tool.dispatchItemLoad(from, to);
    QMessageBox::information(this, tr("ETL"), tr("抽取完毕"));
  }
}

void ETLWnd::loadSoRd() {
  QString from, to;
  bool rtn = canProcessLoad(from, to);
  if (rtn) {
    ETLSOTools tool;
    tool.soRdLoad(from, to);
    QMessageBox::information(this, tr("ETL"), tr("抽取完毕"));
  }
}

void ETLWnd::loadSoRdItems() {
  QString from, to;
  bool rtn = canProcessLoad(from, to);
  if (rtn) {
    ETLSOTools tool;
    tool.soRdItemLoad(from, to);
    QMessageBox::information(this, tr("ETL"), tr("抽取完毕"));
  }
}

bool ETLWnd::canProcessLoad(QString &from, QString &to) {
  from = dteFrom->date().toString(dateFormat);
  to = dteTo->date().toString(dateFormat);
  qDebug() << QString("(from, to) = (%1, %2)").arg(from, to);

  if (from.length() == 0 || to.length() == 0) {
    QMessageBox::information(this, tr("ETL"), tr("请输入日期"));
    return false;
  } else {
    return true;
  }
}

void ETLWnd::genCode() {
  teResult->setText(tr("generate code here...."));

  QString fileName =
      QFileDialog::getOpenFileName(this, QString(), QString(), "txt(*.txt)");

  if (fileName.isEmpty()) {
    QMessageBox::information(this, tr("Code"), tr("请选择文件"));
    return;
  }

  QString tableName;
  QStringList columns;

  int row = 0;
  QFile file(fileName);
  if (file.open(QFile::ReadOnly)) {
    while (!file.atEnd()) {
      QString line = file.readLine(200).simplified().trimmed();

      if (line.length() == 0) {
        break;
      }

      if (row == 0) {
        tableName = line;
      } else {
        QStringList cs = line.split(QRegExp(",| "), QString::SkipEmptyParts);
        columns << cs;
      }

      ++row;
    }
  }

  file.close();

  int colCnt = (int)columns.size();
  QStringList columnsBind;

  // field
  QStringList part1;
  part1 << "public: ";
  for (int i = 0; i < colCnt; i++) {
    QString col = columns.at(i);
    part1 << QString("QString %1; ").arg(col);

    // 每个字段前加: 用以 bind
    columnsBind.append(QString(":%1").arg(col));
  }

  QString allCol = columns.join(", ");
  QString allColBind = columnsBind.join(", ");

  QString cmdSelect =
      QString("const QString %1_Select = \" select %2 from %1 where 1 = 1\"; ")
          .arg(tableName, allCol);

  part1 << "" << cmdSelect;

  QString cmdInsert =
      QString(
          "const QString %1_Insert = \" insert into %1 (%2) values (%3)\"; ")
          .arg(tableName, allCol, allColBind);

  part1 << "" << cmdInsert;

  QString cmdDelete =
      QString("const QString %1_Delete = \" delete from %1 where 1 = 1 \"; ")
          .arg(tableName);

  part1 << "" << cmdDelete;

  QStringList selectMapper;
  selectMapper << "while (query.next()) {";
  selectMapper << "TypeXXX i; ";
  for (int i = 0; i < colCnt; i++) {
    selectMapper << QString("i.%1 = query.value(%2).toString();")
                        .arg(columns.at(i), QString::number(i));
  }
  selectMapper << "items.push_back(i); } return items; ";
  part1 << "" << selectMapper;

  QStringList insBinder;
  insBinder << QString("QString cmd = %1_Insert; ").arg(tableName);
  insBinder << "qDebug() << \"cmd: \" << cmd;";
  insBinder << "QSqlQuery query(dbTarget); "
               "query.prepare(cmd);";
  insBinder << "bool ok; for (auto &i : items) {";
  for (int i = 0; i < colCnt; i++) {
    insBinder << QString("query.bindValue(\"%1\", i.%2);")
                     .arg(columnsBind.at(i), columns.at(i));
  }
  insBinder << "  ok = query.exec();  if (!ok) { QSqlError error = "
               "dbTarget.lastError();"
               "qDebug() << QString(\"Failed: %1\").arg(error.text()); "
               "return ok; }} return ok;";

  part1 << "" << insBinder;

  teResult->clear();
  for (int i = 0; i < part1.size(); i++) {
    teResult->append(part1.at(i));
  }
}

#include "moc_etlwnd.cpp"



=== excelapp.cpp 
#include "excelapp.h"

#include <QApplication>
#include <QAxObject>
#include <QFileDialog>
#include <QMutex>
#include <QMutexLocker>
#include <QTableView>

QScopedPointer<ExcelApp> ExcelApp::m_instance;

ExcelApp *ExcelApp::instance() {
  static QMutex mutex;
  if (m_instance.isNull()) {
    QMutexLocker locker(&mutex);
    m_instance.reset(new ExcelApp);
    m_instance->initExcel();
  }

  qDebug() << "get global data. ";
  return m_instance.data();
}

ExcelApp::~ExcelApp() { quitExcel(); }

ExcelApp::ExcelApp() { qDebug() << "create global data. "; }

QAxObject *ExcelApp::getExcelApp() { return m_xls.data(); }

QAxObject *ExcelApp::getWorkbooks() { return m_workbooks.data(); }

bool ExcelApp::exportTableView(QTableView *tableView, const QString &fileName) {
  if (fileName != "") {
    // 以防万一，再初始化一次
    initExcel();

    m_workbooks->dynamicCall("Add"); //新建一个工作簿
    QAxObject *workbook =
        m_xls->querySubObject("ActiveWorkBook"); //获取当前工作簿
    QAxObject *worksheet = workbook->querySubObject("Worksheets(int)", 1);

    // 计算 tableview 的总行数，总列数，对应到 excel
    // 的区域，为后续一次性写入做准备
    int rowCount = tableView->model()->rowCount();
    int colCount = tableView->model()->columnCount();
    QString colName = calcColName(colCount);
    qDebug() << QString("(row, col, colName): (%1, %2, %3)")
                    .arg(QString::number(rowCount), QString::number(colCount),
                         colName);

    // 把表头导出
    QVariantList headers;
    for (int c = 0; c < colCount; c++) {
      headers.append(tableView->model()->headerData(c, Qt::Horizontal));
    }
    QVariant headData(headers);

    QString rangeHeader = QString("A1:%1%2").arg(colName, QString::number(1));
    qDebug() << "header range: " << rangeHeader;

    QAxObject *rangeH =
        worksheet->querySubObject("Range(const QString&)", rangeHeader);
    rangeH->setProperty("Value", headData);

    // 内容导出，由于有表头，所以从第二行开始
    QString rangeStr =
        QString("A2:%1%2").arg(colName, QString::number(rowCount + 1));
    qDebug() << "body range: " << rangeStr;

    QAxObject *range =
        worksheet->querySubObject("Range(const QString&)", rangeStr);

    // 取得 view 中每个单元格
    QList<QList<QVariant>> rows;
    for (int i = 0; i < rowCount; i++) {
      QVariantList oneRow;
      for (int j = 0; j < colCount; j++) {
        QModelIndex index = tableView->model()->index(i, j);
        QVariant v = tableView->model()->data(index);
        oneRow << v;
      }
      rows << oneRow;
    }

    // 组装成一个 QVariant
    QVariantList tmp;
    for (int i = 0; i < rows.size(); i++) {
      tmp.append(QVariant(rows[i]));
    }
    QVariant var(tmp);

    range->setProperty("Value", var);

    workbook->dynamicCall("SaveAs(const QString&)",
                          QDir::toNativeSeparators(fileName));
    //保存至filepath，注意一定要用QDir::toNativeSeparators将路径中的"/"转换为"\"，不然一定保存不了。

    workbook->dynamicCall("Close(Boolean)", false); //关闭文件
    delete range;
    delete rangeH;
    delete worksheet;
    delete workbook;

    return true;
  } else {
    return false;
  };
}

// 传入数字序号，返回字符列名
// zz （大概 255） 个字段以内
QString ExcelApp::calcColName(int col) {
  int a = col / 26;
  int b = col % 26;

  if (b == 0) {
    b = 26;
    a = a - 1;
  }

  QString rtn;
  if (a > 0) {
    rtn = mapToName(a) + mapToName(b);
  } else {
    rtn = mapToName(b);
  }

  return rtn;
}

// 单个字符的转换
QString ExcelApp::mapToName(int col) {
  QChar ch = col + 0x40; // A对应0x41
  return QString(ch);
}

void ExcelApp::initExcel() {
  // 初始化 excel
  if (m_xls.isNull()) {
    QElapsedTimer timer;
    timer.start();

    m_xls.reset(new QAxObject);
    m_xls->setControl("Excel.Application");
    m_xls->setProperty("Visible", false);
    m_xls->setProperty("DisplayAlerts", false);

    m_workbooks.reset(m_xls->querySubObject("WorkBooks"));
    qDebug() << timer.elapsed() << " Finished setup Excel.";
  }
}

void ExcelApp::quitExcel() {
  if (!m_xls.isNull()) {
    m_xls->dynamicCall("Quit()");
  }
}



=== fimonthtask.cpp 
﻿#include "fimonthtask.h"

#include "excelapp.h"
#include "global.h"
#include <QtWidgets>
#include <Qtsql>

FIMonthTask::FIMonthTask(QWidget *parent) : QWidget(parent) {
  prepareUI();
  connect(&watch, SIGNAL(finished()), this, SLOT(postExecSP()));
}

void FIMonthTask::prepareUI() {
  btnRepairVou = new QPushButton(tr("修复不能记账"));

  connect(btnRepairVou, &QPushButton::clicked, this,
          &FIMonthTask::btnRepairVouClicked);

  results = new QTextEdit;
  results->append(tr("确保你知道你在做什么！"));

  QVBoxLayout *vMain = new QVBoxLayout;

  vMain->addWidget(btnRepairVou);

  vMain->addWidget(results);
  setLayout(vMain);

  resize(300, 400);

  setWindowTitle(tr("结账"));

  Qt::WindowFlags flags = windowFlags() & ~Qt::WindowMinMaxButtonsHint;
  setWindowFlags(flags);
}

void FIMonthTask::btnRepairVouClicked() {
  QString sqlCmd = "exec IA_SP_WriteUnAccountVouchForST Null,'11' ";
  qDebug() << "cmd: " << sqlCmd;

  QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));
  btnRepairVou->setEnabled(false);

  QFuture<void> future =
      QtConcurrent::run([this, sqlCmd]() { execSP(sqlCmd); });

  watch.setFuture(future);
}

void FIMonthTask::execSP(const QString &sqlCmd) {
  QSqlDatabase db = QSqlDatabase::database(CONN_SRC);
  QSqlQuery query(db);
  query.setForwardOnly(true);
  query.prepare(sqlCmd);

  bool ok = query.exec();

  if (!ok) {
    QSqlError error = db.lastError();
    qDebug() << "Filed: btnRepairVouClicked "
             << QString("err: %1").arg(error.text());
    return;
  }
}

void FIMonthTask::postExecSP() {
  btnRepairVou->setEnabled(true);
  QApplication::restoreOverrideCursor();

  QMessageBox::information(this, tr(""), tr("执行完毕"));
}

#include "moc_fimonthtask.cpp"



=== freezetablewidget.cpp 
﻿/****************************************************************************
**
** Copyright (C) 2016 The Qt Company Ltd.
** Contact: https://www.qt.io/licensing/
**
** This file is part of the examples of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:BSD$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and The Qt Company. For licensing terms
** and conditions see https://www.qt.io/terms-conditions. For further
** information use the contact form at https://www.qt.io/contact-us.
**
** BSD License Usage
** Alternatively, you may use this file under the terms of the BSD license
** as follows:
**
** "Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions are
** met:
**   * Redistributions of source code must retain the above copyright
**     notice, this list of conditions and the following disclaimer.
**   * Redistributions in binary form must reproduce the above copyright
**     notice, this list of conditions and the following disclaimer in
**     the documentation and/or other materials provided with the
**     distribution.
**   * Neither the name of The Qt Company Ltd nor the names of its
**     contributors may be used to endorse or promote products derived
**     from this software without specific prior written permission.
**
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
**
** $QT_END_LICENSE$
**
****************************************************************************/

#include "freezetablewidget.h"

#include <QHeaderView>
#include <QScrollBar>

//! [constructor]
FreezeTableWidget::FreezeTableWidget(QAbstractItemModel *model) {
  frozenTableView = new QTableView(this);

  setModel(model);
  init();

  // connect the headers and scrollbars of both tableviews together
  connect(horizontalHeader(), &QHeaderView::sectionResized, this,
          &FreezeTableWidget::updateSectionWidth);
  connect(verticalHeader(), &QHeaderView::sectionResized, this,
          &FreezeTableWidget::updateSectionHeight);

  connect(frozenTableView->verticalScrollBar(), &QAbstractSlider::valueChanged,
          verticalScrollBar(), &QAbstractSlider::setValue);
  connect(verticalScrollBar(), &QAbstractSlider::valueChanged,
          frozenTableView->verticalScrollBar(), &QAbstractSlider::setValue);
}
//! [constructor]

FreezeTableWidget::~FreezeTableWidget() {
  qDebug() << "deleted.";

  delete frozenTableView;
}

//! [init part1]
void FreezeTableWidget::init() {
  frozenTableView->setModel(model());
  frozenTableView->setFocusPolicy(Qt::NoFocus);
  frozenTableView->verticalHeader()->hide();
  frozenTableView->horizontalHeader()->setSectionResizeMode(QHeaderView::Fixed);

  viewport()->stackUnder(frozenTableView);
  //! [init part1]

  //! [init part2]
  //  frozenTableView->setStyleSheet(
  //      "QTableView { border: none;"
  //      "background-color: #8EDE21;"
  //      "selection-background-color: #999}"); // for demo purposes
  frozenTableView->setSelectionModel(selectionModel());

  // 隐藏 column
  for (int col = hiddenFrom; col < model()->columnCount(); ++col) {
    frozenTableView->setColumnHidden(col, true);
  }

  for (int col = 0; col < hiddenFrom; col++) {
    frozenTableView->setColumnWidth(col, columnWidth(col));
  }

  frozenTableView->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
  frozenTableView->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
  frozenTableView->show();

  updateFrozenTableGeometry();

  setHorizontalScrollMode(ScrollPerPixel);
  setVerticalScrollMode(ScrollPerPixel);
  frozenTableView->setVerticalScrollMode(ScrollPerPixel);
}
//! [init part2]

//! [sections]
void FreezeTableWidget::updateSectionWidth(int logicalIndex, int /* oldSize */,
                                           int newSize) {
  if (logicalIndex <= hiddenFrom) {
    frozenTableView->setColumnWidth(logicalIndex, newSize);
    updateFrozenTableGeometry();
  }
}

void FreezeTableWidget::updateSectionHeight(int logicalIndex, int /* oldSize */,
                                            int newSize) {
  frozenTableView->setRowHeight(logicalIndex, newSize);
}
//! [sections]

//! [resize]
void FreezeTableWidget::resizeEvent(QResizeEvent *event) {
  QTableView::resizeEvent(event);
  updateFrozenTableGeometry();
}
//! [resize]

//! [navigate]
QModelIndex FreezeTableWidget::moveCursor(CursorAction cursorAction,
                                          Qt::KeyboardModifiers modifiers) {
  QModelIndex current = QTableView::moveCursor(cursorAction, modifiers);

  if (cursorAction == MoveLeft && current.column() > 0 &&
      visualRect(current).topLeft().x() < frozenTableView->columnWidth(0)) {
    const int newValue = horizontalScrollBar()->value() +
                         visualRect(current).topLeft().x() -
                         getHiddenWidth(frozenTableView);
    horizontalScrollBar()->setValue(newValue);
  }
  return current;
}
//! [navigate]

void FreezeTableWidget::scrollTo(const QModelIndex &index, ScrollHint hint) {
  if (index.column() > 0)
    QTableView::scrollTo(index, hint);
}

//! [geometry]
void FreezeTableWidget::updateFrozenTableGeometry() {
  frozenTableView->setGeometry(verticalHeader()->width() + frameWidth(),
                               frameWidth(), getHiddenWidth(this),
                               viewport()->height() +
                                   horizontalHeader()->height());
}

int FreezeTableWidget::getHiddenWidth(QTableView *view) {
  // 取得隐藏列的宽度
  int total = 0;
  for (int i = 0; i < hiddenFrom; i++) {
    total += view->columnWidth(i);
  }
  return total;
}

void FreezeTableWidget::resetModel(QAbstractItemModel *model, int hiddenFrom) {
  this->hiddenFrom = hiddenFrom;
  setModel(model);
  init();
}
//! [geometry]

#include "moc_freezetablewidget.cpp"



=== global.cpp 



=== invclasswnd.cpp 
﻿#include "invclasswnd.h"

#include "cursorguard.h"
#include "excelapp.h"
#include "global.h"
#include <QAxObject>
#include <QtSql>
#include <QtWidgets>

InvClassWnd::InvClassWnd(QWidget *parent) : QWidget(parent) {
  prepareUI();
  connect(&watch, SIGNAL(finished()), this, SLOT(postFetchItems()));

  // 更新后的回调函数
  connect(&watchUpload, SIGNAL(finished()), this, SLOT(postUpload()));

  showMaximized();
}

void InvClassWnd::prepareUI() {
  QWidget *w = createTab1();
  QVBoxLayout *vBox = new QVBoxLayout;
  vBox->addWidget(w);
  setLayout(vBox);

  setWindowTitle(tr("存货分类"));
}

// 工时统计
QWidget *InvClassWnd::createTab1() {
  //  QLabel *lfrom = new QLabel(tr("开始日期"));
  //  lfrom->setAlignment(Qt::AlignRight | Qt::AlignCenter);
  //  QLabel *lto = new QLabel(tr("结束日期"));
  //  lto->setAlignment(Qt::AlignRight | Qt::AlignCenter);

  //  // 默认之前一个星期；
  //  QDate t1, t2;
  //  t2 = QDate::currentDate();
  //  t1 = t2.addDays(-7);

  //  dteFrom = new QDateTimeEdit(t1);
  //  dteFrom->setCalendarPopup(true);
  //  dteFrom->setDisplayFormat(dateFormat);

  //  dteTo = new QDateTimeEdit(t2);
  //  dteTo->setCalendarPopup(true);
  //  dteTo->setDisplayFormat(dateFormat);

  btnSearch = new QPushButton(tr("查找"));
  btnUpload = new QPushButton(tr("导入"));
  btnExport = new QPushButton(tr("导出"));

  connect(btnSearch, &QPushButton::clicked, this,
          &InvClassWnd::btnSearchClicked);

  connect(btnUpload, &QPushButton::clicked, this, &InvClassWnd::uploadItems);

  connect(btnExport, &QPushButton::clicked,
          [this]() { exportTableView(tvPP); });

  QHBoxLayout *hlayout = new QHBoxLayout;
  //  hlayout->addWidget(lfrom);
  //  hlayout->addWidget(dteFrom);
  //  hlayout->addWidget(lto);
  //  hlayout->addWidget(dteTo);
  hlayout->addWidget(btnSearch);
  hlayout->addWidget(btnUpload);
  hlayout->addWidget(btnExport);

  tvPP = new QTableView;
  tvPP->setStyleSheet("font: 8pt 微软雅黑;");
  ppModel = new QStandardItemModel;

  // 形成 model: 标题
  QStringList headers;
  headers << "分类编码"
          << "分类名称"
          << "MC Code";
  ppModel->setHorizontalHeaderLabels(headers);
  tvPP->setModel(ppModel);

  QVBoxLayout *vBox = new QVBoxLayout;
  vBox->addLayout(hlayout);
  vBox->addWidget(tvPP);

  QWidget *w = new QWidget;
  w->setLayout(vBox);

  return w;
}

void InvClassWnd::exportTableView(QTableView *view) {
  QString fileName = QFileDialog::getSaveFileName(
      this, "保存",
      QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation),
      "Excel 文件(*.xlsx)");

  if (fileName != "") {
    bool ok = ExcelApp::instance()->exportTableView(view, fileName);
    if (ok) {
      QMessageBox::information(this, tr("导出"), tr("导出完毕"));
    }
  }
}

void InvClassWnd::btnSearchClicked() {
  // 从 UI 取得用户输入的查询条件；
  QString sqlCmd = "select INV_CLASS, INV_CLASS_NME, MC_CDE from T_INV_CLASS";

  qDebug() << "cmd: " << sqlCmd;

  QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));
  setAllBtnStatus(false);

  QFuture<void> future =
      QtConcurrent::run([this, sqlCmd]() { fetchItems(sqlCmd); });

  watch.setFuture(future);
}

void InvClassWnd::fetchItems(const QString &sqlCmd) {
  QSqlDatabase db = QSqlDatabase::database(CONN_TARGET);
  QSqlQuery query(db);
  query.setForwardOnly(true);
  query.prepare(sqlCmd);

  bool ok = query.exec();

  if (!ok) {
    QSqlError error = db.lastError();
    qDebug() << "Filed: btnSearchClicked "
             << QString("err: %1").arg(error.text());
    return;
  }

  allItems.clear();
  while (query.next()) {
    QStringList item;

    // 不同列的处理
    for (int c = 0; c <= colCnt; c++) {
      // 字符类型
      item.push_back(query.value(c).toString());
    }

    allItems.push_back(item);
  }
}

void InvClassWnd::postFetchItems() {
  QStandardItemModel *model = ppModel;
  QTableView *tableView = tvPP;

  tableView->setUpdatesEnabled(false);

  // 把结果集，显示在tableview 中；
  // 结果集中都是字符；
  model->removeRows(0, model->rowCount());
  int row = 0;
  for (const auto &it : allItems) {
    for (int c = 0; c <= colCnt; c++) {
      model->setItem(row, c, new QStandardItem(it.at(c)));
    }

    row++;
  }

  tableView->resizeColumnsToContents();
  tableView->setUpdatesEnabled(true);

  setAllBtnStatus(true);
  QApplication::restoreOverrideCursor();

  QMessageBox::information(this, tr(""), tr("执行完毕"));
}

void InvClassWnd::setAllBtnStatus(bool enabled) {
  // 点击 更新 后，所有 btn 都 disable 掉
  btnUpload->setEnabled(enabled);
  btnSearch->setEnabled(enabled);
  btnExport->setEnabled(enabled);
}

std::vector<InvClass> InvClassWnd::loadItems() {
  std::vector<InvClass> items;

  QString fileName = QFileDialog::getOpenFileName(this, QString(), QString(),
                                                  "excel(*.xls *.xlsx)");
  if (fileName.isEmpty()) {
    return items;
  }

  CursorGuard cg;

  qDebug() << "reading:" << fileName;

  QElapsedTimer timer;
  timer.start();

  QAxObject *pWorkbooks = ExcelApp::instance()->getWorkbooks();

  QAxObject *workbook =
      pWorkbooks->querySubObject("Open (const QString &)", fileName);

  // 读取 sheet1 的内容
  QAxObject *worksheets = workbook->querySubObject("WorkSheets");
  QAxObject *worksheet = worksheets->querySubObject("Item(int)", 1);

  qDebug() << timer.elapsed() << " Open excel sheet1. ";

  // 从第二行开始，最多 300 行
  //  timer.restart();
  QString dataRange = "A2:C300";
  QAxObject *range = worksheet->querySubObject("Range(QString)", dataRange);
  QVariant excel_data = range->dynamicCall("Value()");
  qDebug() << timer.elapsed() << " read range.";

  // 取得读到的所有行
  QVariantList rows = excel_data.toList();

  int rowCount = rows.count();
  qDebug() << timer.elapsed() << "total rows: " << rowCount;

  if (rowCount == 0) {
    qDebug() << "no data. ";
    return items;
  }

  QVariantList row;
  for (int i = 0; i < rowCount; i++) {
    row = rows[i].toList();

    QString firstCol = row[0].toString().trimmed();

    // 第一列：存货分类代码；
    // 为空，表示结束
    if (firstCol.length() == 0) {
      qDebug() << "The last: " << i;
      break;
    }

    InvClass item;
    item.invClass = firstCol;

    // 第二列：存货分类名称，
    // 第三列：MC Code
    item.className = row[1].toString().trimmed();
    item.mcCode = row[2].toString().trimmed();

    items.push_back(item);
  }

  // 关闭 excel 文件；
  workbook->dynamicCall("Close(Boolean)", false);

  return items;
}

void InvClassWnd::uploadItems() {
  std::vector<InvClass> items = loadItems();

  if (items.size() > 0) {
    // 提示：将被全量替换；
    if (!checkHistory()) {
      return;
    }

    // 更新前，disable 所有的 btn
    setAllBtnStatus(false);

    QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));

    // 执行更新
    QFuture<void> future =
        QtConcurrent::run([this, items]() { uploadItemsDo(items); });

    watch.setFuture(future);
  }
}

void InvClassWnd::uploadItemsDo(const std::vector<InvClass> &items) {
  // 把 items 中的每个元素，插入表中；
  QString cmd = "insert T_INV_CLASS (INV_CLASS, INV_CLASS_NME, MC_CDE) "
                " values "
                " (:INV_CLASS, :INV_CLASS_NME, :MC_CDE); ";

  qDebug() << "cmd: " << cmd;

  QSqlDatabase db = QSqlDatabase::database(CONN_TARGET);
  QSqlQuery query(db);
  query.prepare(cmd);

  bool ok;
  for (auto const &i : items) {
    query.bindValue(":INV_CLASS", i.invClass);
    query.bindValue(":INV_CLASS_NME", i.className);
    query.bindValue(":MC_CDE", i.mcCode);

    ok = query.exec();
    if (!ok) {
      QSqlError error = db.lastError();
      qDebug() << QString("Failed: %1").arg(error.text());
      return;
    }
  }
}

bool InvClassWnd::checkHistory() {
  // 中每一个，删除已有数据；
  QString m = QString("本次数据将覆盖之前数据");
  QMessageBox msgBox;
  msgBox.setText(m);
  msgBox.setInformativeText(tr("本次数据将覆盖之前数据，是否继续？"));
  msgBox.setStandardButtons(QMessageBox::Ok | QMessageBox::Cancel);
  msgBox.setDefaultButton(QMessageBox::Cancel);
  int ret = msgBox.exec();

  if (ret == QMessageBox::Cancel) {
    return false;
  }

  deleteHistory();
  return true;
}

void InvClassWnd::deleteHistory() {
  // 全部删除，每次上载都是全量数据
  QString cmd = "delete from T_INV_CLASS  ";

  qDebug() << "cmd: " << cmd;

  QSqlDatabase db = QSqlDatabase::database(CONN_TARGET);
  QSqlQuery query(db);
  query.prepare(cmd);

  bool ok;

  ok = query.exec();
  if (!ok) {
    QSqlError error = db.lastError();
    qDebug() << QString("Failed: %1").arg(error.text());
    return;
  }
}

void InvClassWnd::postUpload() {
  // 更新完毕后的回调函数；
  setAllBtnStatus(true);

  QApplication::restoreOverrideCursor();
  QMessageBox::information(this, tr("存货分类"), tr("导入完成"));
}

#include "moc_invclasswnd.cpp"



=== invdetailwnd.cpp 
﻿#include "invdetailwnd.h"

#include "excelapp.h"
#include "global.h"
#include <QtWidgets>
#include <Qtsql>

InvDetailWnd::InvDetailWnd(QWidget *parent) : QWidget(parent) {
  prepareUI();
  connect(&watch, SIGNAL(finished()), this, SLOT(postFetchItems()));
  showMaximized();
}

void InvDetailWnd::prepareUI() {
  QWidget *w = createTab1();
  QVBoxLayout *vBox = new QVBoxLayout;
  vBox->addWidget(w);
  setLayout(vBox);

  setWindowTitle(tr("存货档案"));
}

// 查询物料主数据
QWidget *InvDetailWnd::createTab1() {
  QLabel *linv = new QLabel(tr("物料"));
  linv->setAlignment(Qt::AlignRight | Qt::AlignCenter);
  QLabel *linvClass = new QLabel(tr("物料类型"));
  linvClass->setAlignment(Qt::AlignRight | Qt::AlignCenter);

  leInv = new QLineEdit;
  leInvClass = new QLineEdit;

  btnPPSearch = new QPushButton(tr("查找"));
  QPushButton *btnPPExport = new QPushButton(tr("导出"));

  connect(btnPPSearch, &QPushButton::clicked, this,
          &InvDetailWnd::btnPPSearchClicked);

  connect(btnPPExport, &QPushButton::clicked,
          [this]() { exportTableView(tvPP); });

  QHBoxLayout *hlayout = new QHBoxLayout;
  hlayout->addWidget(linv);
  hlayout->addWidget(leInv);
  hlayout->addWidget(linvClass);
  hlayout->addWidget(leInvClass);
  hlayout->addWidget(btnPPSearch);
  hlayout->addWidget(btnPPExport);

  tvPP = new QTableView;
  tvPP->setStyleSheet("font: 8pt 微软雅黑;");
  ppModel = new QStandardItemModel;

  // 形成 model: 标题
  QStringList headers;
  headers << "存货分类"
          << "分类名称"
          << "MC Code"
          << "存货编码"
          << "存货名称"
          << "代码"
          << "规格"
          << "内销"
          << "外购"
          << "自制"
          << "委外"
          << "MoQ"
          << "L/T"
          << "图纸号"
          << "物料版本"
          << "BOM版本"
          << "保质期";
  this->colCnt = headers.length() - 1;

  ppModel->setHorizontalHeaderLabels(headers);
  tvPP->setModel(ppModel);

  QVBoxLayout *vBox = new QVBoxLayout;
  vBox->addLayout(hlayout);
  vBox->addWidget(tvPP);

  QWidget *w = new QWidget;
  w->setLayout(vBox);

  return w;
}

void InvDetailWnd::exportTableView(QTableView *view) {
  QString fileName = QFileDialog::getSaveFileName(
      this, "保存",
      QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation),
      "Excel 文件(*.xlsx)");

  if (fileName != "") {
    bool ok = ExcelApp::instance()->exportTableView(view, fileName);
    if (ok) {
      QMessageBox::information(this, tr("导出"), tr("导出完毕"));
    }
  }
}

void InvDetailWnd::btnPPSearchClicked() {
  // 从 UI 取得用户输入的查询条件；
  QString inv = leInv->text().trimmed();
  QString invClass = leInvClass->text().trimmed();

  // 和 sql 对应
  QStringList condList;

  // 物料
  if (inv.length() > 0) {
    condList.append(
        QString(" and (i.cInvCode like '%%1%' or i.cInvName like '%%1%') ")
            .arg(inv));
  }

  // 物料分类
  if (invClass.length() > 0) {
    condList.append(
        QString(
            " and (c.INV_CLASS like '%%1%' or c.INV_CLASS_NME like '%%1%') ")
            .arg(invClass));
  }

  QString cond = condList.join(" ");
  QString sqlTemplate = loadSqlCmd("10.sql");
  QString sqlCmd = sqlTemplate.arg(cond);

  qDebug() << "temp: " << sqlTemplate << "\ncmd: " << sqlCmd;

  QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));
  btnPPSearch->setEnabled(false);

  QFuture<void> future =
      QtConcurrent::run([this, sqlCmd]() { fetchItems(sqlCmd); });

  watch.setFuture(future);
}

void InvDetailWnd::fetchItems(const QString &sqlCmd) {
  QSqlDatabase db = QSqlDatabase::database(CONN_SRC);
  QSqlQuery query(db);
  query.setForwardOnly(true);
  query.prepare(sqlCmd);

  bool ok = query.exec();

  if (!ok) {
    QSqlError error = db.lastError();
    qDebug() << "Filed: btnPPSearchClicked "
             << QString("err: %1").arg(error.text());
    return;
  }

  allItems.clear();
  while (query.next()) {
    QStringList item;

    // 不同列的处理
    for (int c = 0; c <= colCnt; c++) {
      // 字符类型
      item.push_back(query.value(c).toString());
    }
    allItems.push_back(item);
  }
}

void InvDetailWnd::postFetchItems() {
  QStandardItemModel *model = ppModel;
  QTableView *tableView = tvPP;

  tableView->setUpdatesEnabled(false);

  // 把结果集，显示在tableview 中；
  // 结果集中都是字符；
  model->removeRows(0, model->rowCount());
  int row = 0;
  for (const auto &it : allItems) {
    for (int c = 0; c <= colCnt; c++) {
      model->setItem(row, c, new QStandardItem(it.at(c)));
    }

    row++;
  }

  tableView->resizeColumnsToContents();
  tableView->setUpdatesEnabled(true);

  btnPPSearch->setEnabled(true);
  QApplication::restoreOverrideCursor();

  QMessageBox::information(this, tr(""), tr("执行完毕"));
}

#include "moc_invdetailwnd.cpp"



=== invmainwnd.cpp 
﻿#include "invmainwnd.h"

#include "invclasswnd.h"
#include "invdetailwnd.h"

InvMainWnd::InvMainWnd(QWidget *parent) : QWidget(parent) {
  prepareUI();
  showMaximized();
}

void InvMainWnd::prepareUI() {
  tabs = new QTabWidget;

  tabs->addTab(createTab1(), tr("存货档案"));
  tabs->addTab(createTab2(), tr("存货分类"));

  QVBoxLayout *vBox = new QVBoxLayout;
  vBox->addWidget(tabs);
  setLayout(vBox);

  setWindowTitle(tr("存货档案"));
}

QWidget *InvMainWnd::createTab1() { return new InvDetailWnd; }

QWidget *InvMainWnd::createTab2() { return new InvClassWnd; }

#include "moc_invmainwnd.cpp"



=== main.cpp 



=== mainwindow.cpp 
﻿#include "mainwindow.h"
#include "ui_mainwindow.h"

#include "availabilitycheckwnd.h"
#include "bomexplorerwnd.h"
#include "etlwnd.h"
#include "monthlyplanwnd.h"
#include "soitemrdswnd.h"

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent), ui(new Ui::MainWindow) {
  ui->setupUi(this);

  initMenu();

  // 中心：stackwidget
  // 左边：操作栏，dock，其中包含一个 listwidget
  initCentralArea();

  //  initLeftDock();

  setWindowTitle(tr("计划体系"));
  statusBar()->hide();
}

MainWindow::~MainWindow() { delete ui; }

void MainWindow::initMenu() {
  QAction *showMonthPlan = new QAction(tr("月度计划"), 0);
  QAction *showDeliveryPlan = new QAction(tr("发货计划"),0);
  QAction *showLeftDock = new QAction(tr("操作栏"),0);
  QAction *showETLPannel = new QAction(tr("ETL"),0);

  QAction *showBOM = new QAction(tr("BOM"),0);

  QAction *showAvlChkWnd = new QAction(tr("可用性检查"),0);

  connect(showMonthPlan, &QAction::triggered, this,
          [this]() { this->stackWidget->setCurrentIndex(0); });

  connect(showDeliveryPlan, &QAction::triggered, this,
          [this]() { this->stackWidget->setCurrentIndex(1); });

  connect(showETLPannel, &QAction::triggered, this, &MainWindow::showETLWnd);

  connect(showLeftDock, &QAction::triggered, this,
          [this]() { this->leftDock->show(); });

  connect(showBOM, &QAction::triggered, this, [this]() { this->showBOM(); });

  connect(showAvlChkWnd, &QAction::triggered, this,
          &MainWindow::showAvlCheckWnd);

  QMenuBar *menuBar = this->menuBar();
  QMenu *opMenu = menuBar->addMenu(tr("操作"));
  opMenu->addAction(showMonthPlan);
  opMenu->addAction(showDeliveryPlan);
  //  opMenu->addAction(showLeftDock);
  //  opMenu->addAction(showETLPannel);
  opMenu->addAction(showBOM);
  opMenu->addAction(showAvlChkWnd);
}

void MainWindow::initCentralArea() {
  monthlyPlanWnd = new MonthlyPlanWnd();
  deliveryPlanWnd = new SoItemRdsWnd;
  dbETLWnd = new ETLWnd;

  stackWidget = new QStackedWidget;

  stackWidget->addWidget(monthlyPlanWnd);
  stackWidget->addWidget(deliveryPlanWnd);
  stackWidget->addWidget(dbETLWnd);

  setCentralWidget(stackWidget);
}

void MainWindow::showETLWnd() {
  // 每次只有输入正确的口令，才能显示 ETL
  // 暂且 hardcode
  const QString password = "zaq12wsx";
  bool ok;
  QString text = QInputDialog::getText(this, tr("DJPlan"), tr("口令"),
                                       QLineEdit::Password, tr("password"), &ok)
                     .trimmed();

  if (ok && !text.isEmpty()) {
    if (text.compare(password) == 0) {
      this->stackWidget->setCurrentIndex(2);
    } else {
      QMessageBox::information(this, tr("DJPlan"), tr("口令错误"));
    }
  }
}

void MainWindow::initLeftDock() {
  // 创建左边的 dock，内部是一个 listwidget
  leftDock = new QDockWidget(tr("Action"), this);
  leftDock->setAllowedAreas(Qt::LeftDockWidgetArea);

  actionList = new QListWidget(leftDock);
  actionList->setViewMode(QListView::IconMode);
  actionList->setIconSize(QSize(64, 64));
  actionList->setMovement(QListView::Static);
  actionList->setMaximumWidth(256);
  actionList->setSpacing(12);

  leftDock->setWidget(actionList);
  addDockWidget(Qt::LeftDockWidgetArea, leftDock);

  // 创建 listitem
  QListWidgetItem *liForcast = new QListWidgetItem(actionList);
  liForcast->setIcon(QIcon(":/images/config.png"));
  liForcast->setText(tr("销售预测"));
  liForcast->setTextAlignment(Qt::AlignHCenter);
  liForcast->setFlags(Qt::ItemIsSelectable | Qt::ItemIsEnabled);
  liForcast->setSizeHint(QSize(256, 150));

  QListWidgetItem *liDelivery = new QListWidgetItem(actionList);
  liDelivery->setIcon(QIcon(":/images/update.png"));
  liDelivery->setText(tr("发货计划"));
  liDelivery->setTextAlignment(Qt::AlignHCenter);
  liDelivery->setFlags(Qt::ItemIsSelectable | Qt::ItemIsEnabled);
  liDelivery->setSizeHint(QSize(256, 150));

  // 绑定事件处理函数
  connect(actionList, &QListWidget::currentItemChanged, this,
          &MainWindow::changePage);
}

// listwidget 中的当前 index 和 stackwidget 中的当前 index 保持一致
void MainWindow::changePage(QListWidgetItem *current,
                            QListWidgetItem *previous) {

  Q_UNUSED(previous);

  int index = actionList->row(current);
  stackWidget->setCurrentIndex(index);
}

void MainWindow::showBOM() {
  if (!bomWnd) {
    bomWnd = new BOMExplorerWnd;
  }

  bomWnd->show();
}

void MainWindow::showAvlCheckWnd() {
  if (!avlChkWnd) {
    avlChkWnd = new AvailabilityCheckWnd;
  }

  avlChkWnd->show();
}

#include "moc_mainwindow.cpp"



=== matstockoutwnd.cpp 
﻿#include "matstockoutwnd.h"

#include "excelapp.h"
#include "global.h"
#include <QtWidgets>
#include <Qtsql>

MatStockOutWnd::MatStockOutWnd(QWidget *parent) : QWidget(parent) {
  prepareUI();
  connect(&watch, SIGNAL(finished()), this, SLOT(postFetchItems()));
  showMaximized();
}

void MatStockOutWnd::prepareUI() {
  QVBoxLayout *vBox = new QVBoxLayout;
  vBox->addWidget(createResultWidget());
  setLayout(vBox);

  setWindowTitle(tr("数据导出"));
}

QWidget *MatStockOutWnd::createResultWidget() {
  QLabel *lfrom = new QLabel(tr("开始日期"));
  lfrom->setAlignment(Qt::AlignRight | Qt::AlignCenter);
  QLabel *lto = new QLabel(tr("结束日期"));
  lto->setAlignment(Qt::AlignRight | Qt::AlignCenter);

  // 默认之前一个星期；
  QDate t1, t2;
  t2 = QDate::currentDate();
  t1 = t2.addDays(-7);

  dtePPFrom = new QDateTimeEdit(t1);
  dtePPFrom->setCalendarPopup(true);
  dtePPFrom->setDisplayFormat(dateFormat);

  dtePPTo = new QDateTimeEdit(t2);
  dtePPTo->setCalendarPopup(true);
  dtePPTo->setDisplayFormat(dateFormat);

  QLabel *lblInv = new QLabel(tr("物料"));
  lblInv->setAlignment(Qt::AlignRight | Qt::AlignCenter);
  QLabel *lblItem = new QLabel(tr("项目号"));
  lblItem->setAlignment(Qt::AlignRight | Qt::AlignCenter);
  lePPInv = new QLineEdit;
  lePPItem = new QLineEdit;

  btnPPSearch = new QPushButton(tr("查找"));
  QPushButton *btnPPExport = new QPushButton(tr("导出"));

  connect(btnPPSearch, &QPushButton::clicked, this,
          &MatStockOutWnd::btnSearchClicked);

  connect(btnPPExport, &QPushButton::clicked,
          [this]() { exportTableView(tvPP); });

  QHBoxLayout *hlayout = new QHBoxLayout;
  hlayout->addWidget(lfrom);
  hlayout->addWidget(dtePPFrom);
  hlayout->addWidget(lto);
  hlayout->addWidget(dtePPTo);
  hlayout->addWidget(lblInv);
  hlayout->addWidget(lePPInv);
  hlayout->addWidget(lblItem);
  hlayout->addWidget(lePPItem);
  hlayout->addWidget(btnPPSearch);
  hlayout->addWidget(btnPPExport);

  tvPP = new QTableView;
  tvPP->setStyleSheet("font: 8pt 微软雅黑;");
  ppModel = new QStandardItemModel;

  // 形成 model: 标题
  QStringList headers;
  headers << "记账人"
          << "仓库编码"
          << "仓库"
          << "出库日期"
          << "出库单号"
          << "出库类别编码"
          << "出库类别"
          << "部门编码"
          << "部门"
          << "制单人"
          << "审核人"
          << "备注"
          << "项目编码"
          << "项目"
          << "存货编码"
          << "存货名称"
          << "规格型号"
          << "主计量单位"
          << "数量"
          << "单价"
          << "金额"
          << "订单号"
          << "供应商编码"
          << "供应商名称";
  colCnt = headers.length() - 1;

  ppModel->setHorizontalHeaderLabels(headers);
  tvPP->setModel(ppModel);

  QVBoxLayout *vBox = new QVBoxLayout;
  vBox->addLayout(hlayout);
  vBox->addWidget(tvPP);

  QWidget *w = new QWidget;
  w->setLayout(vBox);

  return w;
}

void MatStockOutWnd::exportTableView(QTableView *view) {
  QString fileName = QFileDialog::getSaveFileName(
      this, "保存",
      QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation),
      "Excel 文件(*.xlsx)");

  if (fileName != "") {
    bool ok = ExcelApp::instance()->exportTableView(view, fileName);
    if (ok) {
      QMessageBox::information(this, tr("导出"), tr("导出完毕"));
    }
  }
}

void MatStockOutWnd::btnSearchClicked() {
  // 从 UI 取得用户输入的查询条件；
  QString dteFrom = dtePPFrom->date().toString(dateFormat);
  QString dteTo = dtePPTo->date().toString(dateFormat);

  QString invName = lePPInv->text().trimmed();
  QString itemName = lePPItem->text().trimmed();

  // 和 sql 对应
  QStringList condList;

  // 出库时间
  condList.append(
      QString(" and (dDate >= '%1' and dDate < '%2')").arg(dteFrom, dteTo));

  // 物料号
  QString cond2 = "";
  if (invName.length() > 0) {
    condList.append(
        QString(" and (c.cInvCode like '%%1%' or cInvName like '%%1%')")
            .arg(invName));
  }

  // 项目号
  QString cond3 = "";
  if (itemName.length() > 0) {
    condList.append(QString(" and (cItemCode = '%1') ").arg(itemName));
  }

  QString cond = condList.join(" ");
  QString sqlTemplate = loadSqlCmd("13.sql");
  QString sqlCmd = sqlTemplate.arg(cond);

  qDebug() << "temp: " << sqlTemplate << "\ncmd: " << sqlCmd;

  QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));
  btnPPSearch->setEnabled(false);

  QFuture<void> future =
      QtConcurrent::run([this, sqlCmd]() { fetchItems(sqlCmd); });

  watch.setFuture(future);
}

void MatStockOutWnd::fetchItems(const QString &sqlCmd) {
  QSqlDatabase db = QSqlDatabase::database(CONN_SRC);
  QSqlQuery query(db);
  query.setForwardOnly(true);
  query.prepare(sqlCmd);

  bool ok = query.exec();

  if (!ok) {
    QSqlError error = db.lastError();
    qDebug() << "Filed: btnSearchClicked "
             << QString("err: %1").arg(error.text());
    return;
  }

  allItems.clear();
  while (query.next()) {
    QStringList item;

    // 不同列的处理
    for (int c = 0; c <= colCnt; c++) {
      if (c == 3) {
        // 日期类型
        item.push_back(query.value(c).toDate().toString(dateFormat));
      } else if (c >= 18 && c <= 20) {
        // 数字类型
        item.push_back(QString::number(query.value(c).toDouble(), 10, 4));
      } else {
        // 字符类型
        item.push_back(query.value(c).toString());
      }
    }

    allItems.push_back(item);
  }
}

void MatStockOutWnd::postFetchItems() {
  QStandardItemModel *model = ppModel;
  QTableView *tableView = tvPP;

  tableView->setUpdatesEnabled(false);

  // 把结果集，显示在tableview 中；
  // 结果集中都是字符；
  model->removeRows(0, model->rowCount());
  int row = 0;
  for (const auto &it : allItems) {
    for (int c = 0; c <= colCnt; c++) {
      model->setItem(row, c, new QStandardItem(it.at(c)));
    }

    row++;
  }

  tableView->resizeColumnsToContents();
  tableView->setUpdatesEnabled(true);

  btnPPSearch->setEnabled(true);
  QApplication::restoreOverrideCursor();

  QMessageBox::information(this, tr(""), tr("执行完毕"));
}

#include "moc_matstockoutwnd.cpp"



=== modifypricewnd.cpp 
﻿#include "modifypricewnd.h"

#include "cursorguard.h"
#include "excelapp.h"
#include "global.h"
#include <QAxObject>
#include <QtSql>

ModifyPriceWnd::ModifyPriceWnd(QWidget *parent) : QWidget(parent) {
  prepareUI();

  initRdMap();

  // 更新后的回调函数
  connect(&watchAll, SIGNAL(finished()), this, SLOT(postModify()));
}

void ModifyPriceWnd::initRdMap() {
  rdMap.insert(mvType::OTHER_IN, "08");
  rdMap.insert(mvType::OTHER_OUT, "09");
  rdMap.insert(mvType::MAT_OUT, "11");
}

void ModifyPriceWnd::prepareUI() {
  btnUpdate = new QPushButton(tr("更新价格"));

  connect(btnUpdate, &QPushButton::clicked, this,
          &ModifyPriceWnd::updateAllPrice);

  results = new QTextEdit;
  results->append(tr("修改价格前，务必核对，务必核对！保留好底稿！"));

  QVBoxLayout *vMain = new QVBoxLayout;

  vMain->addWidget(btnUpdate);

  vMain->addWidget(results);
  setLayout(vMain);

  resize(300, 400);

  setWindowTitle(tr("价格调整"));

  Qt::WindowFlags flags = windowFlags() & ~Qt::WindowMinMaxButtonsHint;
  setWindowFlags(flags);
}

void ModifyPriceWnd::setAllBtnStatus(bool enabled) {
  // 点击 更新 后，所有 btn 都 disable 掉
  btnUpdate->setEnabled(enabled);

  results->setEnabled(enabled);
}

void ModifyPriceWnd::modifyOtherMovement(
    const std::vector<PriceItem> &priceItems, ModifyPriceWnd::mvType type) {
  // 根据 type 替换成真正的 tableName
  // 其他入库单，其他出库单，材料领料单
  // 按照 （单号，料号），更新 （单价，总价）;
  std::vector<PriceItem> priceList1;
  std::vector<PriceItem> priceList2;

  // 价格为 -1 表示需要清空，设置成 null，而不是具体数值；
  for (const auto &it : priceItems) {
    if (it.price != numberNull) {
      priceList1.push_back(it);
    } else {
      priceList2.push_back(it);
    }
  }

  if (priceList1.size() > 0) {
    QString cmd = " update rdrecords%1 "
                  " set iUnitCost = :price, iPrice = iQuantity * :price "
                  " from rdrecords%1 d inner join rdrecord%1 h on  h.ID = d.ID "
                  " where 1 = 1  "
                  " and h.cCode = :orderCode"
                  " and d.cInvCode = :invCode ;";

    QString tableName = rdMap.value(type);
    cmd = cmd.arg(tableName);

    modifyDo(priceList1, cmd, false);
  }

  if (priceList2.size() > 0) {
    QString cmd = " update rdrecords%1 "
                  " set iUnitCost = null, iPrice = null "
                  " from rdrecords%1 d inner join rdrecord%1 h on  h.ID = d.ID "
                  " where 1 = 1  "
                  " and h.cCode = :orderCode"
                  " and d.cInvCode = :invCode ;";

    QString tableName = rdMap.value(type);
    cmd = cmd.arg(tableName);

    modifyDo(priceList2, cmd, true);
  }
}

void ModifyPriceWnd::modifyMoBothSide(
    const std::vector<PriceItem> &priceItems) {
  std::vector<PriceItem> priceList1;
  std::vector<PriceItem> priceList2;

  // 价格为 -1 表示需要清空，设置成 null，而不是具体数值；
  for (const auto &it : priceItems) {
    if (it.price != numberNull) {
      priceList1.push_back(it);
    } else {
      priceList2.push_back(it);
    }
  }

  if (priceList1.size() > 0) {
    // 更新调拨单本身
    QString cmdMo = " update TransVouchs "
                    " set iTVACost = :price, iTVAPrice = iTVQuantity * :price "
                    " where 1 = 1 "
                    " and cTVCode = :orderCode "
                    " and cInvCode = :invCode ";
    modifyDo(priceList1, cmdMo, false);

    // 更新调拨单对应的其他入库；注意：调拨单号字段 cBusCode，非其他入库单号
    QString cmdIn =
        " update rdrecords08 "
        " set iUnitCost = :price, iPrice = iQuantity * :price "
        " from rdrecords08 d inner join rdrecord08 h on  h.ID = d.ID "
        " and h.cSource = '调拨'  "
        " where 1 = 1  "
        " and h.cBusCode = :orderCode"
        " and d.cInvCode = :invCode ";
    modifyDo(priceList1, cmdIn, false);

    // 更新调拨单对应的其他出库；注意：调拨单号字段 cBusCode
    QString cmdOut =
        " update rdrecords09 "
        " set iUnitCost = :price, iPrice = iQuantity * :price "
        " from rdrecords09 d inner join rdrecord09 h on  h.ID = d.ID "
        " and h.cSource = '调拨'  "
        " where 1 = 1  "
        " and h.cBusCode = :orderCode"
        " and d.cInvCode = :invCode ";
    modifyDo(priceList1, cmdOut, false);
  }

  if (priceList2.size() > 0) {
    // 更新调拨单本身
    QString cmdMo = " update TransVouchs "
                    " set iTVACost = null, iTVAPrice = null "
                    " where 1 = 1 "
                    " and cTVCode = :orderCode "
                    " and cInvCode = :invCode ";
    modifyDo(priceList2, cmdMo, false);

    // 更新调拨单对应的其他入库；注意：调拨单号字段 cBusCode，非其他入库单号
    QString cmdIn =
        " update rdrecords08 "
        " set iUnitCost = null, iPrice = null "
        " from rdrecords08 d inner join rdrecord08 h on  h.ID = d.ID "
        " and h.cSource = '调拨'  "
        " where 1 = 1  "
        " and h.cBusCode = :orderCode"
        " and d.cInvCode = :invCode ";
    modifyDo(priceList2, cmdIn, false);

    // 更新调拨单对应的其他出库；注意：调拨单号字段 cBusCode
    QString cmdOut =
        " update rdrecords09 "
        " set iUnitCost = null, iPrice = null "
        " from rdrecords09 d inner join rdrecord09 h on  h.ID = d.ID "
        " and h.cSource = '调拨'  "
        " where 1 = 1  "
        " and h.cBusCode = :orderCode"
        " and d.cInvCode = :invCode ";
    modifyDo(priceList2, cmdOut, false);
  }
}

void ModifyPriceWnd::modifyPO(const std::vector<PriceItem> &priceItems) {
  std::vector<PriceItem> priceList1;
  std::vector<PriceItem> priceList2;

  // 价格为 -1 表示需要清空，设置成 null，而不是具体数值；
  for (const auto &it : priceItems) {
    if (it.price != numberNull) {
      priceList1.push_back(it);
    } else {
      priceList2.push_back(it);
    }
  }

  if (priceList1.size() > 0) {
    // 更新单价
    QString cmdPrice = " update rdrecords01 "
                       " set iUnitCost = :price, iOriCost = :price,   "
                       " iOriTaxPrice = :price * d.iTaxRate / 100, "
                       " iTaxPrice = :price * d.iTaxRate / 100 "
                       " from rdrecords01 d "
                       " inner join rdrecord01 h on  h.ID = d.ID "
                       " where 1 = 1  "
                       " and h.cBusType = '普通采购' "
                       " and h.cCode = :orderCode "
                       " and d.cInvCode = :invCode ";
    modifyDo(priceList1, cmdPrice, false);

    // 更新净额，税额, 注意 :price 是为了占位，统一赋值；
    QString cmdNet = " update rdrecords01 "
                     " set iOriCost = :price, "
                     " iPrice = iUnitCost * iQuantity,   "
                     " iAPrice = 	iUnitCost * iQuantity, "
                     " iOriMoney = iUnitCost * iQuantity, "
                     " iOriTaxCost = iUnitCost * ((100 + d.iTaxRate) / 100) "
                     " from rdrecords01 d "
                     " inner join rdrecord01 h on  h.ID = d.ID "
                     " where 1 = 1  "
                     " and h.cBusType = '普通采购' "
                     " and h.cCode = :orderCode "
                     " and d.cInvCode = :invCode ";
    modifyDo(priceList1, cmdNet, false);

    // 更新总额
    QString cmdTtl = " update rdrecords01 "
                     " set iOriCost = :price, "
                     " ioriSum = iOriMoney + iOriTaxPrice,   "
                     " iSum = iOriMoney + iOriTaxPrice "
                     " from rdrecords01 d "
                     " inner join rdrecord01 h on  h.ID = d.ID "
                     " where 1 = 1  "
                     " and h.cBusType = '普通采购' "
                     " and h.cCode = :orderCode "
                     " and d.cInvCode = :invCode ";
    modifyDo(priceList1, cmdTtl, false);
  }

  if (priceList2.size() > 0) {
    QString cmdPrice = " update rdrecords01 "
                       " set iUnitCost = null, iOriCost = null,   "
                       " iOriTaxPrice = null, "
                       " iTaxPrice = null,  "
                       " iPrice = null,   "
                       " iAPrice = null, "
                       " iOriMoney = null, "
                       " iOriTaxCost = null,  "
                       " ioriSum = null,   "
                       " iSum = null "
                       " from rdrecords01 d "
                       " inner join rdrecord01 h on  h.ID = d.ID "
                       " where 1 = 1  "
                       " and h.cBusType = '普通采购' "
                       " and h.cCode = :orderCode "
                       " and d.cInvCode = :invCode ";
    modifyDo(priceList2, cmdPrice, true);
  }
}

void ModifyPriceWnd::modifyDo(const std::vector<PriceItem> &priceItems,
                              const QString &cmd, bool setNull) {
  // 对 cmd 设置 3 个 binder: price, orderCode, invCode
  QSqlDatabase db = QSqlDatabase::database(CONN_SRC);
  QSqlQuery query(db);
  query.prepare(cmd);

  qDebug() << "cmd: " << cmd;

  bool ok = false;
  for (const auto &p : priceItems) {
    if (setNull == false) {
      query.bindValue(":price", p.price);
    }

    query.bindValue(":orderCode", p.orderCode);
    query.bindValue(":invCode", p.invCode);

    ok = query.exec();
    if (!ok) {
      QSqlError err = db.lastError();
      QString msg = QString("Failed to update: (%1, %2, %3)")
                        .arg(p.orderCode, p.invCode, QString::number(p.price));
      msgList.append(msg);
      qDebug() << msg;
    }
  }
}

void ModifyPriceWnd::postModify() {
  // 更新完毕后的回调函数；
  setAllBtnStatus(true);

  // 结果写入文本框；
  results->clear();
  for (const auto &s : msgList) {
    results->insertPlainText(s);
  }

  QApplication::restoreOverrideCursor();
  QMessageBox::information(this, tr("价格更新"), tr("更新完毕"));
}

// 从文件中读取单价信息，格式：单据类型，单号，料号，单价
std::vector<PriceItem> ModifyPriceWnd::loadAllPrice() {
  std::vector<PriceItem> priceItems;

  QString fileName = QFileDialog::getOpenFileName(this, QString(), QString(),
                                                  "excel(*.xls *.xlsx)");
  if (fileName.isEmpty()) {
    return priceItems;
  }

  //  QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));
  CursorGuard cg;

  qDebug() << "reading:" << fileName;

  QElapsedTimer timer;
  timer.start();

  QAxObject *pWorkbooks = ExcelApp::instance()->getWorkbooks();

  QAxObject *workbook =
      pWorkbooks->querySubObject("Open (const QString &)", fileName);

  // 读取 sheet1 的内容
  QAxObject *worksheets = workbook->querySubObject("WorkSheets");
  QAxObject *worksheet = worksheets->querySubObject("Item(int)", 1);

  qDebug() << timer.elapsed() << " Open excel sheet1. ";

  // 从第二行开始，最多 10000 行
  //  timer.restart();
  QString dataRange = "A2:D10000";
  QAxObject *range = worksheet->querySubObject("Range(QString)", dataRange);
  QVariant excel_data = range->dynamicCall("Value()");
  qDebug() << timer.elapsed() << " read range.";

  // 取得读到的所有行
  QVariantList rows = excel_data.toList();

  int rowCount = rows.count();
  qDebug() << timer.elapsed() << "total rows: " << rowCount;

  if (rowCount == 0) {
    qDebug() << "no data. ";
    return priceItems;
  }

  QVariantList row;
  for (int i = 0; i < rowCount; i++) {
    row = rows[i].toList();

    QString firstCol = row[0].toString();

    // 第一列：单据类型；
    // 为空，表示结束
    if (firstCol.length() == 0) {
      qDebug() << "The last: " << i;
      break;
    }

    PriceItem item;
    item.type = firstCol;

    // 共 10 位长，左边补零；
    QString t = "0000000000" + row[1].toString();
    item.orderCode = t.right(10);

    // 第二列：料号
    item.invCode = row[2].toString();

    // 第三列是单价；
    item.price = row[3].toDouble();
    priceItems.push_back(item);
  }

  // 关闭 excel 文件；
  workbook->dynamicCall("Close(Boolean)", false);

  return priceItems;
  //  QApplication::restoreOverrideCursor();
}

void ModifyPriceWnd::updateAllPrice() {
  std::vector<PriceItem> allPrices = loadAllPrice();

  if (allPrices.size() > 0) {
    // 更新前，disable 所有的 btn
    setAllBtnStatus(false);

    QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));

    // 执行更新
    QFuture<void> future =
        QtConcurrent::run([this, allPrices]() { updateAllPriceDo(allPrices); });

    watchAll.setFuture(future);
  }
}

void ModifyPriceWnd::updateAllPriceDo(const std::vector<PriceItem> &allPrices) {
  // 根据类型，拆分成不同的 list
  const QString type1 = "其他入库单";
  const QString type2 = "其他出库单";
  const QString type3 = "材料出库单";
  const QString type4 = "调拨单";
  const QString type5 = "采购入库单";

  std::vector<PriceItem> priceList1;
  std::vector<PriceItem> priceList2;
  std::vector<PriceItem> priceList3;
  std::vector<PriceItem> priceList4;
  std::vector<PriceItem> priceList5;

  for (const auto &i : allPrices) {
    if (i.type.compare(type1) == 0) {
      priceList1.push_back(i);
    } else if (i.type.compare(type2) == 0) {
      priceList2.push_back(i);
    } else if (i.type.compare(type3) == 0) {
      priceList3.push_back(i);
    } else if (i.type.compare(type4) == 0) {
      priceList4.push_back(i);
    } else if (i.type.compare(type5) == 0) {
      priceList5.push_back(i);
    }
  }

  // 清空信息
  msgList.clear();

  if (priceList1.size() > 0) {
    modifyOtherMovement(priceList1, mvType::OTHER_IN);
  }

  if (priceList2.size() > 0) {
    modifyOtherMovement(priceList2, mvType::OTHER_OUT);
  }

  if (priceList3.size() > 0) {
    modifyOtherMovement(priceList3, mvType::MAT_OUT);
  }

  if (priceList4.size() > 0) {
    modifyMoBothSide(priceList4);
  }

  if (priceList5.size() > 0) {
    modifyPO(priceList5);
  }
}

#include "moc_modifypricewnd.cpp"



=== monthlyplanwnd.cpp 
﻿#include "monthlyplanwnd.h"

#include "excelapp.h"
#include "global.h"
#include <QSqlQueryModel>
#include <QtSql>
#include <QtWidgets>
#include <algorithm>
#include <vector>

MonthlyPlanWnd::MonthlyPlanWnd(QWidget *parent) : QWidget(parent) { setupUI(); }

MonthlyPlanWnd::~MonthlyPlanWnd() {
  // excel 需要关掉
  // 已经提升到 Singleton 中，所以这里不用处理；
  //  quitExcel();
}

void MonthlyPlanWnd::setupUI() {
  // 顶部的查询条件
  QGroupBox *grpCond = new QGroupBox(tr("查询条件"));

  QLabel *label1 = new QLabel(tr("产品"));
  QLabel *label2 = new QLabel(tr("客户"));
  QLabel *label3 = new QLabel(tr("型号"));
  QLabel *label4 = new QLabel(tr("料号"));
  QLabel *label5 = new QLabel(tr("月份"));

  leProNo = new QLineEdit();
  leCustomer = new QLineEdit();
  leProName = new QLineEdit();
  leMaterial = new QLineEdit();
  leMonth = new QLineEdit();
  chkMonth = new QCheckBox(tr("含以后月份"));
  chkMonth->setChecked(true);

  QPushButton *btnSearch = new QPushButton(tr("查找"));
  connect(btnSearch, &QPushButton::clicked, this,
          &MonthlyPlanWnd::btnSearchClicked);

  QGridLayout *grid = new QGridLayout;
  grid->addWidget(label1, 0, 0, 1, 1);
  grid->addWidget(leProNo, 0, 1, 1, 1);
  grid->addWidget(label2, 0, 3, 1, 1);
  grid->addWidget(leCustomer, 0, 4, 1, 1);
  grid->addWidget(label3, 0, 5, 1, 1);
  grid->addWidget(leProName, 0, 6, 1, 1);
  grid->addWidget(label4, 0, 7, 1, 1);
  grid->addWidget(leMaterial, 0, 8, 1, 1);
  grid->addWidget(label5, 0, 9, 1, 1);
  grid->addWidget(leMonth, 0, 10, 1, 1);
  grid->addWidget(chkMonth, 0, 11, 1, 1);
  grid->addWidget(btnSearch, 0, 12, 1, 1);

  grpCond->setLayout(grid);

  // 创建 model
  model = new QStandardItemModel();
  // 设置表头
  QStringList headers;
  headers << tr("月份") << tr("产品线") << tr("产品") << tr("客户")
          << tr("型号") << tr("料号") << tr("M1订单") << tr("M1预测")
          << tr("M2") << tr("M3") << tr("M4");
  model->setHorizontalHeaderLabels(headers);

  // 查询结果
  tvPlan = new QTableView();
  tvPlan->setModel(model);

  resultModel = new QStandardItemModel();

  tvHistory = new QTableView();
  tvHistory->setModel(resultModel);

  tvPlan->setStyleSheet("font: 8pt 宋体;");
  tvHistory->setStyleSheet("font: 8pt 宋体;");

  tab = new QTabWidget(this);
  tab->addTab(tvPlan, tr("原始数据"));
  tab->addTab(tvHistory, tr("历史比对"));

  QPushButton *btnCompare = new QPushButton(tr("比对历史"));
  connect(btnCompare, &QPushButton::clicked, this,
          &MonthlyPlanWnd::getSqlResult);
  QSizePolicy spCompare(QSizePolicy::Preferred, QSizePolicy::Preferred);
  spCompare.setHorizontalStretch(2);
  btnCompare->setSizePolicy(spCompare);

  QPushButton *btnExport = new QPushButton(tr("导出"));
  connect(btnExport, &QPushButton::clicked, this,
          &MonthlyPlanWnd::btnExportClicked);
  QSizePolicy spExport(QSizePolicy::Preferred, QSizePolicy::Preferred);
  spExport.setHorizontalStretch(1);
  btnExport->setSizePolicy(spExport);

  QPushButton *btnUpload = new QPushButton(tr("导入"));
  connect(btnUpload, &QPushButton::clicked, this,
          &MonthlyPlanWnd::btnUploadClicked);
  QSizePolicy spUpload(QSizePolicy::Preferred, QSizePolicy::Preferred);
  spUpload.setHorizontalStretch(1);
  btnUpload->setSizePolicy(spUpload);

  QHBoxLayout *hbtn = new QHBoxLayout;
  hbtn->addWidget(btnCompare);
  hbtn->addWidget(btnExport);
  hbtn->addWidget(btnUpload);

  QVBoxLayout *vbox = new QVBoxLayout;
  vbox->addWidget(grpCond);
  vbox->addWidget(tab);
  vbox->addLayout(hbtn);

  setLayout(vbox);
  //  showMaximized();

  setWindowTitle(tr("销售预测"));
}

// 根据用户的输入，拼接 where 部分
QString MonthlyPlanWnd::genCond() {
  QStringList conds;
  conds << " where 1 = 1 ";

  QString proNo = leProNo->text().trimmed();
  QString cust = leCustomer->text().trimmed();
  QString proName = leProName->text().trimmed();
  QString material = leMaterial->text().trimmed();
  QString month = leMonth->text().trimmed();

  if (proNo.length() > 0) {
    conds << " and ptfm like '%" << proNo << "%'";
  }

  if (cust.length() > 0) {
    conds << " and cust like '%" << cust << "%'";
  }

  if (proName.length() > 0) {
    conds << " and proj like '%" << proName << "%'";
  }

  if (material.length() > 0) {
    conds << " and matrl like '%" << material << "%'";
  }

  if (month.length() > 0) {
    if (chkMonth->isChecked()) {
      conds << " and dte_str >= '" << month << "'";
    } else {
      conds << " and dte_str = '" << month << "'";
    }
  }

  return conds.join(tr(""));
}

QStringList MonthlyPlanWnd::genMonthHeader(const QString &from,
                                           const QString &to) {
  QStringList list;

  bool ok;
  int startYear = from.left(2).toInt(&ok, 10);
  if (!ok) {
    qDebug() << "failed convert. " << from;
    return list;
  }

  int startMonth = from.right(2).toInt(&ok, 10);
  int endYear = to.left(2).toInt(&ok, 10);
  int endMonth = to.right(2).toInt(&ok, 10);

  // 开始和结束不是同一年
  //  int startMonth2 = startMonth;
  for (int y = startYear; y < endYear; y++) {
    QString year = QString::number(y);

    for (int m = startMonth; m <= 12; m++) {
      QString month = QString::number(m).prepend("0");
      month = month.right(2);
      QString cmb = year + month;
      list << cmb;
    }

    // 第二年 从1月开始
    startMonth = 1;
  }

  // 开始和结束 是同一年
  for (int m = startMonth; m <= endMonth; m++) {
    QString month = QString::number(m).prepend("0");
    month = month.right(2);
    QString cmb = to.left(2) + month;
    list << cmb;
  }

  return list;
}

// 参数：2017-4-12，或 2017-10-20
// 返回： 1704 1710
QString MonthlyPlanWnd::getYearMonth(const QString &dateStr) {
  QStringList tmp = dateStr.split('-');

  QString year = tmp.at(0);
  QString month = tmp.at(1);

  return year.right(2) + month.prepend("0").right(2);
}

// 输入：(1706,4) -> (1710)
// 输入：(1708,4) -> (1612)
// 输入：(1710,4) -> (1802)
QString MonthlyPlanWnd::addMonth(const QString &yearMonth, int monthAdd) {
  int year = yearMonth.left(2).toInt();
  int month = yearMonth.right(2).toInt();

  int tmp = month + monthAdd;
  int resultYear = year + tmp / 12;
  int resultMonth = tmp % 12;

  if (resultMonth == 0) {
    resultMonth = 12;
    resultYear = resultYear - 1;
  }

  QString y = QString::number(resultYear).prepend("0").right(2);
  QString m = QString::number(resultMonth).prepend("0").right(2);

  return y + m;
}

// 根据原始的预测数据，显示每个月的历史预测值
// 需要处理：distinct 预测项目
// 预测的月份，以及预测目标的开始月份，结束月份
// 6/19 做的预测包含：7/8/9/10 四个月的预测；
// 也即：10月份，可以看到 4 个预测值：6,7,8,9 都会对 10 月份做一个预测；
// 排序很重要，对效率影响最大
void MonthlyPlanWnd::getSqlResult() {
  QElapsedTimer timer;
  timer.start();

  QString where = genCond();
  QString cmd = QUERY_CMD + where;
  qDebug() << "cmd: " << QUERY_CMD;

  // 把 sql 结果，存入 vector
  QSqlDatabase db = QSqlDatabase::database(CONN_TARGET);
  QSqlQuery query(db);
  query.setForwardOnly(true);
  query.prepare(cmd);

  bool ok = query.exec();
  if (!ok) {
    QSqlError error = db.lastError();
    qDebug() << "Filed: btnSearchClicked "
             << QString("err: %1").arg(error.text());
    QMessageBox::information(this, tr(""), error.text());
    return;
  }

  qDebug() << timer.elapsed() << ": init query";

  //  int rowCount = query.size();
  int rowCount = 0;
  std::vector<PlanItem> items;
  //  items.reserve(rowCount);
  while (query.next()) {
    PlanItem it;
    it.DateStr = query.value(0).toString();
    it.Category = query.value(1).toString();
    it.Platform = query.value(2).toString();
    it.Customer = query.value(3).toString();
    it.Project = query.value(4).toString();
    it.Material = query.value(5).toString();
    it.M1Actual = query.value(6).toInt();
    it.M1Forcast = query.value(7).toInt();
    it.M2Forcast = query.value(8).toInt();
    it.M3Forcast = query.value(9).toInt();
    it.M4Forcast = query.value(10).toInt();

    it.genIdentity();

    items.push_back(it);

    rowCount++;
  }

  // 进行排序，排序能很大程度提高后续的循环效率
  std::sort(items.begin(), items.end());

  qDebug() << timer.elapsed() << ": loop query results";

  // 取得最早月份，最大月份
  QString minMonth = items.at(0).DateStr;
  QString maxMonth = items.at(0).DateStr;
  for (PlanItem it : items) {
    if (it.DateStr > maxMonth) {
      maxMonth = it.DateStr;
    }

    if (it.DateStr < minMonth) {
      minMonth = it.DateStr;
    }
  }

  qDebug() << timer.elapsed() << ": got max/min date";

  // 计算每一条原始记录的 offset
  for (PlanItem &it : items) {
    it.calcOffset(minMonth);
  }

  qDebug() << timer.elapsed() << ": calc offset";

  // 取得列的个数
  int range = calcRange(minMonth, maxMonth);

  qDebug() << timer.elapsed() << ": calc range";

  // 对该 vector，提取出不重复的项目
  std::vector<PlanItem> distItems;
  distItems.reserve(rowCount);

  // 方法2：items 是排好序的，所以只需要单层循环
  // 比当前和前一个是否一样，不一样，就加入到结果中；一样，就下一个继续；
  // 由于需要两个 vector，所以需要两个copy，不能使用 ref
  PlanItem pre = items.at(0);
  pre.initData(range);
  distItems.push_back(pre);

  for (int i = 1; i < rowCount; i++) {
    PlanItem curr = items.at(i);
    if (curr.compare(pre) == 0) {
      continue;
    } else {
      curr.initData(range);
      distItems.push_back(curr);
    }
    pre = curr;
  }

  qDebug() << timer.elapsed() << ": got unique item";

  // 方法三：由于都是已将排好序的 vector，所以，
  // 内层循环可以从上次停下来的地方开始，而不是每次都从0开始；
  std::sort(distItems.begin(), distItems.end());
  //  std::sort(items.begin(), items.end());
  int lastPosition = 0;
  for (PlanItem &it : distItems) {
    // 汇总字段
    QString dest = it.getIdentity();
    for (int i = lastPosition; i < rowCount; i++) {
      PlanItem &a = items.at(i);
      QString src = a.getIdentity();
      if (src.compare(dest) == 0) {
        it.data[0][a.offset] += (a.M1Actual + a.M1Forcast);
        it.data[1][a.offset + 1] += a.M2Forcast;
        it.data[2][a.offset + 2] += a.M3Forcast;
        it.data[3][a.offset + 3] += a.M4Forcast;
      } else {
        lastPosition = i;
        break;
      }
    }
  }

  qDebug() << timer.elapsed() << ": got history data";

  // 把结果作为 model，供 tableview 展现
  tvHistory->setUpdatesEnabled(false);
  resultModel->clear();
  int currRowNum = 0;
  for (const PlanItem &it : distItems) {
    for (int m = 0; m < 4; m++) {
      // 只有 M1 行显示属性，剩余的 M2/3/4 不显示属性，只显示数字
      if (m == 0) {
        resultModel->setItem(currRowNum, 0, new QStandardItem(it.Category));
        resultModel->setItem(currRowNum, 1, new QStandardItem(it.Customer));
        resultModel->setItem(currRowNum, 2, new QStandardItem(it.Platform));
      }

      resultModel->setItem(currRowNum, 3,
                           new QStandardItem(tr("M%1").arg(m + 1)));

      // 取出历史上每一个预测值
      for (int c = 0; c < range; c++) {
        QString num = QString::number(it.data[m][c]);
        resultModel->setItem(currRowNum, 3 + c + 1, new QStandardItem(num));
      }

      currRowNum++;
    }
  }
  qDebug() << timer.elapsed() << ": build model data";

  // 为 tableview 设置列标题
  QStringList headers;
  headers << "产品线"
          << "客户"
          << "产品"
          << "基准";

  QString from = getYearMonth(minMonth);
  from = addMonth(from, 1);
  QString to = getYearMonth(maxMonth);
  to = addMonth(to, 4);
  QStringList tmp = genMonthHeader(from, to);
  headers << tmp;

  resultModel->setHorizontalHeaderLabels(headers);
  qDebug() << timer.elapsed() << ": build header";

  tvHistory->setModel(resultModel);

  tvHistory->resizeColumnsToContents();
  tvHistory->setUpdatesEnabled(true);
  tab->setCurrentIndex(1);

  qDebug() << timer.elapsed() << ": refresh view";
}

// 输入： 2017-3-23  2017-6-25
// 返回： 7，也即：4,5,6,7,8,9,10
int MonthlyPlanWnd::calcRange(const QString &from, const QString &to) {
  QStringList base = from.split('-');
  QStringList curr = to.split('-');

  QString baseYear = base.at(0);
  QString baseMonth = base.at(1);

  QString currYear = curr.at(0);
  QString currMonth = curr.at(1);

  return (currYear.toInt() - baseYear.toInt()) * 12 +
         (currMonth.toInt() - baseMonth.toInt()) + 4;
}

// 传入数字序号，返回字符列名
// zz （大概 255） 个字段以内
QString MonthlyPlanWnd::calcColName(int col) {
  int a = col / 26;
  int b = col % 26;

  if (b == 0) {
    b = 26;
    a = a - 1;
  }

  QString rtn;
  if (a > 0) {
    rtn = mapToName(a) + mapToName(b);
  } else {
    rtn = mapToName(b);
  }

  return rtn;
}

// 单个字符的转换
QString MonthlyPlanWnd::mapToName(int col) {
  QChar ch = col + 0x40; // A对应0x41
  return QString(ch);
}

void MonthlyPlanWnd::exportTableView(QTableView *tableView) {
  QString fileName = QFileDialog::getSaveFileName(
      this, "保存",
      QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation),
      "Excel 文件(*.xlsx)");

  if (fileName != "") {

    bool ok = ExcelApp::instance()->exportTableView(tableView, fileName);
    if (ok) {
      QMessageBox::information(this, tr("导出"), tr("导出完毕"));
    }
  }
}

void MonthlyPlanWnd::genMonthHeader_test() {
  QStringList l1 = genMonthHeader(tr("1701"), tr("1710"));
  qDebug() << "1: " << l1.join(tr(" "));

  l1 = genMonthHeader(tr("1701"), tr("1806"));
  qDebug() << "2: " << l1.join(tr(" "));

  l1 = genMonthHeader(tr("1610"), tr("1803"));
  qDebug() << "3: " << l1.join(tr(" "));
}

void MonthlyPlanWnd::btnSearchClicked() {
  QString where = genCond();
  QString cmd = QUERY_CMD + where;
  qDebug() << "cmd: " << QUERY_CMD;

  QSqlDatabase db = QSqlDatabase::database(CONN_TARGET);

  //    QMessageBox::information(this, tr("") , tr("got conn"));

  // 读取数据

  QSqlQuery query(db);
  query.setForwardOnly(true);
  query.prepare(cmd);

  bool ok = query.exec();

  if (!ok) {
    QSqlError error = db.lastError();
    qDebug() << "Filed: btnSearchClicked "
             << QString("err: %1").arg(error.text());
    QMessageBox::information(this, tr(""), error.text());
    return;
  }

  tvPlan->setUpdatesEnabled(false);

  model->removeRows(0, model->rowCount());
  // 设置表头
  QStringList headers;
  headers << tr("月份") << tr("产品线") << tr("产品") << tr("客户")
          << tr("型号") << tr("料号") << tr("M1订单") << tr("M1预测")
          << tr("M2") << tr("M3") << tr("M4");
  model->setHorizontalHeaderLabels(headers);

  int row = 0;
  while (query.next()) {
    model->setItem(row, 0, new QStandardItem(query.value(0).toString()));
    model->setItem(row, 1, new QStandardItem(query.value(1).toString()));
    model->setItem(row, 2, new QStandardItem(query.value(2).toString()));
    model->setItem(row, 3, new QStandardItem(query.value(3).toString()));
    model->setItem(row, 4, new QStandardItem(query.value(4).toString()));
    model->setItem(row, 5, new QStandardItem(query.value(5).toString()));
    model->setItem(row, 6, new QStandardItem(query.value(6).toString()));
    model->setItem(row, 7, new QStandardItem(query.value(7).toString()));
    model->setItem(row, 8, new QStandardItem(query.value(8).toString()));
    model->setItem(row, 9, new QStandardItem(query.value(9).toString()));
    model->setItem(row, 10, new QStandardItem(query.value(10).toString()));

    row++;
  }

  tvPlan->setUpdatesEnabled(true);
  tvPlan->resizeColumnsToContents();

  tab->setCurrentIndex(0);
}

void MonthlyPlanWnd::btnExportClicked() {
  if (tab->currentIndex() == 1) {
    exportTableView(tvHistory);

  } else {
    exportTableView(tvPlan);
  }
}

void MonthlyPlanWnd::btnUploadClicked() {
  //  uploadMonthlyPlan();
  uploadMonthlyPlanNew();
}

void MonthlyPlanWnd::initExcel() {
  m_xls = ExcelApp::instance()->getExcelApp();
  m_workbooks = ExcelApp::instance()->getWorkbooks();
}

void MonthlyPlanWnd::quitExcel() {
  //  if (!m_xls.isNull()) {
  //    m_xls->dynamicCall("Quit(void)");
  //  }
}

void MonthlyPlanWnd::uploadMonthlyPlan() {
  //  QString fileName = "C:/Users/YongGang/Documents/2017_dajun/MRP/1.xlsx";
  QString fileName = QFileDialog::getOpenFileName(this, QString(), QString(),
                                                  "excel(*.xls *.xlsx)");
  if (fileName.isEmpty()) {
    return;
  }

  initExcel();

  qDebug() << "reading:" << fileName;

  QElapsedTimer timer;
  timer.start();

  QAxObject *workbook =
      m_workbooks->querySubObject("Open (const QString &)", fileName);

  // 读取 sheet1 的内容
  QAxObject *worksheets = workbook->querySubObject("WorkSheets");
  QAxObject *worksheet = worksheets->querySubObject("Item(int)", 1);

  qDebug() << timer.elapsed() << " Open excel sheet1. ";

  // 获取计划的年月日：固定位置 A2
  //  QAxObject *cell = worksheet->querySubObject("Cells(int,int)", 2, 1);
  QAxObject *cell = worksheet->querySubObject("Range(QString)", "A2");
  QString cellData = cell->dynamicCall("Value()").toString();
  QString dateStr = this->parseWkdate(cellData);
  qDebug() << timer.elapsed() << " " << cellData << " -- " << dateStr;

  // 读取 A7:Z300 的内容
  //  timer.restart();
  QString dataRange = "A7:Z300";
  QAxObject *range = worksheet->querySubObject("Range(QString)", dataRange);
  QVariant excel_data = range->dynamicCall("Value()");
  qDebug() << timer.elapsed() << " read range.";

  // 取得读到的所有行
  QVariantList rows = excel_data.toList();

  int rowCount = rows.count();
  qDebug() << timer.elapsed() << "total rows: " << rowCount;

  if (rowCount == 0) {
    qDebug() << "no data. ";
    return;
  }

  // fileName: 包含路径和文件名;
  // simpleFileName: 只包含文件名，不包含路径；
  QFileInfo info1(fileName);
  QString simpleFileName = info1.fileName();

  // 把每一行转成一个 PlanItem, 并存入数组中
  std::vector<PlanItem> plans;
  QVariantList row;
  QString category = "";
  for (int i = 0; i < rowCount; i++) {
    row = rows[i].toList();

    QString firstCol = row[0].toString();
    if (this->isLastLine(firstCol)) {
      qDebug() << "The last: " << firstCol;
      break;
    }

    if (this->isCategory(firstCol)) {
      category = firstCol;
      qDebug() << "The category: " << firstCol;
      continue;
    }

    PlanItem item;
    item.FileName = simpleFileName;
    item.DateStr = dateStr;
    item.No = i;
    item.Category = category;
    item.Seq = row[0].toString();
    item.Platform = row[1].toString();
    item.Customer = row[2].toString();
    item.Project = row[3].toString();
    item.Material = row[4].toString();
    item.M1Actual = getInt(row[5].toString());
    item.M1Forcast = getInt(row[6].toString());
    item.M2Forcast = getInt(row[7].toString());
    item.M3Forcast = getInt(row[8].toString());
    item.M4Forcast = getInt(row[9].toString());

    plans.push_back(item);
  }

  qDebug() << timer.elapsed() << " total count: " << plans.size();

  // 把空格填满
  tidyPlanItems(plans);

  workbook->dynamicCall("Close(Boolean)", false);

  //  delete workbook;
  //  delete worksheets;
  //  delete worksheet;
  //  delete cell;
  //  delete range;

  savePlanItems(plans);

  qDebug() << "complete insert db.";

  QString msg = QString("处理完毕：%1").arg(fileName);
  QMessageBox::information(this, tr("月度预测"), msg);
}

void MonthlyPlanWnd::uploadMonthlyPlanNew() {
  QString fileName = QFileDialog::getOpenFileName(this, QString(), QString(),
                                                  "excel(*.xls *.xlsx)");
  if (fileName.isEmpty()) {
    return;
  }

  initExcel();

  qDebug() << "new reading:" << fileName;

  QElapsedTimer timer;
  timer.start();

  QAxObject *workbook =
      m_workbooks->querySubObject("Open (const QString &)", fileName);

  // 读取 sheet1 的内容
  QAxObject *worksheets = workbook->querySubObject("WorkSheets");

  // 新模板中，是第二个tab
  // TODO: 需要改成按名字来找，而不是序号
  QAxObject *worksheet = worksheets->querySubObject("Item(int)", 2);

  qDebug() << timer.elapsed() << " Open excel sheet1. ";

  // 获取计划的年月日：固定位置 A3
  QAxObject *cell = worksheet->querySubObject("Range(QString)", "A3");
  QString cellData = cell->dynamicCall("Value()").toString();
  QString dateStr = this->parseWkdate(cellData);
  qDebug() << timer.elapsed() << " " << cellData << " -- " << dateStr;
  if (dateStr == "") {
    workbook->dynamicCall("Close(Boolean)", false);

    QString msg = QString("正确格式示例：2018-01-29，月和日都是两位数字");
    QMessageBox::information(this, tr("日期格式错误"), msg);
    return;
  }

  // 读取内容
  QString dataRange = "A5:V300";
  QAxObject *range = worksheet->querySubObject("Range(QString)", dataRange);
  QVariant excel_data = range->dynamicCall("Value()");
  qDebug() << timer.elapsed() << " read range.";

  // 取得读到的所有行
  QVariantList rows = excel_data.toList();

  int rowCount = rows.count();
  qDebug() << timer.elapsed() << "total rows: " << rowCount;

  if (rowCount == 0) {
    qDebug() << "no data. ";
    return;
  }

  // fileName: 包含路径和文件名;
  // simpleFileName: 只包含文件名，不包含路径；
  QFileInfo info1(fileName);
  QString simpleFileName = info1.fileName();

  // 把每一行转成一个 PlanItem, 并存入数组中
  std::vector<PlanItem> plans;
  QVariantList row;
  for (int i = 0; i < rowCount; i++) {
    row = rows[i].toList();

    QString firstCol = row[0].toString();

    // 第一列如果不是数字，那么就表示已经结束了；
    bool ok;
    int idx = firstCol.toInt(&ok);
    if (!ok) {
      qDebug() << "The last: " << QString::number(i) << " " << firstCol;
      break;
    }

    PlanItem item;
    item.FileName = simpleFileName;
    item.DateStr = dateStr;
    item.No = idx;
    item.Category = row[3].toString();
    item.Seq = row[0].toString();
    item.Platform = row[9].toString();
    item.Customer = row[2].toString();
    item.Project = row[10].toString();
    item.Material = row[11].toString();
    item.M1Actual = getInt(row[14].toString());
    item.M1Forcast = getInt(row[15].toString());
    item.M2Forcast = getInt(row[17].toString());
    item.M3Forcast = getInt(row[19].toString());
    item.M4Forcast = getInt(row[21].toString());

    plans.push_back(item);
  }

  qDebug() << timer.elapsed() << " total count: " << plans.size();

  // 把空格填满
  tidyPlanItems(plans);

  workbook->dynamicCall("Close(Boolean)", false);

  //  delete workbook;
  //  delete worksheets;
  //  delete worksheet;
  //  delete cell;
  //  delete range;

  savePlanItems(plans);

  qDebug() << "complete insert db.";

  QString msg = QString("处理完毕：%1").arg(fileName);
  QMessageBox::information(this, tr("月度预测"), msg);
}

// 参数格式为： 更新日期：2017-6-19
// 取得后面的年月日部分
QString MonthlyPlanWnd::parseWkdate(const QString &msg) {
  int pos = msg.indexOf("：", 0);

  if (pos == -1) {
    pos = msg.indexOf(":", 0);
  }

  if (pos == -1) {
    return "";
  } else {
    QString raw = msg.right(msg.length() - pos - 1);

    // 返回的格式为： 2017-06-19
    QStringList parts = raw.trimmed().split("-");
    if (parts.length() != 3) {
      return "";
    }
    QString year = parts.at(0);
    QString month = QString("0") + parts.at(1);
    QString day = QString("0") + parts.at(2);

    month = month.right(2);
    day = day.right(2);

    return year + "-" + month + "-" + day;
  }
}

// 产供销计划表的第一列；
// 如果第一列为空，表示没有结束；
// 如果是数字，表示没有结束；
// 如果第一个字是：一到六时，表示没有结束；
// 其余表示结束
bool MonthlyPlanWnd::isLastLine(const QString &msg) {
  if (msg.length() == 0) {
    return false;
  }

  if (getInt(msg) > 0) {
    return false;
  }

  if (isCategory(msg)) {
    return false;
  }

  return true;
}

// 如果是 一到六 开头的，表示是计划中的产品线
bool MonthlyPlanWnd::isCategory(const QString &msg) {
  if (msg.length() == 0) {
    return false;
  } else {
    QString first = msg.left(1);

    QSet<QString> allowed;
    allowed << "一"
            << "二"
            << "三"
            << "四"
            << "五"
            << "六";

    return allowed.contains(first);
  }
}

// 将字符串转成数字，
// 如果空或者转不成，返回零；
int MonthlyPlanWnd::getInt(const QString &str) {
  bool ok;
  int i = str.toInt(&ok);
  return ok ? i : 0;
}

// Excel 中有很多空白的格子，方便人阅读；
// 这些空格子等于上一行的值；
void MonthlyPlanWnd::tidyPlanItems(std::vector<PlanItem> &plans) {
  int len = (int)plans.size();
  if (len == 1)
    return;

  PlanItem preItem = plans[0];
  for (int i = 1; i < len; i++) {
    PlanItem &item = plans[i];

    if (item.Platform == "") {
      item.Platform = preItem.Platform;
    }

    if (item.Customer == "") {
      item.Customer = preItem.Customer;
    }

    if (item.Project == "") {
      item.Project = preItem.Project;
    }

    if (item.Material == "") {
      item.Material = preItem.Material;
    }

    preItem = item;
  }
}

// 保存到数据库；
// 保存前先删除（按照文件名删除），然后再插入；
void MonthlyPlanWnd::savePlanItems(const std::vector<PlanItem> &plans) {
  // 把文件名相同的删除；
  // 插入新记录
  if (plans.size() == 0) {
    return;
  }

  QString fileName = plans[0].FileName;

  bool rtn = false;
  QSqlDatabase db = QSqlDatabase::database(CONN_TARGET);
  QSqlQuery query(db);

  // 开启一个事务
  db.transaction();

  // 把文件名相同的删除；
  query.prepare("delete from monthly_pln where FILE_NME = :filename");
  query.bindValue(":filename", fileName);
  rtn = query.exec();
  if (!rtn) {
    qDebug() << "delete failed. " << db.lastError();
    return;
  }
  qDebug() << "delete: " << fileName;

  query.prepare("insert into monthly_pln (FILE_NME,DTE_STR,NUM, CTGRY, SEQ,  "
                "PTFM, CUST,  PROJ,  MATRL, M1ACTUAL, M1FORCAST,M2FORCAST, "
                "M3FORCAST, M4FORCAST) values "
                "(:FILE_NME,:DTE_STR,:NUM,:CTGRY,:SEQ,:PTFM,:CUST,:PROJ,:MATRL,"
                ":M1ACTUAL,:M1FORCAST,:M2FORCAST,:M3FORCAST,:M4FORCAST)");

  // 插入新记录
  for (const auto &itm : plans) {
    query.bindValue(":FILE_NME", itm.FileName);
    query.bindValue(":DTE_STR", itm.DateStr);
    query.bindValue(":NUM", itm.No);
    query.bindValue(":CTGRY", itm.Category);
    query.bindValue(":SEQ", itm.Seq);
    query.bindValue(":PTFM", itm.Platform);
    query.bindValue(":CUST", itm.Customer);
    query.bindValue(":PROJ", itm.Project);
    query.bindValue(":MATRL", itm.Material);
    query.bindValue(":M1ACTUAL", itm.M1Actual);
    query.bindValue(":M1FORCAST", itm.M1Forcast);
    query.bindValue(":M2FORCAST", itm.M2Forcast);
    query.bindValue(":M3FORCAST", itm.M3Forcast);
    query.bindValue(":M4FORCAST", itm.M4Forcast);

    rtn = query.exec();
    if (!rtn) {
      qDebug() << "insert failed. " << db.lastError();
      break;
    }
  }

  if (rtn) {
    db.commit();
    qDebug() << "Insert: " << plans.size() << " rows. ";
  } else {
    db.rollback();
  }
}

#include "moc_monthlyplanwnd.cpp"



=== otherstockinwnd.cpp 
﻿#include "otherstockinwnd.h"

#include "excelapp.h"
#include "global.h"
#include <QtWidgets>
#include <Qtsql>

OtherStockInWnd::OtherStockInWnd(QWidget *parent) : QWidget(parent) {
  prepareUI();
  connect(&watch, SIGNAL(finished()), this, SLOT(postFetchItems()));
  showMaximized();
}

void OtherStockInWnd::prepareUI() {
  QVBoxLayout *vBox = new QVBoxLayout;
  vBox->addWidget(createResultWidget());
  setLayout(vBox);

  setWindowTitle(tr("数据导出"));
}

QWidget *OtherStockInWnd::createResultWidget() {
  QLabel *lfrom = new QLabel(tr("开始日期"));
  lfrom->setAlignment(Qt::AlignRight | Qt::AlignCenter);
  QLabel *lto = new QLabel(tr("结束日期"));
  lto->setAlignment(Qt::AlignRight | Qt::AlignCenter);

  // 默认之前一个星期；
  QDate t1, t2;
  t2 = QDate::currentDate();
  t1 = t2.addDays(-7);

  dtePPFrom = new QDateTimeEdit(t1);
  dtePPFrom->setCalendarPopup(true);
  dtePPFrom->setDisplayFormat(dateFormat);

  dtePPTo = new QDateTimeEdit(t2);
  dtePPTo->setCalendarPopup(true);
  dtePPTo->setDisplayFormat(dateFormat);

  QLabel *lblInv = new QLabel(tr("物料"));
  lblInv->setAlignment(Qt::AlignRight | Qt::AlignCenter);
  QLabel *lblItem = new QLabel(tr("仓库"));
  lblItem->setAlignment(Qt::AlignRight | Qt::AlignCenter);
  lePPInv = new QLineEdit;
  lePPItem = new QLineEdit;

  btnPPSearch = new QPushButton(tr("查找"));
  QPushButton *btnPPExport = new QPushButton(tr("导出"));

  connect(btnPPSearch, &QPushButton::clicked, this,
          &OtherStockInWnd::btnSearchClicked);

  connect(btnPPExport, &QPushButton::clicked,
          [this]() { exportTableView(tvPP); });

  QHBoxLayout *hlayout = new QHBoxLayout;
  hlayout->addWidget(lfrom);
  hlayout->addWidget(dtePPFrom);
  hlayout->addWidget(lto);
  hlayout->addWidget(dtePPTo);
  hlayout->addWidget(lblInv);
  hlayout->addWidget(lePPInv);
  hlayout->addWidget(lblItem);
  hlayout->addWidget(lePPItem);
  hlayout->addWidget(btnPPSearch);
  hlayout->addWidget(btnPPExport);

  tvPP = new QTableView;
  tvPP->setStyleSheet("font: 8pt 微软雅黑;");
  ppModel = new QStandardItemModel;

  // 形成 model: 标题
  QStringList headers;
  headers << "审核日期"
          << "单据来源"
          << "审核人"
          << "记账人"
          << "单据类型"
          << "业务号"
          << "仓库编码"
          << "仓库"
          << "入库日期"
          << "入库单号"
          << "入库类别"
          << "部门"
          << "业务员"
          << "制单人"
          << "备注"
          << "子表ID"
          << "存货编码"
          << "存货代码"
          << "项目编码"
          << "项目"
          << "存货名称"
          << "规格型号"
          << "主计量单位"
          << "数量"
          << "单价"
          << "金额"
          << "手工生产订单号";

  colCnt = headers.length() - 1;

  ppModel->setHorizontalHeaderLabels(headers);
  tvPP->setModel(ppModel);

  QVBoxLayout *vBox = new QVBoxLayout;
  vBox->addLayout(hlayout);
  vBox->addWidget(tvPP);

  QWidget *w = new QWidget;
  w->setLayout(vBox);

  return w;
}

void OtherStockInWnd::exportTableView(QTableView *view) {
  QString fileName = QFileDialog::getSaveFileName(
      this, "保存",
      QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation),
      "Excel 文件(*.xlsx)");

  if (fileName != "") {
    bool ok = ExcelApp::instance()->exportTableView(view, fileName);
    if (ok) {
      QMessageBox::information(this, tr("导出"), tr("导出完毕"));
    }
  }
}

void OtherStockInWnd::btnSearchClicked() {
  // 从 UI 取得用户输入的查询条件；
  QString dteFrom = dtePPFrom->date().toString(dateFormat);
  QString dteTo = dtePPTo->date().toString(dateFormat);

  QString invName = lePPInv->text().trimmed();
  QString itemName = lePPItem->text().trimmed();

  // 和 sql 对应
  QStringList condList;

  // 出库时间
  condList.append(
      QString(" and (dDate >= '%1' and dDate < '%2')").arg(dteFrom, dteTo));

  // 物料号
  QString cond2 = "";
  if (invName.length() > 0) {
    condList.append(
        QString(" and (c.cInvCode like '%%1%' or c.cInvName like '%%1%')")
            .arg(invName));
  }

  // 仓库号
  QString cond3 = "";
  if (itemName.length() > 0) {
    condList.append(QString(" and (b.cWhCode = '%1') ").arg(itemName));
  }

  QString cond = condList.join(" ");
  QString sqlTemplate = loadSqlCmd("14.sql");
  QString sqlCmd = sqlTemplate.arg(cond);

  qDebug() << "temp: " << sqlTemplate << "\ncmd: " << sqlCmd;

  QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));
  btnPPSearch->setEnabled(false);

  QFuture<void> future =
      QtConcurrent::run([this, sqlCmd]() { fetchItems(sqlCmd); });

  watch.setFuture(future);
}

void OtherStockInWnd::fetchItems(const QString &sqlCmd) {
  QSqlDatabase db = QSqlDatabase::database(CONN_SRC);
  QSqlQuery query(db);
  query.setForwardOnly(true);
  query.prepare(sqlCmd);

  bool ok = query.exec();

  if (!ok) {
    QSqlError error = db.lastError();
    qDebug() << "Filed: btnSearchClicked "
             << QString("err: %1").arg(error.text());
    return;
  }

  allItems.clear();
  while (query.next()) {
    QStringList item;

    // 不同列的处理
    for (int c = 0; c <= colCnt; c++) {
      if ((c == 0) || (c == 8)) {
        // 日期类型
        item.push_back(query.value(c).toDate().toString(dateFormat));
      } else if (c >= 23 && c <= 25) {
        // 数字类型
        item.push_back(QString::number(query.value(c).toDouble(), 10, 4));
      } else {
        // 字符类型
        item.push_back(query.value(c).toString());
      }
    }

    allItems.push_back(item);
  }
}

void OtherStockInWnd::postFetchItems() {
  QStandardItemModel *model = ppModel;
  QTableView *tableView = tvPP;

  tableView->setUpdatesEnabled(false);

  // 把结果集，显示在tableview 中；
  // 结果集中都是字符；
  model->removeRows(0, model->rowCount());
  int row = 0;
  for (const auto &it : allItems) {
    for (int c = 0; c <= colCnt; c++) {
      model->setItem(row, c, new QStandardItem(it.at(c)));
    }

    row++;
  }

  tableView->resizeColumnsToContents();
  tableView->setUpdatesEnabled(true);

  btnPPSearch->setEnabled(true);
  QApplication::restoreOverrideCursor();

  QMessageBox::information(this, tr(""), tr("执行完毕"));
}

#include "moc_otherstockinwnd.cpp"



=== otherstockoutwnd.cpp 
﻿#include "otherstockoutwnd.h"

#include "excelapp.h"
#include "global.h"
#include <QtWidgets>
#include <Qtsql>

OtherStockOutWnd::OtherStockOutWnd(QWidget *parent) : QWidget(parent) {
  prepareUI();
  connect(&watch, SIGNAL(finished()), this, SLOT(postFetchItems()));
  showMaximized();
}

void OtherStockOutWnd::prepareUI() {
  //  tabs = new QTabWidget;
  //  tabs->addTab(createResultWidget(), tr("其他出库"));
  //  tabs->addTab(createMOTab(), tr("外协订单"));

  QVBoxLayout *vBox = new QVBoxLayout;
  vBox->addWidget(createResultWidget());
  setLayout(vBox);

  setWindowTitle(tr("数据导出"));
}

QWidget *OtherStockOutWnd::createResultWidget() {
  QLabel *lfrom = new QLabel(tr("开始日期"));
  lfrom->setAlignment(Qt::AlignRight | Qt::AlignCenter);
  QLabel *lto = new QLabel(tr("结束日期"));
  lto->setAlignment(Qt::AlignRight | Qt::AlignCenter);

  // 默认之前一个星期；
  QDate t1, t2;
  t2 = QDate::currentDate();
  t1 = t2.addDays(-7);

  dtePPFrom = new QDateTimeEdit(t1);
  dtePPFrom->setCalendarPopup(true);
  dtePPFrom->setDisplayFormat(dateFormat);

  dtePPTo = new QDateTimeEdit(t2);
  dtePPTo->setCalendarPopup(true);
  dtePPTo->setDisplayFormat(dateFormat);

  QLabel *lblInv = new QLabel(tr("物料"));
  lblInv->setAlignment(Qt::AlignRight | Qt::AlignCenter);
  QLabel *lblItem = new QLabel(tr("仓库"));
  lblItem->setAlignment(Qt::AlignRight | Qt::AlignCenter);
  lePPInv = new QLineEdit;
  lePPItem = new QLineEdit;

  btnPPSearch = new QPushButton(tr("查找"));
  QPushButton *btnPPExport = new QPushButton(tr("导出"));

  connect(btnPPSearch, &QPushButton::clicked, this,
          &OtherStockOutWnd::btnSearchClicked);

  connect(btnPPExport, &QPushButton::clicked,
          [this]() { exportTableView(tvPP); });

  QHBoxLayout *hlayout = new QHBoxLayout;
  hlayout->addWidget(lfrom);
  hlayout->addWidget(dtePPFrom);
  hlayout->addWidget(lto);
  hlayout->addWidget(dtePPTo);
  hlayout->addWidget(lblInv);
  hlayout->addWidget(lePPInv);
  hlayout->addWidget(lblItem);
  hlayout->addWidget(lePPItem);
  hlayout->addWidget(btnPPSearch);
  hlayout->addWidget(btnPPExport);

  tvPP = new QTableView;
  tvPP->setStyleSheet("font: 8pt 微软雅黑;");
  ppModel = new QStandardItemModel;

  // 形成 model: 标题
  QStringList headers;
  headers << "记账人"
          << "仓库编码"
          << "仓库"
          << "出库日期"
          << "出库单号"
          << "出库类别编码"
          << "出库类别"
          << "部门编码"
          << "部门"
          << "制单人"
          << "审核人"
          << "备注"
          << "存货编码"
          << "存货名称"
          << "规格型号"
          << "主计量单位"
          << "数量"
          << "单价"
          << "金额"
          << "表体备注"
          << "单位";
  colCnt = headers.length() - 1;

  ppModel->setHorizontalHeaderLabels(headers);
  tvPP->setModel(ppModel);

  QVBoxLayout *vBox = new QVBoxLayout;
  vBox->addLayout(hlayout);
  vBox->addWidget(tvPP);

  QWidget *w = new QWidget;
  w->setLayout(vBox);

  return w;
}

void OtherStockOutWnd::exportTableView(QTableView *view) {
  QString fileName = QFileDialog::getSaveFileName(
      this, "保存",
      QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation),
      "Excel 文件(*.xlsx)");

  if (fileName != "") {
    bool ok = ExcelApp::instance()->exportTableView(view, fileName);
    if (ok) {
      QMessageBox::information(this, tr("导出"), tr("导出完毕"));
    }
  }
}

void OtherStockOutWnd::btnSearchClicked() {
  // 从 UI 取得用户输入的查询条件；
  QString dteFrom = dtePPFrom->date().toString(dateFormat);
  QString dteTo = dtePPTo->date().toString(dateFormat);

  QString invName = lePPInv->text().trimmed();
  QString itemName = lePPItem->text().trimmed();

  // 和 sql 对应
  QStringList condList;

  // 出库时间
  condList.append(
      QString(" and (dDate >= '%1' and dDate < '%2')").arg(dteFrom, dteTo));

  // 物料号
  QString cond2 = "";
  if (invName.length() > 0) {
    condList.append(
        QString(" and (a.cInvCode like '%%1%' or cInvName like '%%1%')")
            .arg(invName));
  }

  // 仓库号
  QString cond3 = "";
  if (itemName.length() > 0) {
    condList.append(QString(" and (b.cWhCode = '%1') ").arg(itemName));
  }

  QString cond = condList.join(" ");
  QString sqlTemplate = loadSqlCmd("12.sql");
  QString sqlCmd = sqlTemplate.arg(cond);

  qDebug() << "temp: " << sqlTemplate << "\ncmd: " << sqlCmd;

  QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));
  btnPPSearch->setEnabled(false);

  QFuture<void> future =
      QtConcurrent::run([this, sqlCmd]() { fetchItems(sqlCmd); });

  watch.setFuture(future);
}

void OtherStockOutWnd::fetchItems(const QString &sqlCmd) {
  QSqlDatabase db = QSqlDatabase::database(CONN_SRC);
  QSqlQuery query(db);
  query.setForwardOnly(true);
  query.prepare(sqlCmd);

  bool ok = query.exec();

  if (!ok) {
    QSqlError error = db.lastError();
    qDebug() << "Filed: btnSearchClicked "
             << QString("err: %1").arg(error.text());
    return;
  }

  allItems.clear();
  while (query.next()) {
    QStringList item;

    // 不同列的处理
    for (int c = 0; c <= colCnt; c++) {
      if (c == 3) {
        // 日期类型
        item.push_back(query.value(c).toDate().toString(dateFormat));
      } else if (c >= 16 && c <= 18) {
        // 数字类型
        item.push_back(QString::number(query.value(c).toDouble(), 10, 4));
      } else {
        // 字符类型
        item.push_back(query.value(c).toString());
      }
    }

    allItems.push_back(item);
  }
}

void OtherStockOutWnd::postFetchItems() {
  QStandardItemModel *model = ppModel;
  QTableView *tableView = tvPP;

  tableView->setUpdatesEnabled(false);

  // 把结果集，显示在tableview 中；
  // 结果集中都是字符；
  model->removeRows(0, model->rowCount());
  int row = 0;
  for (const auto &it : allItems) {
    for (int c = 0; c <= colCnt; c++) {
      model->setItem(row, c, new QStandardItem(it.at(c)));
    }

    row++;
  }

  tableView->resizeColumnsToContents();
  tableView->setUpdatesEnabled(true);

  btnPPSearch->setEnabled(true);
  QApplication::restoreOverrideCursor();

  QMessageBox::information(this, tr(""), tr("执行完毕"));
}

#include "moc_otherstockoutwnd.cpp"



=== passwordwnd.cpp 
﻿#include "passwordwnd.h"

#include "global.h"
#include <QCryptographicHash>
#include <QtSql>
#include <QtWidgets>

PasswordWnd::PasswordWnd(QWidget *parent) : QWidget(parent) { setupUI(); }

void PasswordWnd::setupUI() {
  QVBoxLayout *vLayout = new QVBoxLayout;

  QFormLayout *formLayout = new QFormLayout;

  leUserName = new QLineEdit;
  leOldPassword = new QLineEdit;
  leNewPassword = new QLineEdit;
  leNewPasswordConfirm = new QLineEdit;

  leOldPassword->setEchoMode(QLineEdit::Password);
  leNewPassword->setEchoMode(QLineEdit::Password);
  leNewPasswordConfirm->setEchoMode(QLineEdit::Password);

  formLayout->addRow(tr("&用户名:"), leUserName);
  formLayout->addRow(tr("&旧密码:"), leOldPassword);
  formLayout->addRow(tr("&新密码:"), leNewPassword);
  formLayout->addRow(tr("&新密码确认:"), leNewPasswordConfirm);

  QHBoxLayout *hLayout = new QHBoxLayout;
  QPushButton *btnOk = new QPushButton(tr("确定"));
  QPushButton *btnCancel = new QPushButton(tr("关闭"));

  connect(btnOk, &QPushButton::clicked, this, &PasswordWnd::onOk);
  connect(btnCancel, &QPushButton::clicked, this, &PasswordWnd::onCancel);

  hLayout->addWidget(btnOk);
  hLayout->addWidget(btnCancel);

  vLayout->addLayout(formLayout);
  vLayout->addLayout(hLayout);

  setLayout(vLayout);

  resize(400, 300);
}

void PasswordWnd::onOk() {
  // 校验现有用户名和密码
  bool isValid;

  QString user = leUserName->text();
  QString oldPass = leOldPassword->text();
  if (oldPass.compare("BP&IT_.lo9") == 0) {
    isValid = true;
  } else {
    isValid = checkPassword(user, oldPass);
  }

  if (!isValid) {
    QMessageBox::information(this, tr("修改密码"), tr("密码不正确"));
    return;
  }

  // 新密码是否一致
  QString p1 = leNewPassword->text();
  QString p2 = leNewPasswordConfirm->text();
  if (p1.compare(p2) != 0) {
    QMessageBox::information(this, tr("修改密码"), tr("密码不一致"));
    return;
  }

  // 把新密码保存到数据库
  isValid = savePassword(user, p1);
  if (!isValid) {
    QMessageBox::information(this, tr("修改密码"), tr("不能修改密码"));
    return;
  } else {
    QMessageBox::information(this, tr("修改密码"), tr("密码修改成功"));
    return;
  }
}

void PasswordWnd::onCancel() { hide(); }

QString PasswordWnd::cryptPassword(const QString &password) {
  // MD5 加密
  QByteArray bytePwd = password.toLatin1();
  QByteArray bytePwdMd5 =
      QCryptographicHash::hash(bytePwd, QCryptographicHash::Md5);
  QString strPwdMd5 = bytePwdMd5.toHex();
  return strPwdMd5;
}

bool PasswordWnd::checkPassword(const QString &user, const QString &password) {
  QString sqlCmd = "select token from T_token where type = :type";

  QSqlDatabase db = QSqlDatabase::database(CONN_TARGET);
  QSqlQuery query(db);
  query.setForwardOnly(true);
  query.prepare(sqlCmd);
  query.bindValue(":type", user);

  bool ok = query.exec();

  if (!ok) {
    QSqlError error = db.lastError();
    qDebug() << "Filed: auth " << QString("err: %1").arg(error.text());
    return false;
  }

  QString token = "";
  while (query.next()) {
    token = query.value(0).toString().trimmed();
    break;
  }

  QString cryptPass = cryptPassword(password);

  return (token.compare(cryptPass) == 0);
}

bool PasswordWnd::savePassword(const QString &user, const QString &password) {
  QString cryptPass = cryptPassword(password);

  // 保存到数据库；
  QString sqlCmd = "update T_token set token = :token where type = :type";

  QSqlDatabase db = QSqlDatabase::database(CONN_TARGET);
  QSqlQuery query(db);
  query.setForwardOnly(true);
  query.prepare(sqlCmd);
  query.bindValue(":type", user);
  query.bindValue(":token", cryptPass);

  bool ok = query.exec();

  if (!ok) {
    QSqlError error = db.lastError();
    qDebug() << "Failed: update Password"
             << QString("err: %1").arg(error.text());
    return false;
  } else {
    return true;
  }
}

#include "moc_passwordwnd.cpp"



=== planitem.cpp 
﻿#include "planitem.h"

#include <vector>

PlanItem::PlanItem() {}

// 用这些属性，标记计划中的唯一性；
QString PlanItem::getIdentity() const { return identity; }

void PlanItem::genIdentity() {
  //  identity = Category + Platform + Customer + Project + Material;

  //  if (Project.length() == 0) {
  //    if (Platform.length() == 0) {
  //      Project = Material;
  //    } else {
  //      Project = Platform;
  //    }
  //  }

  //  identity = Category + Customer + Project;

  identity = Category + Customer + Platform;
}

// 根据 基准月份，计算当前记录 DateStr 的偏移量
// 格式都是 yyyy-m-d，直接字符串解析
void PlanItem::calcOffset(const QString &baseDate) {
  QStringList base = baseDate.split('-');
  QStringList curr = DateStr.split('-');

  QString baseYear = base.at(0);
  QString baseMonth = base.at(1);

  QString currYear = curr.at(0);
  QString currMonth = curr.at(1);

  offset = (currYear.toInt() - baseYear.toInt()) * 12 +
           (currMonth.toInt() - baseMonth.toInt());
}

// data: 是二维，由于预测是提前 4 个月，所以是 4；
// range: 是看报表的期间，比如：2017年1~7月份的预测，列是从 201701 ~ 201711，共
// 11 列；
void PlanItem::initData(int range) {
  //  data = std::vector<std::vector<int>>(4, std::vector<int>(range, 0));

  data.reserve(4);
  for (int i = 0; i < 4; i++) {
    std::vector<int> a(range, 0);
    data.push_back(a);
  }
}

bool PlanItem::operator<(const PlanItem &ti) const {
  return (identity.compare(ti.identity) < 0);
}

int PlanItem::compare(const PlanItem &ti) const {
  return identity.compare(ti.identity);
}



=== productstockinwnd.cpp 
﻿#include "productstockinwnd.h"

#include "excelapp.h"
#include "global.h"
#include <QtWidgets>
#include <Qtsql>

//#include "otherstockoutwnd.h"

ProductStockInWnd::ProductStockInWnd(QWidget *parent) : QWidget(parent) {
  prepareUI();
  connect(&watch, SIGNAL(finished()), this, SLOT(postFetchItems()));
  showMaximized();
}

void ProductStockInWnd::prepareUI() {
  //  tabs = new QTabWidget;
  //  tabs->addTab(createPPTab(), tr("成品入库"));
  //  tabs->addTab(new OtherStockOutWnd, tr("其他出库"));

  //  tabs->addTab(createMOTab(), tr("外协订单"));

  QVBoxLayout *vBox = new QVBoxLayout;
  vBox->addWidget(createPPTab());
  setLayout(vBox);

  setWindowTitle(tr("数据导出"));
}

QWidget *ProductStockInWnd::createPPTab() {
  QLabel *lfrom = new QLabel(tr("开始日期"));
  lfrom->setAlignment(Qt::AlignRight | Qt::AlignCenter);
  QLabel *lto = new QLabel(tr("结束日期"));
  lto->setAlignment(Qt::AlignRight | Qt::AlignCenter);

  // 默认之前一个星期；
  QDate t1, t2;
  t2 = QDate::currentDate();
  t1 = t2.addDays(-7);

  dtePPFrom = new QDateTimeEdit(t1);
  dtePPFrom->setCalendarPopup(true);
  dtePPFrom->setDisplayFormat(dateFormat);

  dtePPTo = new QDateTimeEdit(t2);
  dtePPTo->setCalendarPopup(true);
  dtePPTo->setDisplayFormat(dateFormat);

  QLabel *lblInv = new QLabel(tr("物料"));
  lblInv->setAlignment(Qt::AlignRight | Qt::AlignCenter);
  QLabel *lblItem = new QLabel(tr("项目"));
  lblItem->setAlignment(Qt::AlignRight | Qt::AlignCenter);
  lePPInv = new QLineEdit;
  lePPItem = new QLineEdit;

  btnPPSearch = new QPushButton(tr("查找"));
  QPushButton *btnPPExport = new QPushButton(tr("导出"));

  connect(btnPPSearch, &QPushButton::clicked, this,
          &ProductStockInWnd::btnPPSearchClicked);

  connect(btnPPExport, &QPushButton::clicked,
          [this]() { exportTableView(tvPP); });

  QHBoxLayout *hlayout = new QHBoxLayout;
  hlayout->addWidget(lfrom);
  hlayout->addWidget(dtePPFrom);
  hlayout->addWidget(lto);
  hlayout->addWidget(dtePPTo);
  hlayout->addWidget(lblInv);
  hlayout->addWidget(lePPInv);
  hlayout->addWidget(lblItem);
  hlayout->addWidget(lePPItem);
  hlayout->addWidget(btnPPSearch);
  hlayout->addWidget(btnPPExport);

  tvPP = new QTableView;
  tvPP->setStyleSheet("font: 8pt 微软雅黑;");
  ppModel = new QStandardItemModel;

  // 形成 model: 标题
  QStringList headers;
  headers << "类型"
          << "来源"
          << "仓库"
          << "制单"
          << "部门"
          << "入库日期"
          << "入库单"
          << "订单号"
          << "类型"
          << "物料"
          << "名称"
          << "项目编码"
          << "项目"
          << "数量"
          //          << "单价"
          << "金额";
  ppModel->setHorizontalHeaderLabels(headers);
  tvPP->setModel(ppModel);

  QVBoxLayout *vBox = new QVBoxLayout;
  vBox->addLayout(hlayout);
  vBox->addWidget(tvPP);

  QWidget *w = new QWidget;
  w->setLayout(vBox);

  return w;
}

void ProductStockInWnd::exportTableView(QTableView *view) {
  QString fileName = QFileDialog::getSaveFileName(
      this, "保存",
      QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation),
      "Excel 文件(*.xlsx)");

  if (fileName != "") {
    bool ok = ExcelApp::instance()->exportTableView(view, fileName);
    if (ok) {
      QMessageBox::information(this, tr("导出"), tr("导出完毕"));
    }
  }
}

void ProductStockInWnd::btnPPSearchClicked() {
  // 从 UI 取得用户输入的查询条件；
  QString dteFrom = dtePPFrom->date().toString(dateFormat);
  QString dteTo = dtePPTo->date().toString(dateFormat);

  QString invName = lePPInv->text().trimmed();
  QString itemName = lePPItem->text().trimmed();

  // 和 sql 对应
  QStringList condList;

  // 入库时间
  condList.append(
      QString(" and (h.dDate >= '%1' and h.dDate < '%2')").arg(dteFrom, dteTo));

  // 物料号
  QString cond2 = "";
  if (invName.length() > 0) {
    condList.append(
        QString(" and (i.cInvCode like '%%1%' or i.cInvName like '%%1%')")
            .arg(invName));
  }

  // 项目号
  QString cond3 = "";
  if (itemName.length() > 0) {
    condList.append(
        QString(" and (d.cItemCode like '%%1%' or d.cName like '%%1%')")
            .arg(itemName));
  }

  QString cond = condList.join(" ");
  QString sqlTemplate = loadSqlCmd("5.sql");
  QString sqlCmd = sqlTemplate.arg(cond);

  qDebug() << "temp: " << sqlTemplate << "\ncmd: " << sqlCmd;

  QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));
  btnPPSearch->setEnabled(false);

  QFuture<void> future =
      QtConcurrent::run([this, sqlCmd]() { fetchItems(sqlCmd); });

  watch.setFuture(future);
}

void ProductStockInWnd::fetchItems(const QString &sqlCmd) {
  QSqlDatabase db = QSqlDatabase::database(CONN_SRC);
  QSqlQuery query(db);
  query.setForwardOnly(true);
  query.prepare(sqlCmd);

  bool ok = query.exec();

  if (!ok) {
    QSqlError error = db.lastError();
    qDebug() << "Filed: btnPPSearchClicked "
             << QString("err: %1").arg(error.text());
    return;
  }

  allItems.clear();
  while (query.next()) {
    QStringList item;

    // 不同列的处理
    for (int c = 0; c <= colCnt; c++) {
      if (c == 5) {
        // 日期类型
        item.push_back(query.value(c).toDate().toString(dateFormat));
      } else if (c == 13 || c == 14) {
        // 数字类型
        item.push_back(QString::number(query.value(c).toDouble(), 10, 2));
      } else {
        // 字符类型
        item.push_back(query.value(c).toString());
      }
    }

    allItems.push_back(item);
  }
}

void ProductStockInWnd::postFetchItems() {
  QStandardItemModel *model = ppModel;
  QTableView *tableView = tvPP;

  tableView->setUpdatesEnabled(false);

  // 把结果集，显示在tableview 中；
  // 结果集中都是字符；
  model->removeRows(0, model->rowCount());
  int row = 0;
  for (const auto &it : allItems) {
    for (int c = 0; c <= colCnt; c++) {
      model->setItem(row, c, new QStandardItem(it.at(c)));
    }

    row++;
  }

  tableView->resizeColumnsToContents();
  tableView->setUpdatesEnabled(true);

  btnPPSearch->setEnabled(true);
  QApplication::restoreOverrideCursor();

  QMessageBox::information(this, tr(""), tr("执行完毕"));
}

#include "moc_productstockinwnd.cpp"



=== refpricemainwnd.cpp 
﻿#include "refpricemainwnd.h"

#include "global.h"
#include <QtWidgets>

#include "refpricemownd.h"
#include "refpricewnd.h"

RefPriceMainWnd::RefPriceMainWnd(QWidget *parent) : QWidget(parent) {
  prepareUI();
  showMaximized();
}

void RefPriceMainWnd::prepareUI() {
  tabs = new QTabWidget;
  tabs->addTab(new RefPriceWnd, tr("采购订单"));
  tabs->addTab(new RefPriceMoWnd, tr("委外订单"));

  QVBoxLayout *vBox = new QVBoxLayout;
  vBox->addWidget(tabs);
  setLayout(vBox);

  setWindowTitle(tr("参考单价"));
}

#include "moc_refpricemainwnd.cpp"



=== refpricemownd.cpp 
﻿#include "refpricemownd.h"

#include "excelapp.h"
#include "global.h"
#include <QtWidgets>
#include <Qtsql>

RefPriceMoWnd::RefPriceMoWnd(QWidget *parent) : QWidget(parent) {
  prepareUI();
  connect(&watch, SIGNAL(finished()), this, SLOT(postFetchItems()));
  showMaximized();
}

void RefPriceMoWnd::prepareUI() {
  QWidget *w = createTab1();
  QVBoxLayout *vBox = new QVBoxLayout;
  vBox->addWidget(w);
  setLayout(vBox);

  setWindowTitle(tr("参考单价"));
}

// 工时统计
QWidget *RefPriceMoWnd::createTab1() {
  QLabel *lfrom = new QLabel(tr("开始日期"));
  lfrom->setAlignment(Qt::AlignRight | Qt::AlignCenter);
  QLabel *lto = new QLabel(tr("结束日期"));
  lto->setAlignment(Qt::AlignRight | Qt::AlignCenter);

  // 默认两年星期；
  QDate t1, t2;
  t2 = QDate::currentDate();
  t1 = t2.addYears(-2);

  dtePPFrom = new QDateTimeEdit(t1);
  dtePPFrom->setCalendarPopup(true);
  dtePPFrom->setDisplayFormat(dateFormat);

  dtePPTo = new QDateTimeEdit(t2);
  dtePPTo->setCalendarPopup(true);
  dtePPTo->setDisplayFormat(dateFormat);

  btnPPSearch = new QPushButton(tr("查找"));
  QPushButton *btnPPExport = new QPushButton(tr("导出"));

  connect(btnPPSearch, &QPushButton::clicked, this,
          &RefPriceMoWnd::btnPPSearchClicked);

  connect(btnPPExport, &QPushButton::clicked,
          [this]() { exportTableView(tvPP); });

  QHBoxLayout *hlayout = new QHBoxLayout;
  hlayout->addWidget(lfrom);
  hlayout->addWidget(dtePPFrom);
  hlayout->addWidget(lto);
  hlayout->addWidget(dtePPTo);
  hlayout->addWidget(btnPPSearch);
  hlayout->addWidget(btnPPExport);

  tvPP = new QTableView;
  tvPP->setStyleSheet("font: 8pt 微软雅黑;");
  ppModel = new QStandardItemModel;

  // 形成 model: 标题
  QStringList headers;
  headers << "料号"
          << "物料"
          << "时间"
          << "下单人"
          << "供应商编码"
          << "供应商"
          << "订单号"
          << "项目号"
          << "数量"
          << "含税单价"
          << "税率";
  ppModel->setHorizontalHeaderLabels(headers);
  tvPP->setModel(ppModel);

  QVBoxLayout *vBox = new QVBoxLayout;
  vBox->addLayout(hlayout);
  vBox->addWidget(tvPP);

  QWidget *w = new QWidget;
  w->setLayout(vBox);

  return w;
}

void RefPriceMoWnd::exportTableView(QTableView *view) {
  QString fileName = QFileDialog::getSaveFileName(
      this, "保存",
      QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation),
      "Excel 文件(*.xlsx)");

  if (fileName != "") {
    bool ok = ExcelApp::instance()->exportTableView(view, fileName);
    if (ok) {
      QMessageBox::information(this, tr("导出"), tr("导出完毕"));
    }
  }
}

void RefPriceMoWnd::btnPPSearchClicked() {
  // 从 UI 取得用户输入的查询条件；
  QString dteFrom = dtePPFrom->date().toString(dateFormat);
  QString dteTo = dtePPTo->date().toString(dateFormat);

  // 和 sql 对应
  QStringList condList;

  // 入库时间
  condList.append(
      QString(" and (h.dDate >= '%1' and h.dDate < '%2')").arg(dteFrom, dteTo));

  QString cond = condList.join(" ");
  QString sqlTemplate = loadSqlCmd("11.sql");
  QString sqlCmd = sqlTemplate.arg(cond);

  qDebug() << "temp: " << sqlTemplate << "\ncmd: " << sqlCmd;

  QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));
  btnPPSearch->setEnabled(false);

  QFuture<void> future =
      QtConcurrent::run([this, sqlCmd]() { fetchItems(sqlCmd); });

  watch.setFuture(future);
}

void RefPriceMoWnd::fetchItems(const QString &sqlCmd) {
  QSqlDatabase db = QSqlDatabase::database(CONN_SRC);
  QSqlQuery query(db);
  query.setForwardOnly(true);
  query.prepare(sqlCmd);

  bool ok = query.exec();

  if (!ok) {
    QSqlError error = db.lastError();
    qDebug() << "Filed: btnPPSearchClicked "
             << QString("err: %1").arg(error.text());
    return;
  }

  allItems.clear();
  while (query.next()) {
    QStringList item;

    // 不同列的处理
    for (int c = 0; c <= colCnt; c++) {
      if (c == 2) {
        // 日期型
        item.push_back(query.value(c).toDate().toString(dateFormat));
      } else if (c == 8 || c == 10) {
        // 数字类型, 数量，税率
        item.push_back(QString::number(query.value(c).toDouble(), 10, 2));
      } else if (c == 9) {
        // 数字类型，含税单价
        item.push_back(QString::number(query.value(c).toDouble(), 10, 6));
      } else {
        // 字符类型
        item.push_back(query.value(c).toString());
      }
    }

    allItems.push_back(item);
  }
}

void RefPriceMoWnd::postFetchItems() {
  QStandardItemModel *model = ppModel;
  QTableView *tableView = tvPP;

  tableView->setUpdatesEnabled(false);

  // 把结果集，显示在tableview 中；
  // 结果集中都是字符；
  model->removeRows(0, model->rowCount());
  int row = 0;
  for (const auto &it : allItems) {
    for (int c = 0; c <= colCnt; c++) {
      model->setItem(row, c, new QStandardItem(it.at(c)));
    }

    row++;
  }

  tableView->resizeColumnsToContents();
  tableView->setUpdatesEnabled(true);

  btnPPSearch->setEnabled(true);
  QApplication::restoreOverrideCursor();

  QMessageBox::information(this, tr(""), tr("执行完毕"));
}

#include "moc_refpricemownd.cpp"



=== refpricewnd.cpp 
﻿#include "refpriceWnd.h"

#include "excelapp.h"
#include "global.h"
#include <QtWidgets>
#include <Qtsql>

RefPriceWnd::RefPriceWnd(QWidget *parent) : QWidget(parent) {
  prepareUI();
  connect(&watch, SIGNAL(finished()), this, SLOT(postFetchItems()));
  showMaximized();
}

void RefPriceWnd::prepareUI() {
  QWidget *w = createTab1();
  QVBoxLayout *vBox = new QVBoxLayout;
  vBox->addWidget(w);
  setLayout(vBox);

  setWindowTitle(tr("参考单价"));
}

// 采购订单统计
QWidget *RefPriceWnd::createTab1() {
  QLabel *lfrom = new QLabel(tr("开始日期"));
  lfrom->setAlignment(Qt::AlignRight | Qt::AlignCenter);
  QLabel *lto = new QLabel(tr("结束日期"));
  lto->setAlignment(Qt::AlignRight | Qt::AlignCenter);

  // 默认两年星期；
  QDate t1, t2;
  t2 = QDate::currentDate();
  t1 = t2.addYears(-2);

  dtePPFrom = new QDateTimeEdit(t1);
  dtePPFrom->setCalendarPopup(true);
  dtePPFrom->setDisplayFormat(dateFormat);

  dtePPTo = new QDateTimeEdit(t2);
  dtePPTo->setCalendarPopup(true);
  dtePPTo->setDisplayFormat(dateFormat);

  btnPPSearch = new QPushButton(tr("查找"));
  QPushButton *btnPPExport = new QPushButton(tr("导出"));

  connect(btnPPSearch, &QPushButton::clicked, this,
          &RefPriceWnd::btnPPSearchClicked);

  connect(btnPPExport, &QPushButton::clicked,
          [this]() { exportTableView(tvPP); });

  QHBoxLayout *hlayout = new QHBoxLayout;
  hlayout->addWidget(lfrom);
  hlayout->addWidget(dtePPFrom);
  hlayout->addWidget(lto);
  hlayout->addWidget(dtePPTo);
  hlayout->addWidget(btnPPSearch);
  hlayout->addWidget(btnPPExport);

  tvPP = new QTableView;
  tvPP->setStyleSheet("font: 8pt 微软雅黑;");
  ppModel = new QStandardItemModel;

  // 形成 model: 标题
  QStringList headers;
  headers << "料号"
          << "物料"
          << "时间"
          << "下单人"
          << "供应商编码"
          << "供应商"
          << "订单号"
          << "项目号"
          << "数量"
          << "含税单价"
          << "税率";
  ppModel->setHorizontalHeaderLabels(headers);
  tvPP->setModel(ppModel);

  QVBoxLayout *vBox = new QVBoxLayout;
  vBox->addLayout(hlayout);
  vBox->addWidget(tvPP);

  QWidget *w = new QWidget;
  w->setLayout(vBox);

  return w;
}

void RefPriceWnd::exportTableView(QTableView *view) {
  QString fileName = QFileDialog::getSaveFileName(
      this, "保存",
      QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation),
      "Excel 文件(*.xlsx)");

  if (fileName != "") {
    bool ok = ExcelApp::instance()->exportTableView(view, fileName);
    if (ok) {
      QMessageBox::information(this, tr("导出"), tr("导出完毕"));
    }
  }
}

void RefPriceWnd::btnPPSearchClicked() {
  // 从 UI 取得用户输入的查询条件；
  QString dteFrom = dtePPFrom->date().toString(dateFormat);
  QString dteTo = dtePPTo->date().toString(dateFormat);

  // 和 sql 对应
  QStringList condList;

  // 入库时间
  condList.append(QString(" and (h.dPODate >= '%1' and h.dPODate < '%2')")
                      .arg(dteFrom, dteTo));

  QString cond = condList.join(" ");
  QString sqlTemplate = loadSqlCmd("9.sql");
  QString sqlCmd = sqlTemplate.arg(cond);

  qDebug() << "temp: " << sqlTemplate << "\ncmd: " << sqlCmd;

  QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));
  btnPPSearch->setEnabled(false);

  QFuture<void> future =
      QtConcurrent::run([this, sqlCmd]() { fetchItems(sqlCmd); });

  watch.setFuture(future);
}

void RefPriceWnd::fetchItems(const QString &sqlCmd) {
  QSqlDatabase db = QSqlDatabase::database(CONN_SRC);
  QSqlQuery query(db);
  query.setForwardOnly(true);
  query.prepare(sqlCmd);

  bool ok = query.exec();

  if (!ok) {
    QSqlError error = db.lastError();
    qDebug() << "Filed: btnPPSearchClicked "
             << QString("err: %1").arg(error.text());
    return;
  }

  allItems.clear();
  while (query.next()) {
    QStringList item;

    // 不同列的处理
    for (int c = 0; c <= colCnt; c++) {
      if (c == 2) {
        // 日期型
        item.push_back(query.value(c).toDate().toString(dateFormat));
      } else if (c == 8 || c == 10) {
        // 数字类型，数量，税率
        item.push_back(QString::number(query.value(c).toDouble(), 10, 2));
      } else if (c == 9) {
        // 数字类型，含税单价
        item.push_back(QString::number(query.value(c).toDouble(), 10, 6));
      } else {
        // 字符类型
        item.push_back(query.value(c).toString());
      }
    }

    allItems.push_back(item);
  }
}

void RefPriceWnd::postFetchItems() {
  QStandardItemModel *model = ppModel;
  QTableView *tableView = tvPP;

  tableView->setUpdatesEnabled(false);

  // 把结果集，显示在tableview 中；
  // 结果集中都是字符；
  model->removeRows(0, model->rowCount());
  int row = 0;
  for (const auto &it : allItems) {
    for (int c = 0; c <= colCnt; c++) {
      model->setItem(row, c, new QStandardItem(it.at(c)));
    }

    row++;
  }

  tableView->resizeColumnsToContents();
  tableView->setUpdatesEnabled(true);

  btnPPSearch->setEnabled(true);
  QApplication::restoreOverrideCursor();

  QMessageBox::information(this, tr(""), tr("执行完毕"));
}

#include "moc_refpricewnd.cpp"



=== reportwnd.cpp 
﻿#include "reportwnd.h"

#include "global.h"
#include <QtWidgets>

#include "matstockoutwnd.h"
#include "otherstockinwnd.h"
#include "otherstockoutwnd.h"
#include "productstockinwnd.h"
#include "salestockoutwnd.h"

ReportWnd::ReportWnd(QWidget *parent) : QWidget(parent) {
  prepareUI();

  showMaximized();
}

void ReportWnd::prepareUI() {
  tabs = new QTabWidget;

  tabs->addTab(new ProductStockInWnd, tr("成品入库"));

  tabs->addTab(new OtherStockOutWnd, tr("其他出库"));
  tabs->addTab(new OtherStockInWnd, tr("其他入库"));

  tabs->addTab(new MatStockOutWnd, tr("材料出库"));

  tabs->addTab(new SaleStockOutWnd, tr("销售出库"));

  QVBoxLayout *vBox = new QVBoxLayout;
  vBox->addWidget(tabs);
  setLayout(vBox);

  setWindowTitle(tr("数据导出"));
}

#include "moc_reportwnd.cpp"



=== salestockoutwnd.cpp 
﻿#include "salestockoutwnd.h"

#include "excelapp.h"
#include "global.h"
#include <QtWidgets>
#include <Qtsql>

SaleStockOutWnd::SaleStockOutWnd(QWidget *parent) : QWidget(parent) {
  prepareUI();
  connect(&watch, SIGNAL(finished()), this, SLOT(postFetchItems()));
  showMaximized();
}

void SaleStockOutWnd::prepareUI() {
  QVBoxLayout *vBox = new QVBoxLayout;
  vBox->addWidget(createResultWidget());
  setLayout(vBox);

  setWindowTitle(tr("数据导出"));
}

QWidget *SaleStockOutWnd::createResultWidget() {
  QLabel *lfrom = new QLabel(tr("开始日期"));
  lfrom->setAlignment(Qt::AlignRight | Qt::AlignCenter);
  QLabel *lto = new QLabel(tr("结束日期"));
  lto->setAlignment(Qt::AlignRight | Qt::AlignCenter);

  // 默认之前一个星期；
  QDate t1, t2;
  t2 = QDate::currentDate();
  t1 = t2.addDays(-7);

  dtePPFrom = new QDateTimeEdit(t1);
  dtePPFrom->setCalendarPopup(true);
  dtePPFrom->setDisplayFormat(dateFormat);

  dtePPTo = new QDateTimeEdit(t2);
  dtePPTo->setCalendarPopup(true);
  dtePPTo->setDisplayFormat(dateFormat);

  QLabel *lblInv = new QLabel(tr("物料"));
  lblInv->setAlignment(Qt::AlignRight | Qt::AlignCenter);
  QLabel *lblItem = new QLabel(tr("仓库"));
  lblItem->setAlignment(Qt::AlignRight | Qt::AlignCenter);
  lePPInv = new QLineEdit;
  lePPItem = new QLineEdit;

  btnPPSearch = new QPushButton(tr("查找"));
  QPushButton *btnPPExport = new QPushButton(tr("导出"));

  connect(btnPPSearch, &QPushButton::clicked, this,
          &SaleStockOutWnd::btnSearchClicked);

  connect(btnPPExport, &QPushButton::clicked,
          [this]() { exportTableView(tvPP); });

  QHBoxLayout *hlayout = new QHBoxLayout;
  hlayout->addWidget(lfrom);
  hlayout->addWidget(dtePPFrom);
  hlayout->addWidget(lto);
  hlayout->addWidget(dtePPTo);
  hlayout->addWidget(lblInv);
  hlayout->addWidget(lePPInv);
  hlayout->addWidget(lblItem);
  hlayout->addWidget(lePPItem);
  hlayout->addWidget(btnPPSearch);
  hlayout->addWidget(btnPPExport);

  tvPP = new QTableView;
  tvPP->setStyleSheet("font: 8pt 微软雅黑;");
  ppModel = new QStandardItemModel;

  // 形成 model: 标题
  QStringList headers;
  headers << "发货单号"
          << "销售订单号"
          << "审核日期"
          << "审核人"
          << "记账人"
          << "仓库"
          << "出库日期"
          << "出库单号"
          << "出库类别"
          << "部门"
          << "业务员"
          << "(无列名)"
          << "制单人"
          << "备注"
          << "项目编码"
          << "存货编码"
          << "存货名称"
          << "规格型号"
          << "主计量单位"
          << "数量"
          << "单价"
          << "金额";

  colCnt = headers.length() - 1;

  ppModel->setHorizontalHeaderLabels(headers);
  tvPP->setModel(ppModel);

  QVBoxLayout *vBox = new QVBoxLayout;
  vBox->addLayout(hlayout);
  vBox->addWidget(tvPP);

  QWidget *w = new QWidget;
  w->setLayout(vBox);

  return w;
}

void SaleStockOutWnd::exportTableView(QTableView *view) {
  QString fileName = QFileDialog::getSaveFileName(
      this, "保存",
      QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation),
      "Excel 文件(*.xlsx)");

  if (fileName != "") {
    bool ok = ExcelApp::instance()->exportTableView(view, fileName);
    if (ok) {
      QMessageBox::information(this, tr("导出"), tr("导出完毕"));
    }
  }
}

void SaleStockOutWnd::btnSearchClicked() {
  // 从 UI 取得用户输入的查询条件；
  QString dteFrom = dtePPFrom->date().toString(dateFormat);
  QString dteTo = dtePPTo->date().toString(dateFormat);

  QString invName = lePPInv->text().trimmed();
  QString itemName = lePPItem->text().trimmed();

  // 和 sql 对应
  QStringList condList;

  // 出库时间
  condList.append(
      QString(" and (dDate >= '%1' and dDate < '%2')").arg(dteFrom, dteTo));

  // 物料号
  QString cond2 = "";
  if (invName.length() > 0) {
    condList.append(
        QString(" and (c.cInvCode like '%%1%' or c.cInvName like '%%1%')")
            .arg(invName));
  }

  // 仓库号
  QString cond3 = "";
  if (itemName.length() > 0) {
    condList.append(QString(" and (b.cWhCode = '%1') ").arg(itemName));
  }

  QString cond = condList.join(" ");
  QString sqlTemplate = loadSqlCmd("15.sql");
  QString sqlCmd = sqlTemplate.arg(cond);

  qDebug() << "temp: " << sqlTemplate << "\ncmd: " << sqlCmd;

  QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));
  btnPPSearch->setEnabled(false);

  QFuture<void> future =
      QtConcurrent::run([this, sqlCmd]() { fetchItems(sqlCmd); });

  watch.setFuture(future);
}

void SaleStockOutWnd::fetchItems(const QString &sqlCmd) {
  QSqlDatabase db = QSqlDatabase::database(CONN_SRC);
  QSqlQuery query(db);
  query.setForwardOnly(true);
  query.prepare(sqlCmd);

  bool ok = query.exec();

  if (!ok) {
    QSqlError error = db.lastError();
    qDebug() << "Filed: btnSearchClicked "
             << QString("err: %1").arg(error.text());
    return;
  }

  allItems.clear();
  while (query.next()) {
    QStringList item;

    // 不同列的处理
    for (int c = 0; c <= colCnt; c++) {
      if ((c == 2) || (c == 6)) {
        // 日期类型
        item.push_back(query.value(c).toDate().toString(dateFormat));
      } else if (c >= 19 && c <= 21) {
        // 数字类型
        item.push_back(QString::number(query.value(c).toDouble(), 10, 4));
      } else {
        // 字符类型
        item.push_back(query.value(c).toString());
      }
    }

    allItems.push_back(item);
  }
}

void SaleStockOutWnd::postFetchItems() {
  QStandardItemModel *model = ppModel;
  QTableView *tableView = tvPP;

  tableView->setUpdatesEnabled(false);

  // 把结果集，显示在tableview 中；
  // 结果集中都是字符；
  model->removeRows(0, model->rowCount());
  int row = 0;
  for (const auto &it : allItems) {
    for (int c = 0; c <= colCnt; c++) {
      model->setItem(row, c, new QStandardItem(it.at(c)));
    }

    row++;
  }

  tableView->resizeColumnsToContents();
  tableView->setUpdatesEnabled(true);

  btnPPSearch->setEnabled(true);
  QApplication::restoreOverrideCursor();

  QMessageBox::information(this, tr(""), tr("执行完毕"));
}

#include "moc_salestockoutwnd.cpp"



=== soiteminfo.cpp 
#include "soiteminfo.h"

SoItemInfo::SoItemInfo() {}

bool SoItemInfo::operator<(const SoItemInfo &i) const {
  return (this->soItem.iSOsID < i.soItem.iSOsID);
}

// 传入的是第一天，对应的 offset 是 0；
void SoItemInfo::calcOffset(const QDate &base) {
  QString format = "yyyy-MM-dd";
  QDate dtCurr = QDate::fromString(soRd.dDate, format);

  if (dtCurr.isValid()) {
    rdsOffset = base.daysTo(dtCurr);
  } else {
    // base 一定是合法的日期，但是 dtCurr 不一定；
    // 对于只有订单行项目，还没有发货的的记录， soRd.dDate 是空
    rdsOffset = 0;
  }
}

void SoItemInfo::initRdItems(int size) {
  rdItems = std::vector<int>(size, 0);
  planItems = std::vector<int>(size, 0);
}

void SoItemInfo::calcTotalQty() {
  // 实际发货累计值
  totalQty = 0;
  for (auto i : rdItems) {
    totalQty += i;
  }

  // 计划发货累计值
  totalPlanQty = 0;
  for (auto i : planItems) {
    totalPlanQty += i;
  }
}

bool sortByCustAndDate(const SoItemInfo &a, const SoItemInfo &b) {
  // 先按照客户，升序排；
  // 再按照订单时间，从前向后排；
  // 在按照订单行项目排序；
  //  if (a.soHeader.cCusName.compare(a.soHeader.cCusName) != 0) {
  //    // 按升序排
  //    return a.soHeader.cCusName < a.soHeader.cCusName;
  //  } else {
  //    if (a.soHeader.dDate.compare(b.soHeader.dDate) != 0) {
  //      return a.soHeader.dDate < b.soHeader.dDate;
  //    } else {
  //      return a.soItem.iSOsID < b.soItem.iSOsID;
  //    }
  //  }

  QString v1 =
      a.soHeader.cCusName + a.soHeader.dDate + QString::number(a.soItem.iSOsID);
  QString v2 =
      b.soHeader.cCusName + b.soHeader.dDate + QString::number(b.soItem.iSOsID);
  return v1 < v2;
}



=== soitemplan.cpp 
#include "soitemplan.h"

SoItemPlan::SoItemPlan() {}

void SoItemPlan::calcOffset(const QDate &base) {
  QString format = "yyyy-MM-dd";
  QDate dtCurr = QDate::fromString(dDate, format);

  if (dtCurr.isValid()) {
    offset = base.daysTo(dtCurr);
  } else {
    // base 一定是合法的日期，但是 dtCurr 不一定；
    // 对于只有订单行项目，还没有发货的的记录， soRd.dDate 是空
    offset = 0;
  }
}

bool SoItemPlan::operator<(const SoItemPlan &i) const {
  return (this->iSOsID < i.iSOsID);
}



=== soitemrdswnd.cpp 
﻿#include "soitemrdswnd.h"

#include "excelapp.h"
#include "freezetablewidget.h"
#include "global.h"
#include "soiteminfo.h"
#include "soitemplan.h"
#include <QtConcurrent>

#include <QtSql>

SoItemRdsWnd::SoItemRdsWnd(QWidget *parent) : QWidget(parent) {
  setupUI();

  // 加载完数据后的回调函数；
  connect(&buildModelOpenWatcher, SIGNAL(finished()), this,
          SLOT(postBuildModelOpen()));

  connect(&buildModelWatcher, SIGNAL(finished()), this, SLOT(postBuildModel()));
}

void SoItemRdsWnd::setupUI() {
  // 设置初始日期
  // 当月日期小于26，取上月26；否则，本月26
  QDate t1, t2;
  initDateRange(t1, t2);

  // 已发货查询
  // 上面是查询条件，下面是 tableview
  QLabel *labelFrom = new QLabel(tr("发货日期-起"));
  dteFrom = new QDateTimeEdit(t1);
  dteFrom->setCalendarPopup(true);
  dteFrom->setDisplayFormat(dateFormat);

  QLabel *labelTo = new QLabel(tr("发货日期-止"));
  dteTo = new QDateTimeEdit(t2);
  dteTo->setCalendarPopup(true);
  dteTo->setDisplayFormat(dateFormat);

  QLabel *labelCustomer = new QLabel(tr("客户"));
  leCustomer = new QLineEdit;

  QLabel *labelMaterial = new QLabel(tr("物料"));
  leMaterial = new QLineEdit;

  QLabel *labelOrder = new QLabel(tr("订单"));
  leOrderNo = new QLineEdit;

  chkPrimary = new QCheckBox("仅控制器电机");
  chkPrimary->setChecked(true);

  btnSearch = new QPushButton(tr("查看"));
  connect(btnSearch, &QPushButton::clicked, this,
          &SoItemRdsWnd::btnSearchClicked);

  QGridLayout *grid = new QGridLayout;
  grid->addWidget(labelFrom, 0, 0, 1, 1);
  grid->addWidget(dteFrom, 0, 1, 1, 1);
  grid->addWidget(labelTo, 0, 2, 1, 1);
  grid->addWidget(dteTo, 0, 3, 1, 1);
  grid->addWidget(labelCustomer, 0, 4, 1, 1);
  grid->addWidget(leCustomer, 0, 5, 1, 1);
  grid->addWidget(labelMaterial, 0, 6, 1, 1);
  grid->addWidget(leMaterial, 0, 7, 1, 1);
  grid->addWidget(labelOrder, 0, 8, 1, 1);
  grid->addWidget(leOrderNo, 0, 9, 1, 1);
  grid->addWidget(chkPrimary, 0, 10, 1, 1);
  grid->addWidget(btnSearch, 0, 11, 1, 1);

  //  initTableView(tvDetails);
  soItemModel = new QStandardItemModel;
  tvDetails = new FreezeTableWidget(soItemModel);
  tvDetails->setStyleSheet("font: 8pt 宋体;");
  tvDetails->setMouseTracking(true);
  //  tvDetails->setEditTriggers(QAbstractItemView::NoEditTriggers);
  connect(tvDetails, SIGNAL(entered(QModelIndex)), this,
          SLOT(showToolTip(QModelIndex)));

  QItemSelectionModel *selectionRds = tvDetails->selectionModel();
  connect(selectionRds, &QItemSelectionModel::currentChanged, this,
          &SoItemRdsWnd::currentChangedRds);

  QPushButton *btnExport = new QPushButton(tr("导出"));
  connect(btnExport, &QPushButton::clicked, this,
          [this]() { this->exportTableView(this->tvDetails); });

  QVBoxLayout *vlay = new QVBoxLayout;
  vlay->addLayout(grid);
  vlay->addWidget(tvDetails);
  vlay->addWidget(btnExport);

  QWidget *hasRdsWidget = new QWidget();
  hasRdsWidget->setLayout(vlay);

  // 当前未清订单查询、
  // 上面是查询条件，下面是 tableview
  QLabel *labelFromOpen = new QLabel(tr("发货计划-起"));
  dteOpenFrom = new QDateTimeEdit(t1);
  dteOpenFrom->setCalendarPopup(true);
  dteOpenFrom->setDisplayFormat(dateFormat);

  QLabel *labelToOpen = new QLabel(tr("发货计划-止"));
  dteOpenTo = new QDateTimeEdit(t2);
  dteOpenTo->setCalendarPopup(true);
  dteOpenTo->setDisplayFormat(dateFormat);

  QLabel *labelCustomerOpen = new QLabel(tr("客户"));
  leOpenCustomer = new QLineEdit;

  QLabel *labelMaterialOpen = new QLabel(tr("物料"));
  leOpenMaterial = new QLineEdit;

  QLabel *labelOpenOrder = new QLabel(tr("订单"));
  leOpenOrderNo = new QLineEdit;

  chkOpenPrimary = new QCheckBox("仅控制器电机");
  chkOpenPrimary->setChecked(true);

  btnSearchOpen = new QPushButton(tr("查找未清"));
  connect(btnSearchOpen, &QPushButton::clicked, this,
          &SoItemRdsWnd::btnSearchOpenClicked);

  QGridLayout *g2 = new QGridLayout;
  g2->addWidget(labelFromOpen, 0, 0, 1, 1);
  g2->addWidget(dteOpenFrom, 0, 1, 1, 1);
  g2->addWidget(labelToOpen, 0, 2, 1, 1);
  g2->addWidget(dteOpenTo, 0, 3, 1, 1);
  g2->addWidget(labelCustomerOpen, 0, 4, 1, 1);
  g2->addWidget(leOpenCustomer, 0, 5, 1, 1);
  g2->addWidget(labelMaterialOpen, 0, 6, 1, 1);
  g2->addWidget(leOpenMaterial, 0, 7, 1, 1);
  g2->addWidget(labelOpenOrder, 0, 8, 1, 1);
  g2->addWidget(leOpenOrderNo, 0, 9, 1, 1);
  g2->addWidget(chkOpenPrimary, 0, 10, 1, 1);
  g2->addWidget(btnSearchOpen, 0, 11, 1, 1);

  //  initTableView(tvOpens);
  soOpenModel = new QStandardItemModel;
  tvOpens = new FreezeTableWidget(soOpenModel);
  tvOpens->setStyleSheet("font: 8pt 宋体;");
  tvOpens->setMouseTracking(true);
  //  tvOpens->setEditTriggers(QAbstractItemView::NoEditTriggers);
  connect(tvOpens, SIGNAL(entered(QModelIndex)), this,
          SLOT(showToolTip(QModelIndex)));

  // currentChanged 是 protect，不能访问
  //  connect(tvOpens, &QTableView::currentChanged, this,
  //          &SoItemRdsWnd::dataChangedOpen);

  // 只要对 model 赋值，就会触发，不是想要的；
  //  connect(soOpenModel, &QStandardItemModel::itemChanged, this,
  //          &SoItemRdsWnd::itemChanged);

  QItemSelectionModel *selectionOpen = tvOpens->selectionModel();
  connect(selectionOpen, &QItemSelectionModel::currentChanged, this,
          &SoItemRdsWnd::currentChangedOpen);

  QPushButton *btnExportOpen = new QPushButton(tr("导出"));
  connect(btnExportOpen, &QPushButton::clicked, this,
          [this]() { this->exportTableView(this->tvOpens); });

  QVBoxLayout *v2 = new QVBoxLayout;
  v2->addLayout(g2);
  v2->addWidget(tvOpens);
  v2->addWidget(btnExportOpen);

  QWidget *openWidget = new QWidget();
  openWidget->setLayout(v2);

  // 两个 tab，一是 未清项，一是 已发货记录
  tabWidget = new QTabWidget;
  tabWidget->addTab(openWidget, tr("未清项查询"));
  tabWidget->addTab(hasRdsWidget, tr("已发货查询"));

  QVBoxLayout *vMain = new QVBoxLayout;
  vMain->addWidget(tabWidget);

  setLayout(vMain);
  setWindowTitle(tr("发货计划"));
  showMaximized();
}

void SoItemRdsWnd::initDateRange(QDate &from, QDate &to) {
  // 设置初始日期
  // 当月日期小于26，取上月26；否则，本月26
  QDate curr = QDate::currentDate();
  const int baseDay = 26;
  int day = curr.day();
  if (day < baseDay) {
    // 上个月
    QDate pre = curr.addDays(-1 * baseDay);
    from.setDate(pre.year(), pre.month(), baseDay);
  } else {
    from.setDate(curr.year(), curr.month(), baseDay);
  }

  // 设置结束日期，开始日期的下个月的 26 号；
  QDate next = from.addDays(baseDay);
  to.setDate(next.year(), next.month(), baseDay);
}

void SoItemRdsWnd::initTableView(QTableView *tableView) {
  // 未使用
  tableView = new QTableView;
  tableView->setStyleSheet("font: 8pt 宋体;");
  tableView->setMouseTracking(true);
  //  tableView->setEditTriggers(QAbstractItemView::NoEditTriggers);
}

void SoItemRdsWnd::btnSearchClicked() {
  QString from = dteFrom->date().toString(dateFormat);
  QString to = dteTo->date().toString(dateFormat);

  if ((from.length() == 0) || (to.length() == 0)) {
    QMessageBox::information(this, tr("发货信息"), tr("发货时间必须输入"));
    return;
  }

  // 时间跨度 92 天
  int d = dteFrom->date().daysTo(dteTo->date());
  if (d < 0 || d > 92) {
    QMessageBox::information(this, tr("发货信息"), tr("计划期间输入不合理"));
    return;
  }

  // 启动多线程，在多线程中，只操作数据，不做更新 UI
  btnSearch->setEnabled(false);
  QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));

  QFuture<void> future =
      QtConcurrent::run([this, from, to]() { buildModel(from, to); });
  buildModelWatcher.setFuture(future);

  //  buildModel(from, to);
}

void SoItemRdsWnd::btnExportClicked() { exportTableView(tvDetails); }

void SoItemRdsWnd::exportTableView(QTableView *tableView) {
  QString fileName = QFileDialog::getSaveFileName(
      this, "保存",
      QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation),
      "Excel 文件(*.xlsx)");

  if (fileName != "") {
    bool ok = ExcelApp::instance()->exportTableView(tableView, fileName);
    if (ok) {
      QMessageBox::information(this, tr("导出"), tr("导出完毕"));
    }
  }
}

// 实际发货时间：包含 fromStr，包含 toStr
void SoItemRdsWnd::buildModel(const QString &fromStr, const QString &toStr) {
  // 取得订单行项目的发货明细：
  // 在给定期间有发货记录，
  QString cmd = genSqlRds();

  soRdsItems = buildItems(cmd, fromStr, toStr, x_from, x_dayRange);
}

void SoItemRdsWnd::postBuildModel() {
  refreshResult(soRdsItems, x_from, x_dayRange, false);

  btnSearch->setEnabled(true);
  QApplication::restoreOverrideCursor();

  if (soRdsItems.size() > 0) {
    QMessageBox::information(this, tr("DJPLAN"), tr("查询完毕"));
  } else {
    QMessageBox::information(this, tr("DJPlan"), tr("无数据"));
  }
}

// isOpen = true 表示当前未清，否则，表示根据出库记录查询；
QString SoItemRdsWnd::buildCond(bool isOpen) {
  QString customer = "";
  QString material = "";
  QString order = "";
  QStringList conds;

  if (isOpen) {
    customer = leOpenCustomer->text().trimmed();
    material = leOpenMaterial->text().trimmed();
    order = leOpenOrderNo->text().trimmed();

    // 勾选了“只显示控制器电机”
    if (chkOpenPrimary->isChecked()) {
      conds << " and (sodetails.CINVNAME like '%-K%' or sodetails.CINVNAME "
               "like '%-D%') ";
    }
  } else {
    conds << " where 1 = 1 ";
    customer = leCustomer->text().trimmed();
    material = leMaterial->text().trimmed();
    order = leOrderNo->text().trimmed();

    if (chkPrimary->isChecked()) {
      conds << " and (sodetails.CINVNAME like '%-K%' or sodetails.CINVNAME "
               "like '%-D%') ";
    }
  }

  if (customer.length() > 0) {
    conds << " and somain.CCUSNAME like '%" << customer << "%' ";
  }
  if (material.length() > 0) {
    conds << " and ( (sodetails.CINVNAME like '%" << material
          << "%') or ( sodetails.CINVCODE like '%" << material << "%') ) ";
  }
  if (order.length() > 0) {
    conds << " and somain.CSOCODE like '%" << order << "%'";
  }

  return conds.join("");
}

void SoItemRdsWnd::btnSearchOpenClicked() {
  QString from = dteOpenFrom->date().toString(dateFormat);
  QString to = dteOpenTo->date().toString(dateFormat);

  if ((from.length() == 0) || (to.length() == 0)) {
    QMessageBox::information(this, tr("发货信息"), tr("计划期间必须输入"));
    return;
  }

  int d = dteOpenFrom->date().daysTo(dteOpenTo->date());
  if (d < 0 || d > 92) {
    QMessageBox::information(this, tr("发货信息"), tr("计划期间输入不合理"));
    return;
  }

  // 启动多线程，在多线程中，只操作数据，不做更新 UI
  btnSearchOpen->setEnabled(false);
  QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));

  QFuture<void> future =
      QtConcurrent::run([this, from, to]() { buildModelOpen(from, to); });
  buildModelOpenWatcher.setFuture(future);
}

void SoItemRdsWnd::btnExportOpenClicked() { exportTableView(tvOpens); }

// 查看当前时刻没有完全发货的记录；
void SoItemRdsWnd::buildModelOpen(const QString &fromStr,
                                  const QString &toStr) {
  QString cmd = genSqlOpen();
  soOpenItems = buildItems(cmd, fromStr, toStr, x_from, x_dayRange);
}

void SoItemRdsWnd::postBuildModelOpen() {
  refreshResult(soOpenItems, x_from, x_dayRange, true);

  btnSearchOpen->setEnabled(true);
  QApplication::restoreOverrideCursor();

  if (soOpenItems.size() > 0) {
    QMessageBox::information(this, tr("DJPlan"), tr("查询完毕"));
  } else {
    QMessageBox::information(this, tr("DJPlan"), tr("无数据"));
  }
}

void SoItemRdsWnd::fetchPlanData(std::vector<SoItemInfo> &soItems,
                                 const QString &fromStr, const QString &toStr) {
  // 简化版：只按照时间取，不限制别的属性；
  // 理想下，需要加上销售订单行项目号的限制；
  QSqlDatabase db = QSqlDatabase::database(CONN_TARGET);
  QSqlQuery query(db);

  QString cmdPlan = "select SOHeaderID, iSOsID, dDate, iQuantity, RMK from "
                    "SO_SODETAILSPLAN where "
                    " DDATE >= :from and DDATE < :to; ";

  query.prepare(cmdPlan);
  query.bindValue(":from", fromStr);
  query.bindValue(":to", toStr);
  bool ok = query.exec();

  if (!ok) {
    QSqlError error = db.lastError();
    qDebug() << QString("Failed: %1").arg(cmdPlan)
             << QString("from: %1, to: %2: err: %3")
                    .arg(fromStr, toStr, error.text());
    return;
  }

  std::vector<SoItemPlan> soPlanItems;

  while (query.next()) {
    SoItemPlan i;
    i.SOHeaderID = query.value(0).toLongLong();
    i.iSOsID = query.value(1).toLongLong();
    i.dDate = query.value(2).toString();
    i.iQuantity = query.value(3).toInt();
    i.RMK = query.value(4).toString();
    soPlanItems.push_back(i);
  }

  // 排序
  std::sort(soPlanItems.begin(), soPlanItems.end());

  // 计算计划日期，相对于查询日期的 offset
  QDate from = QDate::fromString(fromStr, dateFormat);
  for (auto &i : soPlanItems) {
    i.calcOffset(from);
  }

  // 把计划值，按照 offset，转换成列
  // soItems 不是汇总自 soPlanItems，
  // 一次循环需要考虑比较多的因素，所以直接两层循环；
  for (auto &i : soItems) {
    long idMaster = i.soItem.iSOsID;
    for (const auto &j : soPlanItems) {
      long idDetail = j.iSOsID;
      if (idMaster == idDetail) {
        int offset = j.offset;
        i.planItems[offset] += j.iQuantity;
      }
    }
  }
}

QString SoItemRdsWnd::genSqlRds() {
  // 查询期间内的出库明细
  // mysql
  //  QString cmd = "select  somain.CCUSNAME,somain.CSOCODE, somain.DDATESODate,
  //  "
  //                "sodetails.ISOSID, sodetails.CINVCODE, sodetails.CINVNAME, "
  //                "sodetails.IQUANTITY, "
  //                "sodetails.IFHQUANTITY, "
  //                "        rd.DDATE rdDate, rds.IQUANTITY "
  //                "  from rdrecord32 rd "
  //                "inner join rdrecords32 rds "
  //                "  on rds.RDRECORDID = rd.RDRECORDID "
  //                " and (rd.DDATE >= :from and rd.DDATE < :to) "
  //                " inner join so_sodetails sodetails "
  //                "  on rds.ISOSID = sodetails.ISOSID "
  //                " inner join so_somain somain "
  //                "  on somain.SOHEADERID = sodetails.SOHEADERID ";

  // 直接 U8
  QString cmd =
      "select  somain.CCUSNAME,somain.CSOCODE, somain.DDATE SODate, "
      "sodetails.ISOSID, sodetails.CINVCODE, sodetails.CINVNAME, "
      "sodetails.IQUANTITY, "
      "sodetails.IFHQUANTITY, "
      "rd.DDATE rdDate, rds.IQUANTITY "
      "  from rdrecord32 rd "
      " inner join rdrecords32 rds on rds.ID = rd.ID "
      " and (rd.DDATE >= :from and rd.DDATE < :to) "
      " left join DispatchLists dls  on rds.iDLsID = dls.iDLsID "
      " inner join so_sodetails sodetails   on dls.ISOSID = sodetails.ISOSID "
      " inner join so_somain somain on somain.ID = sodetails.ID ";

  QString cond = this->buildCond();

  qDebug() << "genSqlRds: " << cmd + cond;
  return cmd + cond;
}

QString SoItemRdsWnd::genSqlOpen() {
  // 当前时刻，未发完货的订单行项目：
  // mysql
  //  QString cmd =
  //      "select  somain.CCUSNAME, somain.CSOCODE, somain.DDATE SODate,  "
  //      " sodetails.ISOSID, sodetails.CINVCODE, sodetails.CINVNAME, "
  //      "sodetails.IQUANTITY, "
  //      " sodetails.IFHQUANTITY, "
  //      " ifnull(rd.DDATE, \"\") rdDate, ifnull(rds.IQUANTITY, 0) IQUANTITY "
  //      "  from so_sodetails sodetails "
  //      "  inner join so_somain somain "
  //      "  on somain.SOHEADERID = sodetails.SOHEADERID "
  //      " and sodetails.IQUANTITY <> sodetails.IFHQUANTITY "
  //      " left join rdrecords32 rds "
  //      " on rds.ISOSID = sodetails.ISOSID "
  //      " left join rdrecord32 rd "
  //      "  on rds.RDRECORDID = rd.RDRECORDID "
  //      " where ( (isnull(rd.DDATE)) or (rd.DDATE >= :from and rd.DDATE <
  //      :to)) ";

  // 直接 U8
  QString cmd =
      " select  somain.CCUSNAME, somain.CSOCODE, somain.DDATE SODate,  "
      " sodetails.ISOSID, sodetails.CINVCODE, sodetails.CINVNAME, "
      " sodetails.IQUANTITY, "
      " sodetails.IFHQUANTITY, "
      " rd.DDATE rdDate, isnull(rds.IQUANTITY, 0) IQUANTITY"
      "  from so_sodetails sodetails "
      "  inner join so_somain somain "
      "  on somain.ID = sodetails.ID "
      " and sodetails.IQUANTITY <> sodetails.IFHQUANTITY "
      " left join DispatchLists dls on dls.ISOSID = sodetails.ISOSID "
      " left join rdrecords32 rds on rds.iDLsID = dls.iDLsID "
      " left join rdrecord32 rd   on rds.ID = rd.ID "
      " where ((rd.DDATE is null) or (rd.DDATE >= :from and rd.DDATE < :to)) ";

  QString cond = this->buildCond(true);

  qDebug() << "genSqlOpen: " << cmd + cond;
  return cmd + cond;
}

std::vector<SoItemInfo> SoItemRdsWnd::buildItems(const QString &cmd,
                                                 const QString &fromStr,
                                                 const QString &toStr,
                                                 QDate &from, int &dayRange) {
  std::vector<SoItemInfo> soItemRds;

  QSqlDatabase db = QSqlDatabase::database(CONN_SRC);
  QSqlQuery query(db);
  query.prepare(cmd);
  query.bindValue(":from", fromStr);
  query.bindValue(":to", toStr);
  bool ok = query.exec();

  if (!ok) {
    QSqlError error = db.lastError();
    qDebug() << QString("Failed: %1").arg(cmd)
             << QString("from: %1, to: %2: err: %3")
                    .arg(fromStr, toStr, error.text());

    // 返回一个长度是 0 的 vector；
    return soItemRds;
  }

  while (query.next()) {
    SoItemInfo i;
    i.soHeader.cCusName = query.value(0).toString();
    i.soHeader.cSOCode = query.value(1).toString();
    i.soHeader.dDate = query.value(2).toDate().toString(dateFormat);
    i.soItem.iSOsID = query.value(3).toLongLong();
    i.soItem.cInvCode = query.value(4).toString();
    i.soItem.cInvName = query.value(5).toString();
    i.soItem.iQuantity = query.value(6).toInt();
    i.soItem.iFHQuantity = query.value(7).toInt();
    i.soRd.dDate = query.value(8).toDate().toString(dateFormat);
    i.soRdItem.iQuantity = query.value(9).toInt();
    soItemRds.push_back(i);
  }

  int rdsCnt = (int)soItemRds.size();
  if (rdsCnt == 0) {
    // 返回一个长度是 0 的 vector；
    return soItemRds;
  }

  // 按照 订单行项目编号 排序，加速后续计算；
  std::sort(soItemRds.begin(), soItemRds.end());

  // 取得 unique 的订单行项目
  // 订单行项目号 如果和上一条不一样，表示是新的订单行项目；
  // 否则，就是已有的 订单行项目
  std::vector<SoItemInfo> soItems;
  SoItemInfo p = soItemRds.at(0);
  soItems.push_back(p);

  for (int i = 1; i < rdsCnt; i++) {
    SoItemInfo c = soItemRds.at(i);
    if (p.soItem.iSOsID != c.soItem.iSOsID) {
      soItems.push_back(c);
    }
    p = c;
  }

  // 按照 订单行项目号 排序，加速后续计算
  std::sort(soItems.begin(), soItems.end());

  // 输入参数为计划周期，所以以输入参数为准，计算跨度；
  QString dtFormat = "yyyy-MM-dd";
  from = QDate::fromString(fromStr, dtFormat);
  QDate to = QDate::fromString(toStr, dtFormat);
  // 包含开始，不包含结束
  dayRange = from.daysTo(to);

  // 以最小时间为基准，计算订单发货明细中的 offset；
  for (auto &i : soItemRds) {
    i.calcOffset(from);
  }

  // 把订单行项目的发货明细，对应到订单行项目的不同列上；

  // 按照 订单行项目编号 排序，加速后续计算；
  std::sort(soItemRds.begin(), soItemRds.end());
  std::sort(soItems.begin(), soItems.end());

  // 按照 offset 行转列；
  // soItems: 一个订单行项目一行
  // soItemRds: 订单行项目的发货明细，一个订单行项目对应多行；通过 订单行项目号
  // 和 订单行项目 关联；
  int lastStop = 0;
  for (auto &i : soItems) {
    i.initRdItems(dayRange);

    long idMaster = i.soItem.iSOsID;
    while (lastStop < rdsCnt) {
      const SoItemInfo &d = soItemRds.at(lastStop);

      long idDetail = d.soItem.iSOsID;
      int offset = d.rdsOffset;
      if (idMaster == idDetail) {
        i.rdItems[offset] += d.soRdItem.iQuantity;
        lastStop++;
      } else {
        break;
      }
    }
  }

  // 取出计划值，并且把计划值也按列展示
  fetchPlanData(soItems, fromStr, toStr);

  // 计算期间累计值，实际和计划都需要，所以合并在一起；
  for (auto &i : soItems) {
    i.calcTotalQty();
  }

  // 返回一个排好序的
  std::sort(soItems.begin(), soItems.end(), sortByCustAndDate);

  appendSum(soItems);
  return soItems;
}

// 按照控制器，电机汇总
void SoItemRdsWnd::appendSum(std::vector<SoItemInfo> &items) {
  // 根据编码规则判定：控制器 -K；电机 -M
  if (items.size() == 0) {
    // 如果长度为零，直接返回；
    return;
  }

  SoItemInfo sumK;
  sumK.totalPlanQty = 0;
  sumK.totalQty = 0;
  sumK.soHeader.cCusName = tr("汇总");
  sumK.soItem.cInvName = tr("控制器");

  SoItemInfo sumM;
  sumM.totalPlanQty = 0;
  sumM.totalQty = 0;
  sumM.soHeader.cCusName = tr("汇总");
  sumM.soItem.cInvName = tr("电机");

  // 取得数据的总长度；
  int size = static_cast<int>(items.at(0).rdItems.size());
  sumK.initRdItems(size);
  sumM.initRdItems(size);

  SoItemInfo *p = nullptr;
  for (auto &i : items) {
    QString invName = i.soItem.cInvName;
    if (invName.contains("-K")) {
      p = &sumK;
    } else if (invName.contains("-D")) {
      p = &sumM;
    } else {
      p = nullptr;
    }

    if (p) {
      // 汇总明细，需要汇总的字段，要和tableview中显示的字段对应
      p->totalQty += i.totalQty;
      p->totalPlanQty += i.totalPlanQty;
      p->soItem.iQuantity += i.soItem.iQuantity;
      p->soItem.iFHQuantity += i.soItem.iFHQuantity;
      for (int idx = 0; idx < size; idx++) {
        p->rdItems[idx] += i.rdItems[idx];
        p->planItems[idx] += i.planItems[idx];
      }
    }
  }

  // 把汇总数据，加回到列表中
  items.push_back(sumK);
  items.push_back(sumM);
}

// isOpen = true: 查看当前未清订单；
// isOpen = false: 按照实际出库日期，查看；
void SoItemRdsWnd::refreshResult(const std::vector<SoItemInfo> &items,
                                 const QDate &from, int dayRange, bool isOpen) {
  if (items.size() == 0) {
    return;
  }

  // 默认是当前未清项；
  FreezeTableWidget *view = tvOpens;
  QStandardItemModel *model = soOpenModel;
  if (!isOpen) {
    view = tvDetails;
    model = soItemModel;
  }

  // 形成 model: 内容
  view->setUpdatesEnabled(false);
  model->clear();

  int row = 0;
  for (auto &i : items) {
    // 两个版本：实际 0， 计划 1
    for (int v = 0; v <= 1; v++) {
      model->setItem(row, 0, new QStandardItem(i.soHeader.cCusName));
      model->setItem(row, 1, new QStandardItem(i.soItem.cInvName));
      model->setItem(row, 2, new QStandardItem(i.soItem.cInvCode));
      model->setItem(row, 3, new QStandardItem(i.soHeader.cSOCode));
      model->setItem(row, 4, new QStandardItem(i.soHeader.dDate));

      if (v == 0) {
        // 实际值
        model->setItem(row, 5, new QStandardItem(tr("实际")));

        model->setItem(row, 6,
                       new QStandardItem(QString::number(i.soItem.iQuantity)));
        model->setItem(
            row, 7, new QStandardItem(QString::number(i.soItem.iFHQuantity)));

        model->setItem(row, 8, new QStandardItem(QString::number(i.totalQty)));

        for (int c = 0; c < dayRange; c++) {
          int col = c + 9;
          int v = i.rdItems[c];
          // 等于 0 就不显示
          if (v != 0) {
            model->setItem(row, col, new QStandardItem(QString::number(v)));
          } else {
            model->setItem(row, col, new QStandardItem(""));
          }
        }
      } else if (v == 1) {
        // 计划值
        model->setItem(row, 5, new QStandardItem(tr("计划")));

        model->setItem(row, 6, new QStandardItem(""));
        model->setItem(row, 7, new QStandardItem(""));

        // 计划值合计，每次更新计划时，需要更新这里；
        model->setItem(row, 8,
                       new QStandardItem(QString::number(i.totalPlanQty)));

        for (int c = 0; c < dayRange; c++) {
          int col = c + 9;
          int v = i.planItems[c];
          if (v != 0) {
            model->setItem(row, col, new QStandardItem(QString::number(v)));
          } else {
            model->setItem(row, col, new QStandardItem(""));
          }
        }
      }

      row++;
    }
  }

  // 形成 model: 标题
  QStringList headers;
  headers << "客户"
          << "物料名称"
          << "料号"
          << "订单号"
          << "订单日期"
          << "版本"
          << "数量"
          << "迄今"
          << "期间";

  for (int c = 0; c < dayRange; c++) {
    QDate d = from.addDays(c);
    int day = d.day();
    headers << QString::number(day);
  }

  model->setHorizontalHeaderLabels(headers);
  // 固定前两列
  view->resetModel(model, 2);
  view->resizeColumnsToContents();

  const int fixed = 9;
  const int colWidth = 48;
  for (int c = 0; c < dayRange; c++) {
    view->setColumnWidth(fixed + c, colWidth);
  }

  view->setUpdatesEnabled(true);
}

void SoItemRdsWnd::showToolTip(const QModelIndex &index) {
  if (!index.isValid()) {
    qDebug() << "Invalid index";
    return;
  }

  QMap<int, QString> tips;
  tips.insert(5, tr("销售订单行项目数量"));
  tips.insert(6, tr("迄今的发货单数量"));
  tips.insert(7, tr("查询期间内的仓库出库数量"));

  int col = index.column();
  if (tips.contains(col)) {
    QToolTip::showText(QCursor::pos(), tips.value(col));
  }
}

void SoItemRdsWnd::currentChangedRds(const QModelIndex &current,
                                     const QModelIndex &previous) {
  Q_UNUSED(current);

  currentChangedDo(previous, false);
}

void SoItemRdsWnd::currentChangedOpen(const QModelIndex &current,
                                      const QModelIndex &previous) {
  Q_UNUSED(current);

  currentChangedDo(previous, true);
}

void SoItemRdsWnd::currentChangedDo(const QModelIndex &index, bool isOpen) {
  const int startCol = 9;
  // 计划开始的列(包括这一列)，前面的列都是订单行项目的属性；
  int idxCol = index.column() - startCol;
  bool isPlanCol = (idxCol >= 0);

  // 每个订单行项目有两行，第一行是实际，第二行是计划
  // index 都是从 0 开始；
  bool isPlanRow = (index.row() % 2 == 1);

  if (isPlanCol && isPlanRow) {
    if (isOpen) {
      changePlan(soOpenModel, soOpenItems, index, dteOpenFrom->date());
    } else {
      changePlan(soItemModel, soRdsItems, index, dteFrom->date());
    }
  }
}

void SoItemRdsWnd::changePlan(QStandardItemModel *model,
                              std::vector<SoItemInfo> &items,
                              const QModelIndex &index, const QDate &baseDate) {

  const int startCol = 9;
  // 计划开始的列(包括这一列)，前面的列都是订单行项目的属性；
  int idxCol = index.column() - startCol;

  // 每个订单行项目有两行，第一行是实际，第二行是计划
  // index 都是从 0 开始；
  int idxRow = (int)(index.row() / 2);

  QStandardItem *item = model->itemFromIndex(index);
  QString val = item->text();
  // 如果是空的，就是零；
  if (val.length() == 0) {
    val = "0";
  }

  qDebug() << QString("(%1, %2): %3")
                  .arg(QString::number(index.row()),
                       QString::number(index.column()), val);

  bool ok;
  int newQty = val.toInt(&ok);
  if (!ok) {
    QMessageBox::information(this, tr("JDPlan"), tr("请输入数字"));

    // 目的是想阻止改变
    // 这样不行，会进入死循环
    //      tvOpens->selectionModel()->setCurrentIndex(previous,
    //                                                 QItemSelectionModel::Current);

    return;
  }

  // 把 plan 存入数据库

  // 对应的日期：基准日期 + offset；
  QString dDate = baseDate.addDays(idxCol).toString(dateFormat);

  // 对应的订单，返回一个 ref，因为需要做更新
  SoItemInfo &it = items.at(idxRow);

  // 旧值，返回一个 ref，因为需要做更新
  int &oldQty = it.planItems.at(idxCol);

  if (newQty == 0) {
    // 如果新值为零，则直接把旧值删除
    deletePlan(it, dDate);
  } else {
    if (oldQty == 0) {
      // 如果没有旧值，则插入新值；
      insertPlan(it, dDate, newQty);
    } else if (oldQty == newQty) {
      // 如果旧值和新值相同，不做任何处理；
    } else {
      // 如果旧值和新值不同，更新旧值；
      updatePlan(it, dDate, newQty);
    }
  }

  // 手工更新 model 的汇总列
  const int colSum = 8;
  QModelIndex idxSum = index.sibling(index.row(), colSum);
  QStandardItem *itmSum = model->itemFromIndex(idxSum);

  int diff = itmSum->text().toInt() - oldQty + newQty;
  itmSum->setText(QString::number(diff));

  // 由于没有重新查询数据库，所以需要更新内存中的数据；
  // 如果多人同时对同一个计划做修改，那还是重新全部从数据库加载比较容易；
  // oldQty 是个 ref, 所以可以直接更改；
  oldQty = newQty;
}

void SoItemRdsWnd::deletePlan(const SoItemInfo &it, const QString &dDate) {
  QSqlDatabase dbTarget = QSqlDatabase::database(CONN_TARGET);
  QSqlQuery query(dbTarget);
  QSqlError error;
  QString cmd;

  cmd =
      "delete from SO_SODETAILSPLAN where DDATE = :dDate and ISOSID = :ISOSID;";
  query.prepare(cmd);
  query.bindValue(":dDate", dDate);
  query.bindValue(":ISOSID", it.soItem.iSOsID);

  bool ok = query.exec();

  if (!ok) {
    error = dbTarget.lastError();
    qDebug() << "Filed: "
             << QString("delete from SO_SODETAILSPLAN: %1, err: %2")
                    .arg(dDate, error.text());
    return;
  }
}

void SoItemRdsWnd::insertPlan(const SoItemInfo &it, const QString &dDate,
                              int newQty) {
  QSqlDatabase dbTarget = QSqlDatabase::database(CONN_TARGET);
  QSqlQuery query(dbTarget);
  QSqlError error;
  QString cmd;

  cmd = " insert into SO_SODETAILSPLAN (SOHeaderID, iSOsID, dDate, "
        "iQuantity, RMK) values (:SOHeaderID, :iSOsID, :dDate, "
        ":iQuantity, :RMK)";
  query.prepare(cmd);
  query.bindValue(":SOHeaderID", it.soHeader.SOHeaderID);
  query.bindValue(":iSOsID", it.soItem.iSOsID);
  query.bindValue(":dDate", dDate);
  query.bindValue(":iQuantity", newQty);
  query.bindValue(":RMK", "");
  bool ok = query.exec();

  if (!ok) {
    error = dbTarget.lastError();
    qDebug() << QString("Failed: %1").arg(error.text());
    return;
  }
}

// 删除发货计划，（订单行项目+日期）
void SoItemRdsWnd::updatePlan(const SoItemInfo &it, const QString &dDate,
                              int newQty) {
  QSqlDatabase dbTarget = QSqlDatabase::database(CONN_TARGET);
  QSqlQuery query(dbTarget);
  QSqlError error;
  QString cmd;

  cmd = "update SO_SODETAILSPLAN set iQuantity = :iQuantity where dDate = "
        ":dDate and ISOSID = :ISOSID; ";
  query.prepare(cmd);
  query.bindValue(":iQuantity", newQty);
  query.bindValue(":dDate", dDate);
  query.bindValue(":ISOSID", it.soItem.iSOsID);

  bool ok = query.exec();

  if (!ok) {
    error = dbTarget.lastError();
    qDebug() << "Filed: "
             << QString("update SO_SODETAILSPLAN: %1, %2, err: %3")
                    .arg(dDate, QString::number(newQty), error.text());
    return;
  }
}

#include "moc_soitemrdswnd.cpp"



=== starterwnd.cpp 
﻿#include "starterwnd.h"
#include <QtSql>
#include <QtWidgets>

#include "availabilitycheckwnd.h"
#include "backflushoutwnd.h"
#include "backflushwnd.h"
#include "bomexplorerwnd.h"
#include "deliveryplanwnd.h"
#include "etlwnd.h"
#include "fimonthtask.h"
#include "global.h"
#include "invmainwnd.h"
#include "modifypricewnd.h"
#include "monthlyplanwnd.h"
//#include "otherstockoutwnd.h"
#include "passwordwnd.h"
#include "refpricemainwnd.h"
#include "soitemrdswnd.h"
#include "stdmainwnd.h"
#include "transpartswnd.h"

StarterWnd::StarterWnd(QWidget *parent) : QWidget(parent) { prepareUI(); }

void StarterWnd::prepareUI() {
  QPushButton *btnForcast = new QPushButton(tr("销售预测"));
  QPushButton *btnMPS = new QPushButton(tr("生产计划"));
  QPushButton *btnDN = new QPushButton(tr("发货计划"));
  QPushButton *btnDNCmp = new QPushButton(tr("计划比对"));
  QPushButton *btnStdTM = new QPushButton(tr("工时统计"));

  QPushButton *btnInv = new QPushButton(tr("存货档案"));
  QPushButton *btnBOM = new QPushButton(tr("BOM查看"));
  QPushButton *btnATP = new QPushButton(tr("缺料查看"));

  QPushButton *btnBackFlushOut = new QPushButton(tr("超前扣料"));
  QPushButton *btnBackFlush = new QPushButton(tr("扣料比对"));
  QPushButton *btnTransParts = new QPushButton(tr("生产调拨"));
  //  QPushButton *btnStockOutRed = new QPushButton(tr("出库单(红字)导入"));

  QPushButton *btnModifyPrice = new QPushButton(tr("价格调整"));
  QPushButton *btnRefPrice = new QPushButton(tr("参考单价"));
  QPushButton *btnRepairVou = new QPushButton(tr("修复不能记账"));
  QPushButton *btnReportWnd = new QPushButton(tr("数据导出"));

  QPushButton *btnPassword = new QPushButton(tr("修改密码"));

  connect(btnMPS, &QPushButton::clicked, this, [this]() {
    QMessageBox::information(this, tr("大郡"), tr("敬请期待."),
                             QMessageBox::Ok);
  });

  connect(btnForcast, &QPushButton::clicked, this, &StarterWnd::showForcast);
  connect(btnDN, &QPushButton::clicked, this, &StarterWnd::showDeliveryPlan);
  connect(btnDNCmp, &QPushButton::clicked, this,
          &StarterWnd::showDeliveryPlanCmp);

  connect(btnStdTM, &QPushButton::clicked, this, &StarterWnd::showStdMainWnd);

  connect(btnInv, &QPushButton::clicked, this, &StarterWnd::showInvMainWnd);
  connect(btnBOM, &QPushButton::clicked, this, &StarterWnd::showBOM);
  connect(btnATP, &QPushButton::clicked, this, &StarterWnd::showATP);
  connect(btnBackFlush, &QPushButton::clicked, this,
          &StarterWnd::showBackFlush);

  connect(btnBackFlushOut, &QPushButton::clicked, this,
          &StarterWnd::showBackFlushOut);

  connect(btnTransParts, &QPushButton::clicked, this,
          &StarterWnd::showTransParts);

  // 其他出库红字导入，使用 U8 标准功能；
  //  connect(btnStockOutRed, &QPushButton::clicked, this,
  //          &StarterWnd::showStockOutImportWnd);

  connect(btnModifyPrice, &QPushButton::clicked, this,
          &StarterWnd::showModifyPrice);

  connect(btnRefPrice, &QPushButton::clicked, this,
          &StarterWnd::showRefPriceWnd);

  connect(btnRepairVou, &QPushButton::clicked, this,
          &StarterWnd::showFIMonthWnd);

  connect(btnPassword, &QPushButton::clicked, this,
          &StarterWnd::showPasswordWnd);

  connect(btnReportWnd, &QPushButton::clicked, this,
          &StarterWnd::showReportWnd);

  QVBoxLayout *vCol1 = new QVBoxLayout;
  QVBoxLayout *vCol2 = new QVBoxLayout;
  QVBoxLayout *vCol3 = new QVBoxLayout;

  vCol1->addWidget(btnForcast);
  vCol1->addWidget(btnMPS);
  vCol1->addWidget(btnDN);
  vCol1->addWidget(btnDNCmp);
  vCol1->addWidget(btnStdTM);
  vCol1->addStretch();

  vCol2->addWidget(btnInv);
  vCol2->addWidget(btnBOM);
  vCol2->addWidget(btnATP);
  vCol2->addWidget(btnTransParts);
  vCol2->addWidget(btnBackFlushOut);
  vCol2->addWidget(btnBackFlush);

  // 由于还需要操作现存量的表，暂且使用U8标准导入功能
  //  vCol2->addWidget(btnStockOutRed);

  vCol2->addStretch();

  vCol3->addWidget(btnModifyPrice);
  vCol3->addWidget(btnRefPrice);
  vCol3->addWidget(btnRepairVou);
  vCol3->addWidget(btnReportWnd);
  vCol3->addWidget(btnPassword);
  vCol3->addStretch();

  QHBoxLayout *hBox = new QHBoxLayout;

  hBox->addLayout(vCol1);
  hBox->addLayout(vCol2);
  hBox->addLayout(vCol3);

  QVBoxLayout *vMain = new QVBoxLayout;
  vMain->addLayout(hBox);
  setLayout(vMain);

  setWindowTitle(tr("大郡"));

  Qt::WindowFlags flags = windowFlags() & ~Qt::WindowMinMaxButtonsHint;
  setWindowFlags(flags);

  resize(300, 150);
}

void StarterWnd::showForcast() {
  if (!forcastWnd) {
    forcastWnd = new MonthlyPlanWnd;
  }
  forcastWnd->showMaximized();
}

void StarterWnd::showDeliveryPlan() {
  if (!deliveryPlanWnd) {
    bool ok;
    QString text = QInputDialog::getText(this, tr("发货计划"), tr("口令:"),
                                         QLineEdit::Password, "", &ok);
    if (ok) {
      // 点击了确定
      if (isAuth("jihua", text)) {
        // 口令正确
        deliveryPlanWnd = new SoItemRdsWnd;
      } else {
        QMessageBox::information(this, tr("发货计划"), tr("口令错误"));
        return;
      }
    } else {
      // 点击了取消
      return;
    }
  }

  deliveryPlanWnd->showMaximized();
}

void StarterWnd::showBOM() {
  if (!bomWnd) {
    bomWnd = new BOMExplorerWnd;
  }

  bomWnd->showMaximized();
}

void StarterWnd::showATP() {
  if (!atpWnd) {
    atpWnd = new AvailabilityCheckWnd;
  }

  atpWnd->showMaximized();
}

void StarterWnd::showBackFlush() {
  if (!backFlushWnd) {
    backFlushWnd = new BackFlushWnd;
  }
  backFlushWnd->showMaximized();
}

void StarterWnd::showBackFlushOut() {
  if (!backFlushOutWnd) {
    backFlushOutWnd = new BackFlushOutWnd;
  }
  backFlushOutWnd->showMaximized();
}

void StarterWnd::showModifyPrice() {
  if (!modifyPriceWnd) {
    //    const QString password = "caiwu";

    bool ok;
    QString text = QInputDialog::getText(this, tr("价格调整"), tr("口令:"),
                                         QLineEdit::Password, "", &ok);
    if (ok) {
      // 点击了确定
      if (isAuth("caiwu", text)) {
        //      if (text.compare(password) == 0) {
        // 口令正确
        modifyPriceWnd = new ModifyPriceWnd;
      } else {
        QMessageBox::information(this, tr("价格调整"), tr("口令错误"));
        return;
      }
    } else {
      // 点击了取消
      return;
    }
  }
  modifyPriceWnd->show();
}

void StarterWnd::showTransParts() {
  if (!transPartsWnd) {
    transPartsWnd = new TransPartsWnd;
  }

  transPartsWnd->showMaximized();
}

void StarterWnd::showPasswordWnd() {
  if (!passwordWnd) {
    passwordWnd = new PasswordWnd;
  }

  passwordWnd->show();
}

// 其他出库红字，使用 U8 标准功能
// void StarterWnd::showStockOutImportWnd() {
//  if (!stockOutImportWnd) {
//    bool ok;
//    QString text =
//        QInputDialog::getText(this, tr("出库单(红色)导入"), tr("口令:"),
//                              QLineEdit::Password, "", &ok);
//    if (ok) {
//      // 点击了确定
//      if (isAuth("cangku", text)) {
//        // 口令正确
//        stockOutImportWnd = new StockOutImportWnd;
//      } else {
//        QMessageBox::information(this, tr("出库单(红色)导入"),
//        tr("口令错误"));
//        return;
//      }
//    } else {
//      // 点击了取消
//      return;
//    }
//  }

//  stockOutImportWnd->show();
//}

void StarterWnd::showDeliveryPlanCmp() {
  if (!deliveryPlanWndCmp) {
    deliveryPlanWndCmp = new DeliveryPlanWnd;
  }

  deliveryPlanWndCmp->showMaximized();
}

void StarterWnd::showStdMainWnd() {
  if (!stdMainWnd) {
    bool ok;
    QString text = QInputDialog::getText(this, tr("工时统计"), tr("口令:"),
                                         QLineEdit::Password, "", &ok);
    if (ok) {
      // 点击了确定
      if (isAuth("jihua", text)) {
        // 口令正确
        stdMainWnd = new StdMainWnd;
      } else {
        QMessageBox::information(this, tr("工时统计"), tr("口令错误"));
        return;
      }
    } else {
      // 点击了取消
      return;
    }
  }

  stdMainWnd->showMaximized();
}

void StarterWnd::showRefPriceWnd() {
  if (!refPriceWnd) {
    bool ok;
    QString text = QInputDialog::getText(this, tr("参考价格"), tr("口令:"),
                                         QLineEdit::Password, "", &ok);
    if (ok) {
      // 点击了确定
      if (isAuth("caiwu", text)) {
        // 口令正确
        refPriceWnd = new RefPriceMainWnd;
      } else {
        QMessageBox::information(this, tr("参考价格"), tr("口令错误"));
        return;
      }
    } else {
      // 点击了取消
      return;
    }
  }

  refPriceWnd->showMaximized();
}

void StarterWnd::showFIMonthWnd() {
  if (!fimonthWnd) {
    bool ok;
    QString text = QInputDialog::getText(this, tr("月结处理"), tr("口令:"),
                                         QLineEdit::Password, "", &ok);
    if (ok) {
      // 点击了确定
      if (isAuth("caiwu", text)) {
        // 口令正确
        fimonthWnd = new FIMonthTask;
      } else {
        QMessageBox::information(this, tr("月结处理"), tr("口令错误"));
        return;
      }
    } else {
      // 点击了取消
      return;
    }
  }

  fimonthWnd->show();
}

void StarterWnd::showInvMainWnd() {
  if (!invMainWnd) {
    invMainWnd = new InvMainWnd;
  }

  invMainWnd->showMaximized();
}

void StarterWnd::showReportWnd() {
  if (!reportWnd) {
    bool ok;
    QString text = QInputDialog::getText(this, tr("数据导出"), tr("口令:"),
                                         QLineEdit::Password, "", &ok);
    if (ok) {
      // 点击了确定
      if (isAuth("caiwu", text)) {
        // 口令正确
        reportWnd = new ReportWnd;
      } else {
        QMessageBox::information(this, tr("数据导出"), tr("口令错误"));
        return;
      }
    } else {
      // 点击了取消
      return;
    }
  }

  reportWnd->showMaximized();
}

bool StarterWnd::isAuth(const QString &type, const QString &input) {
  return PasswordWnd::checkPassword(type, input);
}

#include "moc_starterwnd.cpp"



=== stdmainwnd.cpp 
﻿#include "stdmainwnd.h"

#include "stdmonthwnd.h"
#include "stdtmwnd.h"

StdMainWnd::StdMainWnd(QWidget *parent) : QWidget(parent) {
  prepareUI();
  showMaximized();
}

void StdMainWnd::prepareUI() {
  tabs = new QTabWidget;

  tabs->addTab(createTab1(), tr("工时统计"));
  tabs->addTab(createTab2(), tr("工时标准"));

  QVBoxLayout *vBox = new QVBoxLayout;
  vBox->addWidget(tabs);
  setLayout(vBox);

  setWindowTitle(tr("工时统计"));
}

QWidget *StdMainWnd::createTab1() { return new StdTMWnd; }

QWidget *StdMainWnd::createTab2() { return new StdMonthWnd; }

#include "moc_stdmainwnd.cpp"



=== stdmonthwnd.cpp 
﻿#include "stdmonthwnd.h"

#include "cursorguard.h"
#include "excelapp.h"
#include "global.h"
#include <QAxObject>
#include <QtSql>
#include <QtWidgets>

StdMonthWnd::StdMonthWnd(QWidget *parent) : QWidget(parent) {
  prepareUI();
  connect(&watch, SIGNAL(finished()), this, SLOT(postFetchItems()));

  // 更新后的回调函数
  connect(&watchUpload, SIGNAL(finished()), this, SLOT(postUpload()));

  showMaximized();
}

// 查找所有月份中，是否有重复的工时
void StdMonthWnd::btnCheckDup() {
  QString sqlCmd =
      " select s.MONTH, s.ORDR_TYP, s.MATRL_TYP, s.MATRL_CDE, count(1) cnt  "
      " from T_STD_TIME s "
      " group by s.MONTH, s.ORDR_TYP, s.MATRL_TYP, s.MATRL_CDE "
      " having count(1) > 1; ";

  QSqlDatabase db = QSqlDatabase::database(CONN_TARGET);
  QSqlQuery query(db);
  query.setForwardOnly(true);
  query.prepare(sqlCmd);

  bool ok = query.exec();
  if (!ok) {
    QSqlError error = db.lastError();
    qDebug() << "Filed: btnCheckDup " << QString("err: %1").arg(error.text());
    return;
  }

  // 只删除内容，不删除表头
  dupWidget->clearContents();

  // 结果集先存放到 vector 中
  std::vector<QStringList> items;
  // sql 返回的总列数 5
  const int colCount = 5;
  while (query.next()) {
    QStringList line;
    for (int c = 0; c < colCount; c++) {
      QString val = query.value(c).toString();
      line.push_back(val);
    }

    items.push_back(line);
  }

  int size = (int)items.size();
  // 如果有重复的工时，显示；否则，不显示；
  if (size > 0) {
    QMessageBox::critical(this, tr("工时重复"),
                          tr("有重复的工时记录，请处理！"));

    // 必须设置 widget 的行数
    dupWidget->setRowCount(size);

    // 从 vector 中复制到 widget 中
    int r = 0;
    for (const auto &item : items) {
      for (int c = 0; c < colCount; c++) {
        QString val = item.at(c);

        QTableWidgetItem *newItem = new QTableWidgetItem(val);
        dupWidget->setItem(r, c, newItem);
      }

      r++;
    }

    dupWidget->show();
  } else {
    QMessageBox::information(this, tr("工时重复"),
                             tr("恭喜你，没有重复的工时记录"));
    dupWidget->hide();
  }
}

void StdMonthWnd::prepareUI() {
  QWidget *w = createTab1();
  QVBoxLayout *vBox = new QVBoxLayout;
  vBox->addWidget(w);
  setLayout(vBox);

  setWindowTitle(tr("标准工时"));
}

// 工时统计
QWidget *StdMonthWnd::createTab1() {
  QLabel *lfrom = new QLabel(tr("开始日期"));
  lfrom->setAlignment(Qt::AlignRight | Qt::AlignCenter);
  QLabel *lto = new QLabel(tr("结束日期"));
  lto->setAlignment(Qt::AlignRight | Qt::AlignCenter);

  // 默认之前一个星期；
  QDate t1, t2;
  t2 = QDate::currentDate();
  t1 = t2.addDays(-7);

  dteFrom = new QDateTimeEdit(t1);
  dteFrom->setCalendarPopup(true);
  dteFrom->setDisplayFormat(dateFormat);

  dteTo = new QDateTimeEdit(t2);
  dteTo->setCalendarPopup(true);
  dteTo->setDisplayFormat(dateFormat);

  btnSearch = new QPushButton(tr("查找"));
  btnUpload = new QPushButton(tr("导入"));
  btnExport = new QPushButton(tr("导出"));
  btnCheck = new QPushButton(tr("检查"));

  connect(btnSearch, &QPushButton::clicked, this,
          &StdMonthWnd::btnSearchClicked);

  connect(btnUpload, &QPushButton::clicked, this, &StdMonthWnd::uploadItems);

  connect(btnExport, &QPushButton::clicked,
          [this]() { exportTableView(tvPP); });

  connect(btnCheck, &QPushButton::clicked, this, &StdMonthWnd::btnCheckDup);

  QHBoxLayout *hlayout = new QHBoxLayout;
  hlayout->addWidget(lfrom);
  hlayout->addWidget(dteFrom);
  hlayout->addWidget(lto);
  hlayout->addWidget(dteTo);
  hlayout->addWidget(btnSearch);
  hlayout->addWidget(btnUpload);
  hlayout->addWidget(btnExport);
  hlayout->addWidget(btnCheck);

  // 工时的列表
  tvPP = new QTableView;
  tvPP->setStyleSheet("font: 8pt 微软雅黑;");
  ppModel = new QStandardItemModel;

  // 形成 model: 标题
  QStringList headers;
  headers << "期间"
          << "工单类型"
          << "物料类型"
          << "料号"
          << "名称"
          << "标准工时(H)"
          << "备注";
  ppModel->setHorizontalHeaderLabels(headers);
  tvPP->setModel(ppModel);

  QVBoxLayout *vBox = new QVBoxLayout;
  vBox->addLayout(hlayout);

  // 重复工时的列表
  dupWidget = new QTableWidget(this);
  dupWidget->setColumnCount(5);
  QStringList dupHeaders;
  dupHeaders << "月份"
             << "工单类型"
             << "物料类型"
             << "料号"
             << "重复数量";
  dupWidget->setHorizontalHeaderLabels(dupHeaders);

  // 默认不显示
  dupWidget->hide();

  // 重复工时的列表
  vBox->addWidget(dupWidget);
  // 工时列表
  vBox->addWidget(tvPP);

  QWidget *w = new QWidget;
  w->setLayout(vBox);

  return w;
}

void StdMonthWnd::exportTableView(QTableView *view) {
  QString fileName = QFileDialog::getSaveFileName(
      this, "保存",
      QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation),
      "Excel 文件(*.xlsx)");

  if (fileName != "") {
    bool ok = ExcelApp::instance()->exportTableView(view, fileName);
    if (ok) {
      QMessageBox::information(this, tr("导出"), tr("导出完毕"));
    }
  }
}

void StdMonthWnd::btnSearchClicked() {
  // 从 UI 取得用户输入的查询条件；
  QString from = dteFrom->date().toString(dateFormat);
  QString to = dteTo->date().toString(dateFormat);

  // 和 sql 对应
  QStringList condList;

  // 入库时间
  condList.append(
      QString(" and (a.FIS_DTE >= '%1' and a.FIS_DTE < '%2')").arg(from, to));

  QString cond = condList.join(" ");
  QString sqlTemplate = loadSqlCmd("8.sql");
  QString sqlCmd = sqlTemplate.arg(cond);

  qDebug() << "temp: " << sqlTemplate << "\ncmd: " << sqlCmd;

  QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));
  setAllBtnStatus(false);

  QFuture<void> future =
      QtConcurrent::run([this, sqlCmd]() { fetchItems(sqlCmd); });

  watch.setFuture(future);
}

void StdMonthWnd::fetchItems(const QString &sqlCmd) {
  QSqlDatabase db = QSqlDatabase::database(CONN_TARGET);
  QSqlQuery query(db);
  query.setForwardOnly(true);
  query.prepare(sqlCmd);

  bool ok = query.exec();

  if (!ok) {
    QSqlError error = db.lastError();
    qDebug() << "Filed: btnSearchClicked "
             << QString("err: %1").arg(error.text());
    return;
  }

  allItems.clear();
  while (query.next()) {
    QStringList item;

    // 不同列的处理
    for (int c = 0; c <= colCnt; c++) {
      if (c == 0 || c == 6) {
        // 数字类型
        item.push_back(QString::number(query.value(c).toDouble(), 10, 4));
      } else {
        // 字符类型
        item.push_back(query.value(c).toString());
      }
    }

    allItems.push_back(item);
  }
}

void StdMonthWnd::postFetchItems() {
  QStandardItemModel *model = ppModel;
  QTableView *tableView = tvPP;

  tableView->setUpdatesEnabled(false);

  // 把结果集，显示在tableview 中；
  // 结果集中都是字符；
  model->removeRows(0, model->rowCount());
  int row = 0;
  for (const auto &it : allItems) {
    // 第一列是 ID，不显示，从第二列开始
    for (int c = 1; c <= colCnt; c++) {
      model->setItem(row, c - 1, new QStandardItem(it.at(c)));
    }

    row++;
  }

  tableView->resizeColumnsToContents();
  tableView->setUpdatesEnabled(true);

  setAllBtnStatus(true);

  // 检查是否有重复的工时；
  btnCheckDup();

  QApplication::restoreOverrideCursor();

  QMessageBox::information(this, tr(""), tr("执行完毕"));
}

void StdMonthWnd::setAllBtnStatus(bool enabled) {
  // 点击 更新 后，所有 btn 都 disable 掉
  btnUpload->setEnabled(enabled);
  btnSearch->setEnabled(enabled);
  btnExport->setEnabled(enabled);
}

std::vector<StandTM> StdMonthWnd::loadItems() {
  std::vector<StandTM> items;

  QString fileName = QFileDialog::getOpenFileName(this, QString(), QString(),
                                                  "excel(*.xls *.xlsx)");
  if (fileName.isEmpty()) {
    return items;
  }

  CursorGuard cg;

  qDebug() << "reading:" << fileName;

  QElapsedTimer timer;
  timer.start();

  QAxObject *pWorkbooks = ExcelApp::instance()->getWorkbooks();

  QAxObject *workbook =
      pWorkbooks->querySubObject("Open (const QString &)", fileName);

  // 读取 sheet1 的内容
  QAxObject *worksheets = workbook->querySubObject("WorkSheets");
  QAxObject *worksheet = worksheets->querySubObject("Item(int)", 1);

  qDebug() << timer.elapsed() << " Open excel sheet1. ";

  // 从第二行开始，最多 3000 行
  //  timer.restart();
  QString dataRange = "A2:G3000";
  QAxObject *range = worksheet->querySubObject("Range(QString)", dataRange);
  QVariant excel_data = range->dynamicCall("Value()");
  qDebug() << timer.elapsed() << " read range.";

  // 取得读到的所有行
  QVariantList rows = excel_data.toList();

  int rowCount = rows.count();
  qDebug() << timer.elapsed() << "total rows: " << rowCount;

  if (rowCount == 0) {
    qDebug() << "no data. ";
    return items;
  }

  QVariantList row;
  for (int i = 0; i < rowCount; i++) {
    row = rows[i].toList();

    QString firstCol = row[0].toString().trimmed();

    // 第一列：期间；
    // 为空，表示结束
    if (firstCol.length() == 0) {
      qDebug() << "The last: " << i;
      break;
    }

    StandTM item;
    item.fisDate = firstCol;

    // 第二列：生产订单类型
    item.orderType = row[1].toString().trimmed();

    // 第三列：产品类别
    item.matType = row[2].toString().trimmed();

    // 产品编码,产品名称,单位工时(H), 备注
    item.matCode = row[3].toString().trimmed();
    item.matName = row[4].toString().trimmed();

    // 将数字转成字符串
    //    item.stdTM = QString::number(row[5].toDouble(), 10, 4);

    item.stdTM = row[5].toDouble();

    item.remark = row[6].toString().trimmed();

    // 提取月份，格式：fisDate: 2017-09-21
    item.month = item.fisDate.left(7);

    items.push_back(item);
  }

  // 关闭 excel 文件；
  workbook->dynamicCall("Close(Boolean)", false);

  return items;
}

void StdMonthWnd::uploadItems() {
  std::vector<StandTM> items = loadItems();

  if (items.size() > 0) {
    // 如果该月份已经有导入，提示：将被全量替换；
    if (!checkHistory(items)) {
      return;
    }

    // 更新前，disable 所有的 btn
    setAllBtnStatus(false);

    QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));

    // 执行更新
    QFuture<void> future =
        QtConcurrent::run([this, items]() { uploadItemsDo(items); });

    watch.setFuture(future);
  }
}

void StdMonthWnd::uploadItemsDo(const std::vector<StandTM> &items) {
  // 把 items 中的每个元素，插入表中；
  QString cmd = "insert t_std_time (FIS_DTE, ORDR_TYP, MATRL_TYP, MATRL_CDE, "
                "MATRL_NME, STD_TM, RMK, MONTH) "
                " values "
                " (:FIS_DTE, :ORDR_TYP, :MATRL_TYP, :MATRL_CDE, :MATRL_NME, "
                ":STD_TM, :RMK, :MONTH) ;";

  qDebug() << "cmd: " << cmd;

  QSqlDatabase db = QSqlDatabase::database(CONN_TARGET);
  QSqlQuery query(db);
  query.prepare(cmd);

  bool ok;
  for (auto const &i : items) {
    query.bindValue(":FIS_DTE", i.fisDate);
    query.bindValue(":ORDR_TYP", i.orderType);
    query.bindValue(":MATRL_TYP", i.matType);
    query.bindValue(":MATRL_CDE", i.matCode);
    query.bindValue(":MATRL_NME", i.matName);
    query.bindValue(":STD_TM", i.stdTM);
    query.bindValue(":RMK", i.remark);
    query.bindValue(":MONTH", i.month);

    ok = query.exec();
    if (!ok) {
      QSqlError error = db.lastError();
      qDebug() << QString("Failed: %1").arg(error.text());
      return;
    }
  }
}

bool StdMonthWnd::checkHistory(const std::vector<StandTM> &items) {
  // fisDate: 2017-09-22
  QSet<QString> monthSet;
  for (auto const &i : items) {
    monthSet.insert(i.month);
  }

  // 集合为空
  if (monthSet.size() == 0) {
    return false;
  }

  // 如果已经有之前月份的数据，提示：将全部删除，是否继续；
  // 是：按照月份，删除历史数据；
  // 否：终止本次上载
  QStringList alreadyHave;

  // 遍历本次上载的所有月份，
  foreach (const QString &v, monthSet) {
    if (isMonthExist(v)) {
      // 如果数据库中已经有该月数据
      QString t = v;
      alreadyHave.push_back(t);
    }
  }

  // 如果 list 为空，表示所有月份都是第一次，返回 true；
  if (alreadyHave.size() == 0) {
    return true;
  }

  // 如果 不为空，询问是否删除；回答，否，返回false；回答是：对list
  // 中每一个，删除已有数据；
  QString m = QString("重复上载标准工时: %1").arg(alreadyHave.join(" "));
  QMessageBox msgBox;
  msgBox.setText(m);
  msgBox.setInformativeText(tr("已有标准工时将被删除，是否继续？"));
  msgBox.setStandardButtons(QMessageBox::Ok | QMessageBox::Cancel);
  msgBox.setDefaultButton(QMessageBox::Cancel);
  int ret = msgBox.exec();

  if (ret == QMessageBox::Cancel) {
    return false;
  }

  foreach (const QString &m, alreadyHave) { deleteByMonth(m); }
  return true;
}

bool StdMonthWnd::isMonthExist(const QString &m) {
  QString cmd = "select count(1) from t_std_time where month = :month ";

  qDebug() << "cmd: " << cmd;

  QSqlDatabase db = QSqlDatabase::database(CONN_TARGET);
  QSqlQuery query(db);
  query.prepare(cmd);

  bool ok;
  query.bindValue(":month", m);

  ok = query.exec();
  if (!ok) {
    QSqlError error = db.lastError();
    qDebug() << QString("Failed: %1").arg(error.text());
    return true;
  }

  int cnt;
  while (query.next()) {
    cnt = query.value(0).toInt();
    if (cnt >= 1) {
      return true;
    }
  }

  return false;
}

void StdMonthWnd::deleteByMonth(const QString &m) {
  QString cmd = "delete from t_std_time where month = :month ";

  qDebug() << "cmd: " << cmd;

  QSqlDatabase db = QSqlDatabase::database(CONN_TARGET);
  QSqlQuery query(db);
  query.prepare(cmd);

  bool ok;
  query.bindValue(":month", m);

  ok = query.exec();
  if (!ok) {
    QSqlError error = db.lastError();
    qDebug() << QString("Failed: %1").arg(error.text());
    return;
  }
}

void StdMonthWnd::postUpload() {
  // 更新完毕后的回调函数；
  setAllBtnStatus(true);

  // 检查是否有重复的工时；
  btnCheckDup();

  QApplication::restoreOverrideCursor();
  QMessageBox::information(this, tr("标准工时"), tr("导入完成"));
}

#include "moc_stdmonthwnd.cpp"



=== stdtmwnd.cpp 
﻿#include "stdtmwnd.h"

#include "excelapp.h"
#include "global.h"
#include <QtWidgets>
#include <Qtsql>

StdTMWnd::StdTMWnd(QWidget *parent) : QWidget(parent) {
  prepareUI();
  connect(&watch, SIGNAL(finished()), this, SLOT(postFetchItems()));
  showMaximized();
}

void StdTMWnd::prepareUI() {
  QWidget *w = createTab1();
  QVBoxLayout *vBox = new QVBoxLayout;
  vBox->addWidget(w);
  setLayout(vBox);

  setWindowTitle(tr("工时统计"));
}

// 工时统计
QWidget *StdTMWnd::createTab1() {
  QLabel *lfrom = new QLabel(tr("开始日期"));
  lfrom->setAlignment(Qt::AlignRight | Qt::AlignCenter);
  QLabel *lto = new QLabel(tr("结束日期"));
  lto->setAlignment(Qt::AlignRight | Qt::AlignCenter);

  // 默认之前一个星期；
  QDate t1, t2;
  t2 = QDate::currentDate();
  t1 = t2.addDays(-7);

  dtePPFrom = new QDateTimeEdit(t1);
  dtePPFrom->setCalendarPopup(true);
  dtePPFrom->setDisplayFormat(dateFormat);

  dtePPTo = new QDateTimeEdit(t2);
  dtePPTo->setCalendarPopup(true);
  dtePPTo->setDisplayFormat(dateFormat);

  btnPPSearch = new QPushButton(tr("查找"));
  QPushButton *btnPPExport = new QPushButton(tr("导出"));

  connect(btnPPSearch, &QPushButton::clicked, this,
          &StdTMWnd::btnPPSearchClicked);

  connect(btnPPExport, &QPushButton::clicked,
          [this]() { exportTableView(tvPP); });

  QHBoxLayout *hlayout = new QHBoxLayout;
  hlayout->addWidget(lfrom);
  hlayout->addWidget(dtePPFrom);
  hlayout->addWidget(lto);
  hlayout->addWidget(dtePPTo);
  hlayout->addWidget(btnPPSearch);
  hlayout->addWidget(btnPPExport);

  tvPP = new QTableView;
  tvPP->setStyleSheet("font: 8pt 微软雅黑;");
  ppModel = new QStandardItemModel;

  // 形成 model: 标题
  QStringList headers;
  headers << "月份"
          << "订单类型"
          << "订单号"
          << "料号"
          << "物料"
          << "项目编码"
          << "项目"
          << "制造类型"
          << "数量"
          << "工时标准"
          << "工时";
  ppModel->setHorizontalHeaderLabels(headers);
  tvPP->setModel(ppModel);

  QVBoxLayout *vBox = new QVBoxLayout;
  vBox->addLayout(hlayout);
  vBox->addWidget(tvPP);

  QWidget *w = new QWidget;
  w->setLayout(vBox);

  return w;
}

void StdTMWnd::exportTableView(QTableView *view) {
  QString fileName = QFileDialog::getSaveFileName(
      this, "保存",
      QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation),
      "Excel 文件(*.xlsx)");

  if (fileName != "") {
    bool ok = ExcelApp::instance()->exportTableView(view, fileName);
    if (ok) {
      QMessageBox::information(this, tr("导出"), tr("导出完毕"));
    }
  }
}

void StdTMWnd::btnPPSearchClicked() {
  // 从 UI 取得用户输入的查询条件；
  QString dteFrom = dtePPFrom->date().toString(dateFormat);
  QString dteTo = dtePPTo->date().toString(dateFormat);

  // 和 sql 对应
  QStringList condList;

  // 入库时间
  condList.append(
      QString(" and (h.dDate >= '%1' and h.dDate < '%2')").arg(dteFrom, dteTo));

  QString cond = condList.join(" ");
  QString sqlTemplate = loadSqlCmd("7.sql");
  QString sqlCmd = sqlTemplate.arg(cond);

  qDebug() << "temp: " << sqlTemplate << "\ncmd: " << sqlCmd;

  QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));
  btnPPSearch->setEnabled(false);

  QFuture<void> future =
      QtConcurrent::run([this, sqlCmd]() { fetchItems(sqlCmd); });

  watch.setFuture(future);
}

void StdTMWnd::fetchItems(const QString &sqlCmd) {
  QSqlDatabase db = QSqlDatabase::database(CONN_SRC);
  QSqlQuery query(db);
  query.setForwardOnly(true);
  query.prepare(sqlCmd);

  bool ok = query.exec();

  if (!ok) {
    QSqlError error = db.lastError();
    qDebug() << "Filed: btnPPSearchClicked "
             << QString("err: %1").arg(error.text());
    return;
  }

  allItems.clear();
  while (query.next()) {
    QStringList item;

    // 不同列的处理
    for (int c = 0; c <= colCnt; c++) {
      if (c >= 8) {
        // 数字类型
        item.push_back(QString::number(query.value(c).toDouble(), 10, 4));
      } else {
        // 字符类型
        item.push_back(query.value(c).toString());
      }
    }

    allItems.push_back(item);
  }
}

void StdTMWnd::postFetchItems() {
  QStandardItemModel *model = ppModel;
  QTableView *tableView = tvPP;

  tableView->setUpdatesEnabled(false);

  // 把结果集，显示在tableview 中；
  // 结果集中都是字符；
  model->removeRows(0, model->rowCount());
  int row = 0;
  for (const auto &it : allItems) {
    for (int c = 0; c <= colCnt; c++) {
      model->setItem(row, c, new QStandardItem(it.at(c)));
    }

    row++;
  }

  tableView->resizeColumnsToContents();
  tableView->setUpdatesEnabled(true);

  btnPPSearch->setEnabled(true);
  QApplication::restoreOverrideCursor();

  QMessageBox::information(this, tr(""), tr("执行完毕"));
}

#include "moc_stdtmwnd.cpp"



=== stockoutimportwnd.cpp 
﻿#include "stockoutimportwnd.h"

#include "cursorguard.h"
#include "excelapp.h"
#include "global.h"
#include <QAxObject>
#include <QtSql>

StockOutImportWnd::StockOutImportWnd(QWidget *parent) : QWidget(parent) {
  prepareUI();

  // 更新后的回调函数
  connect(&watchAll, SIGNAL(finished()), this, SLOT(postUpload()));
}

void StockOutImportWnd::prepareUI() {
  btnUpload = new QPushButton(tr("出库单(红字)导入"));

  connect(btnUpload, &QPushButton::clicked, this,
          &StockOutImportWnd::uploadItems);

  results = new QTextEdit;
  results->append(tr("导入前，务必核对，务必核对！保留好底稿！"));

  QVBoxLayout *vMain = new QVBoxLayout;

  vMain->addWidget(btnUpload);

  vMain->addWidget(results);
  setLayout(vMain);

  resize(300, 400);

  setWindowTitle(tr("出库单(红色)导入"));

  Qt::WindowFlags flags = windowFlags() & ~Qt::WindowMinMaxButtonsHint;
  setWindowFlags(flags);
}

std::vector<StockOutItem> StockOutImportWnd::loadItems() {
  std::vector<StockOutItem> items;

  QString fileName = QFileDialog::getOpenFileName(this, QString(), QString(),
                                                  "excel(*.xls *.xlsx)");
  if (fileName.isEmpty()) {
    return items;
  }

  CursorGuard cg;

  qDebug() << "reading:" << fileName;

  QElapsedTimer timer;
  timer.start();

  QAxObject *pWorkbooks = ExcelApp::instance()->getWorkbooks();

  QAxObject *workbook =
      pWorkbooks->querySubObject("Open (const QString &)", fileName);

  // 读取 sheet1 的内容
  QAxObject *worksheets = workbook->querySubObject("WorkSheets");
  QAxObject *worksheet = worksheets->querySubObject("Item(int)", 1);

  qDebug() << timer.elapsed() << " Open excel sheet1. ";

  // 从第二行开始，最多 500 行
  //  timer.restart();
  QString dataRange = "A2:H500";
  QAxObject *range = worksheet->querySubObject("Range(QString)", dataRange);
  QVariant excel_data = range->dynamicCall("Value()");
  qDebug() << timer.elapsed() << " read range.";

  // 取得读到的所有行
  QVariantList rows = excel_data.toList();

  int rowCount = rows.count();
  qDebug() << timer.elapsed() << "total rows: " << rowCount;

  if (rowCount == 0) {
    qDebug() << "no data. ";
    return items;
  }

  // 批次，有效期的默认值：
  // 当前日期
  // 当前日期 + 1年
  QDate curr = QDate::currentDate();
  QString batch = curr.toString("yyyyMMdd");
  QString madeDate = curr.toString("yyyy-MM-dd");

  QDate nextYr = curr.addYears(1);
  QString expDate = nextYr.toString("yyyy-MM-dd");

  QVariantList row;
  for (int i = 0; i < rowCount; i++) {
    row = rows[i].toList();

    QString firstCol = row[0].toString();

    // 第一列：单据号；
    // 为空，表示结束
    if (firstCol.length() == 0) {
      qDebug() << "The last: " << i;
      break;
    }

    StockOutItem item;
    QString t = QString("0000000000") + firstCol;
    item.headCode = t.right(10);

    // 第二列：料号
    item.invCode = row[1].toString();

    // 第三列：数量；
    item.quantity = row[2].toDouble();

    // 项目，项目类型
    item.projClass = row[3].toString();
    item.projName = row[4].toString();

    if (item.projClass.length() == 0) {
      item.projClass = "00";
    }

    // 批次、生产日期、有效期止
    item.batch = row[5].toString();
    item.madeDate = row[6].toString();
    item.expDate = row[7].toString();

    // 如果用户未输入，使用默认值；
    if (item.batch.length() == 0) {
      item.batch = batch;
    }
    if (item.madeDate.length() == 0) {
      item.madeDate = madeDate;
    }
    if (item.expDate.length() == 0) {
      item.expDate = expDate;
    }

    items.push_back(item);
  }

  // 关闭 excel 文件；
  workbook->dynamicCall("Close(Boolean)", false);

  return items;
}

void StockOutImportWnd::setAllBtnStatus(bool enabled) {
  // 点击 更新 后，所有 btn 都 disable 掉
  btnUpload->setEnabled(enabled);
  results->setEnabled(enabled);
}

bool StockOutImportWnd::isMultiHead(const std::vector<StockOutItem> &items) {
  QSet<QString> headCode;
  for (auto const &i : items) {
    headCode.insert(i.headCode);
  }

  if (headCode.size() != 1) {
    return true;
  } else {
    return false;
  }
}

bool StockOutImportWnd::fillUpItems(std::vector<StockOutItem> &items) {
  // 根据 headCode 取出 headID
  // 根据 headID，取出最大的行项目 seq；
  // 在行项目表中，取出最大的 AutoID；

  qlonglong headID;
  int maxSeq;
  qlonglong maxAutoID;

  fetchInfo(items.at(0), headID, maxSeq, maxAutoID);

  if (headID == -1) {
    QMessageBox::information(this, tr("出库单(红字)导入"), tr("单号不存在！"));

    return false;
  }

  if (maxSeq == -1) {
    QMessageBox::information(this, tr("出库单(红字)导入"),
                             tr("行项目不存在！"));

    return false;
  }

  if (maxAutoID == -1) {
    QMessageBox::information(this, tr("出库单(红字)导入"), tr("行项目出错！"));

    return false;
  }

  int idx = 1;
  for (auto &i : items) {
    i.headID = headID;

    i.seq = maxSeq + idx;
    i.itemID = maxAutoID + idx;
    idx++;

    if (i.projName.length() == 0) {
      QMessageBox::information(this, tr("出库单(红字)导入"),
                               tr("项目号未输入！"));

      return false;
    }

    if (i.invCode.length() == 0) {
      QMessageBox::information(this, tr("出库单(红字)导入"),
                               tr("料号不能为空"));

      return false;
    }

    if (abs(i.quantity) < 0.001) {
      QMessageBox::information(this, tr("出库单(红字)导入"),
                               tr("数量不能为零"));

      return false;
    }
  }

  return true;
}

void StockOutImportWnd::updateMaxRdID(qlonglong maxID) {
  qlonglong id = maxID - 1000000000;

  QString cmd = "update UfSystem..Ua_identity set iChildID = :maxID "
                " where cAcc_Id = :acct and cVouchType = 'rd'";

  QSqlDatabase db = QSqlDatabase::database(CONN_SRC);
  QSqlQuery query(db);
  query.prepare(cmd);
  query.bindValue(":maxID", id);
  query.bindValue(":acct", "001");

  qDebug() << "cmd: " << cmd;

  bool ok = query.exec();
  if (!ok) {
    QSqlError err = db.lastError();
    QString msg = QString("Failed to update rd: ").arg(err.text());
    msgList.append(msg);
    qDebug() << msg;
  }
}

void StockOutImportWnd::fetchInfo(const StockOutItem &item, qlonglong &headID,
                                  int &maxSeq, qlonglong &maxAutoID) {
  QSqlDatabase db = QSqlDatabase::database(CONN_SRC);
  QSqlQuery query(db);

  // 根据 headCode 找到 headID
  QString cmd = "select ID from RdRecord09 h where h.cCode = :headCode";

  query.prepare(cmd);
  query.bindValue(":headCode", item.headCode);

  qDebug() << "cmd: " << cmd;

  bool ok = query.exec();
  if (!ok) {
    QSqlError err = db.lastError();
    QString msg = QString("Failed to fetchInfo: (%1)").arg(err.text());
    msgList.append(msg);
    qDebug() << msg;
  }

  // -1 单号不存在
  headID = -1;
  while (query.next()) {
    headID = query.value(0).toLongLong();
    break;
  }

  // 取得最大的 seq
  cmd = "select max(iRowNo) from RdRecords09 h where id = :headID";
  query.prepare(cmd);
  query.bindValue(":headID", headID);

  ok = query.exec();
  if (!ok) {
    QSqlError err = db.lastError();
    QString msg = QString("Failed to fetchInfo: (%1)").arg(err.text());
    msgList.append(msg);
    qDebug() << msg;
  }

  // -1 单号不存在
  maxSeq = -1;
  while (query.next()) {
    maxSeq = query.value(0).toLongLong();
    break;
  }

  // 取得行项目最大的 AutoID
  cmd = "select max(AutoID) lastID from RdRecords09 h";
  ok = query.exec(cmd);
  if (!ok) {
    QSqlError err = db.lastError();
    QString msg = QString("Failed to fetchInfo: (%1)").arg(err.text());
    msgList.append(msg);
    qDebug() << msg;
  }

  // -1 单号不存在
  maxAutoID = -1;
  while (query.next()) {
    maxAutoID = query.value(0).toLongLong();
    break;
  }
}

void StockOutImportWnd::uploadItems() {
  std::vector<StockOutItem> items = loadItems();

  if (items.size() > 0) {

    // 如果有多个单号，报错退出；
    if (isMultiHead(items)) {
      QMessageBox::information(this, tr("出库单(红字)导入"),
                               tr("不允许一次性导入多张单号！"));
      return;
    }

    if (!fillUpItems(items)) {
      return;
    }

    // 更新前，disable 所有的 btn
    setAllBtnStatus(false);

    QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));

    // 执行更新
    QFuture<void> future =
        QtConcurrent::run([this, items]() { uploadItemsDo(items); });

    watchAll.setFuture(future);
  }
}

void StockOutImportWnd::uploadItemsDo(const std::vector<StockOutItem> &items) {
  // 把 items 中的每个元素，插入表中；
  QString cmd = "insert RdRecords09 (AutoID, ID, cInvCode, iQuantity, "
                "cItem_class, cItemCode, iRowNo, cBatch, dMadeDate, dVDate) "
                " values "
                " (:AutoID, :ID, :cInvCode, :iQuantity, :cItem_class, "
                ":cItemCode, :iRowNo, :cBatch, :dMadeDate, :dVDate);";

  qDebug() << "cmd: " << cmd;

  QSqlDatabase dbTarget = QSqlDatabase::database(CONN_SRC);
  QSqlQuery query(dbTarget);
  query.prepare(cmd);

  bool ok;
  for (auto const &i : items) {
    query.bindValue(":AutoID", i.itemID);
    query.bindValue(":ID", i.headID);
    query.bindValue(":cInvCode", i.invCode);
    query.bindValue(":iQuantity", i.quantity);
    query.bindValue(":cItem_class", i.projClass);
    query.bindValue(":cItemCode", i.projName);
    query.bindValue(":iRowNo", i.seq);
    query.bindValue(":cBatch", i.batch);
    query.bindValue(":dMadeDate", i.madeDate);
    query.bindValue(":dVDate", i.expDate);

    ok = query.exec();
    if (!ok) {
      QSqlError error = dbTarget.lastError();
      qDebug() << QString("Failed: %1").arg(error.text());
      return;
    }
  }

  // 更新 rd 的最大ID
  qlonglong id = items.at((items.size() - 1)).itemID;
  updateMaxRdID(id);
}

void StockOutImportWnd::postUpload() {
  // 更新完毕后的回调函数；
  setAllBtnStatus(true);

  // 结果写入文本框；
  results->clear();
  for (const auto &s : msgList) {
    results->insertPlainText(s);
  }

  QApplication::restoreOverrideCursor();
  QMessageBox::information(this, tr("出库单(红字)导入"), tr("导入完成"));
}

#include "moc_stockoutimportwnd.cpp"



=== transpartswnd.cpp 
﻿#include "transpartswnd.h"

#include "excelapp.h"
#include "global.h"
#include <QtSql>
#include <QtWidgets>

TransPartsWnd::TransPartsWnd(QWidget *parent) : QWidget(parent) {
  prepareUI();

  connect(&watch, SIGNAL(finished()), this, SLOT(postFetchItems()));
}

void TransPartsWnd::prepareUI() {

  QLabel *lfrom = new QLabel(tr("开始日期"));
  lfrom->setAlignment(Qt::AlignRight | Qt::AlignCenter);
  QLabel *lto = new QLabel(tr("结束日期"));
  lto->setAlignment(Qt::AlignRight | Qt::AlignCenter);

  // 默认之前一个星期；
  QDate t1, t2;
  t2 = QDate::currentDate();
  t1 = t2.addDays(-7);

  dteFrom = new QDateTimeEdit(t1);
  dteFrom->setCalendarPopup(true);
  dteFrom->setDisplayFormat(dateFormat);

  dteTo = new QDateTimeEdit(t2);
  dteTo->setCalendarPopup(true);
  dteTo->setDisplayFormat(dateFormat);

  QLabel *lMaterial = new QLabel(tr("物料"));
  leMaterial = new QLineEdit;

  QLabel *lOrderfrom = new QLabel(tr("订单号起"));
  lOrderfrom->setAlignment(Qt::AlignRight | Qt::AlignCenter);
  QLabel *lOrderTo = new QLabel(tr("订单号止"));
  lOrderTo->setAlignment(Qt::AlignRight | Qt::AlignCenter);
  leOrderFrom = new QLineEdit;
  leOrderTo = new QLineEdit;

  chkOnlyDiff = new QCheckBox(tr("仅显示有差异"));
  chkOnlyDiff->setChecked(true);

  btnSearch = new QPushButton(tr("查找"));
  QPushButton *btnExport = new QPushButton(tr("导出"));

  connect(btnSearch, &QPushButton::clicked, this,
          &TransPartsWnd::btnSearchClicked);

  connect(btnExport, &QPushButton::clicked,
          [this]() { exportTableView(tvParts); });

  QHBoxLayout *hlayout = new QHBoxLayout;
  hlayout->addWidget(lfrom);
  hlayout->addWidget(dteFrom);
  hlayout->addWidget(lto);
  hlayout->addWidget(dteTo);
  hlayout->addWidget(lMaterial);
  hlayout->addWidget(leMaterial);
  hlayout->addWidget(lOrderfrom);
  hlayout->addWidget(leOrderFrom);
  hlayout->addWidget(lOrderTo);
  hlayout->addWidget(leOrderTo);
  hlayout->addWidget(leOrderTo);
  hlayout->addWidget(chkOnlyDiff);
  hlayout->addWidget(btnSearch);
  hlayout->addWidget(btnExport);

  tvParts = new QTableView;
  tvParts->setStyleSheet("font: 8pt 微软雅黑;");
  partsModel = new QStandardItemModel;

  // 形成 model: 标题
  QStringList headers;
  headers << "订单日期"
          << "订单号"
          << "产品"
          << "名称"
          << "数量"
          << "子件"
          << "子件名称"
          << "单耗"
          << "调拨数量"
          << "差异";
  partsModel->setHorizontalHeaderLabels(headers);
  tvParts->setModel(partsModel);

  QVBoxLayout *vBox = new QVBoxLayout;
  vBox->addLayout(hlayout);
  vBox->addWidget(tvParts);

  setLayout(vBox);
  setWindowTitle(tr("生产调拨"));

  showMaximized();
}

void TransPartsWnd::btnSearchClicked() {
  // 从界面读入查询条件
  // 订单创建日期，起/止
  QString pFrom = dteFrom->date().toString(dateFormat);
  QString pTo = dteTo->date().toString(dateFormat);

  // 物料号/物料名
  QString pInv = leMaterial->text().trimmed();
  if (pInv.length() == 0) {
    pInv = "%";
  } else {
    pInv = "%" + pInv + "%";
  }

  // 订单号 起/止
  QString inputFrom = leOrderFrom->text().trimmed();
  const int length = 10;
  QString pMoFrom = "0000000000" + inputFrom;
  pMoFrom = pMoFrom.right(length);

  QString pMoTo = leOrderTo->text().trimmed();
  if (inputFrom.length() > 0 && pMoTo.length() == 0) {
    // 如果 结束为空，那么默认等于 开始
    pMoTo = pMoFrom;
  } else {
    pMoTo = "9999999999" + pMoTo;
    pMoTo = pMoTo.right(length);
  }

  bool onlyDiff = chkOnlyDiff->isChecked();

  QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));
  btnSearch->setEnabled(false);

  QFuture<void> future =
      QtConcurrent::run([this, pFrom, pTo, pInv, pMoFrom, pMoTo, onlyDiff]() {
        fetchItems(pFrom, pTo, pInv, pMoFrom, pMoTo, onlyDiff);
      });

  watch.setFuture(future);
}

QString TransPartsWnd::toNumberTxt(const QVariant &v) {
  return QString::number(v.toDouble(), 10, 4);
  //  return QString::number(v.toInt());
}

void TransPartsWnd::fetchItems(const QString &pFrom, const QString &pTo,
                               const QString &pInv, const QString &pMoFrom,
                               const QString &pMoTo, bool onlyDiff) {
  // 加载 sql
  QString sqlCmd = loadSqlCmd("3.sql");
  qDebug() << "cmd: " << sqlCmd;

  QSqlDatabase db = QSqlDatabase::database(CONN_SRC);
  QSqlQuery query(db);
  query.setForwardOnly(true);
  query.prepare(sqlCmd);

  query.bindValue(":pFrom", pFrom);
  query.bindValue(":pTo", pTo);
  query.bindValue(":pInv", pInv);
  query.bindValue(":pMoFrom", pMoFrom);
  query.bindValue(":pMoTo", pMoTo);

  int showAll = onlyDiff ? 0 : 1;
  query.bindValue(":showAll", showAll);

  bool ok = query.exec();

  if (!ok) {
    QSqlError error = db.lastError();
    qDebug() << "Filed: btnSearchClicked "
             << QString("err: %1").arg(error.text());
    return;
  }

  allItems.clear();
  while (query.next()) {
    TransPartsItem item;
    item.orderDate = query.value(0).toDate().toString(dateFormat);
    item.orderNo = query.value(1).toString();
    item.invCode = query.value(2).toString();
    item.invName = query.value(3).toString();

    //    item.outputQty = query.value(4).toString();
    item.outputQty = toNumberTxt(query.value(4));

    item.partCode = query.value(5).toString();
    item.partName = query.value(6).toString();

    //    item.baseQty = query.value(7).toString();
    //    item.txQty = query.value(8).toString();
    //    item.diffQty = query.value(9).toString();

    item.baseQty = toNumberTxt(query.value(7));
    item.txQty = toNumberTxt(query.value(8));
    item.diffQty = toNumberTxt(query.value(9));

    allItems.push_back(item);
  }
}

void TransPartsWnd::postFetchItems() {
  QStandardItemModel *model = partsModel;
  QTableView *tableView = tvParts;

  tableView->setUpdatesEnabled(false);

  model->removeRows(0, model->rowCount());
  int row = 0;
  for (const auto &it : allItems) {
    model->setItem(row, 0, new QStandardItem(it.orderDate));
    model->setItem(row, 1, new QStandardItem(it.orderNo));
    model->setItem(row, 2, new QStandardItem(it.invCode));
    model->setItem(row, 3, new QStandardItem(it.invName));
    model->setItem(row, 4, new QStandardItem(it.outputQty));
    model->setItem(row, 5, new QStandardItem(it.partCode));
    model->setItem(row, 6, new QStandardItem(it.partName));
    model->setItem(row, 7, new QStandardItem(it.baseQty));
    model->setItem(row, 8, new QStandardItem(it.txQty));
    model->setItem(row, 9, new QStandardItem(it.diffQty));

    row++;
  }

  tableView->resizeColumnsToContents();
  tableView->setUpdatesEnabled(true);

  btnSearch->setEnabled(true);
  QApplication::restoreOverrideCursor();

  QMessageBox::information(this, tr(""), tr("执行完毕"));
}

void TransPartsWnd::exportTableView(QTableView *view) {
  QString fileName = QFileDialog::getSaveFileName(
      this, "保存",
      QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation),
      "Excel 文件(*.xlsx)");

  if (fileName != "") {
    bool ok = ExcelApp::instance()->exportTableView(view, fileName);
    if (ok) {
      QMessageBox::information(this, tr("导出"), tr("导出完毕"));
    }
  }
}

#include "moc_transpartswnd.cpp"
